{"file_contents":{"railway_ultra_simple.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nRailway Deployment - ULTRA SIMPLE Voice Translation\nGUARANTEED TO WORK - No complex features\n\"\"\"\n\nimport os\nimport json\nimport time\nimport warnings\nimport requests\nfrom flask import Flask, request, Response\nimport gunicorn.app.base\n\n# Suppress warnings\nwarnings.filterwarnings(\"ignore\")\n\n# Set up Google Cloud credentials\ndef setup_google_credentials():\n    try:\n        creds_json = os.environ.get('GOOGLE_CREDENTIALS_JSON')\n        if creds_json:\n            creds_data = json.loads(creds_json)\n            temp_creds_path = '/tmp/google-credentials.json'\n            with open(temp_creds_path, 'w') as f:\n                json.dump(creds_data, f)\n            os.environ['GOOGLE_APPLICATION_CREDENTIALS'] = temp_creds_path\n            print(\"‚úÖ Google credentials set up\")\n            return True\n        return False\n    except Exception as e:\n        print(f\"‚ùå Credentials error: {e}\")\n        return False\n\ncredentials_setup = setup_google_credentials()\n\n# Import Google Cloud\ntry:\n    from google.cloud import translate_v2 as translate\n    GOOGLE_CLOUD_AVAILABLE = True\n    print(\"‚úÖ Google Cloud available\")\nexcept ImportError:\n    GOOGLE_CLOUD_AVAILABLE = False\n    print(\"‚ùå Google Cloud not available\")\n\napp = Flask(__name__)\n\n@app.route('/health')\ndef health_check():\n    return {\n        \"status\": \"healthy\",\n        \"google_cloud_available\": GOOGLE_CLOUD_AVAILABLE,\n        \"credentials_setup\": credentials_setup,\n        \"version\": \"15.0-ultra-simple\"\n    }, 200\n\n@app.route('/')\ndef home():\n    return {\n        \"message\": \"ULTRA SIMPLE Twilio Voice Translator\",\n        \"webhook\": \"/twilio-webhook\",\n        \"version\": \"15.0-ultra-simple\"\n    }, 200\n\n@app.route('/twilio-webhook', methods=['POST'])\ndef twilio_webhook():\n    call_sid = request.form.get('CallSid')\n    from_number = request.form.get('From')\n    \n    print(f\"\\nüìû CALL FROM: {from_number}\")\n    print(f\"   CallSid: {call_sid}\")\n    print(\"=\"*40)\n    \n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    \n    # ULTRA SIMPLE TwiML\n    twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <Response>\n        <Say voice=\"alice\" language=\"en-US\">Hello! Speak now for translation.</Say>\n        <Record \n            action=\"https://{railway_domain}/transcription-webhook\" \n            method=\"POST\"\n            transcribe=\"true\"\n            transcribeCallback=\"https://{railway_domain}/transcription-webhook\"\n            maxLength=\"8\"\n            timeout=\"3\"\n            playBeep=\"true\"\n        />\n    </Response>\"\"\"\n    \n    return Response(twiml, mimetype='text/xml')\n\n@app.route('/transcription-webhook', methods=['POST'])\ndef transcription_webhook():\n    call_sid = request.form.get('CallSid')\n    transcription_text = request.form.get('TranscriptionText', '')\n    transcription_status = request.form.get('TranscriptionStatus', '')\n    \n    print(f\"\\nüé§ TRANSCRIPTION:\")\n    print(f\"   Status: {transcription_status}\")\n    print(f\"   Text: '{transcription_text}'\")\n    print(\"=\"*40)\n    \n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    \n    if not transcription_text:\n        print(\"‚ùå No transcription - fallback response\")\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"en-US\">I didn't hear anything. Goodbye.</Say>\n        </Response>\"\"\"\n        return Response(twiml, mimetype='text/xml')\n    \n    try:\n        # Simple language detection\n        devanagari_chars = set('‡§Ö‡§Ü‡§á‡§à‡§â‡§ä‡§ã‡§è‡§ê‡§ì‡§î‡§ï‡§ñ‡§ó‡§ò‡§ô‡§ö‡§õ‡§ú‡§ù‡§û‡§ü‡§†‡§°‡§¢‡§£‡§§‡§•‡§¶‡§ß‡§®‡§™‡§´‡§¨‡§≠‡§Æ‡§Ø‡§∞‡§≤‡§µ‡§∂‡§∑‡§∏‡§π')\n        is_hindi = any(char in devanagari_chars for char in transcription_text)\n        \n        if is_hindi:\n            # Hindi to English\n            translated_text = translate_text(transcription_text, 'hi', 'en')\n            target_lang = \"en-US\"\n            print(f\"üîÑ Hindi ‚Üí English: '{translated_text}'\")\n        else:\n            # English to Hindi\n            translated_text = translate_text(transcription_text, 'en', 'hi')\n            target_lang = \"hi-IN\"\n            print(f\"üîÑ English ‚Üí Hindi: '{translated_text}'\")\n        \n        print(f\"üîä SPEAKING: You said: {transcription_text}\")\n        print(f\"üîä SPEAKING: Translation: {translated_text}\")\n        print(\"=\"*40)\n        \n        # ULTRA SIMPLE response\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"en-US\">You said: {transcription_text}</Say>\n            <Say voice=\"alice\" language=\"{target_lang}\">Translation: {translated_text}</Say>\n            <Say voice=\"alice\" language=\"en-US\">Thank you. Goodbye.</Say>\n        </Response>\"\"\"\n        \n        return Response(twiml, mimetype='text/xml')\n        \n    except Exception as e:\n        print(f\"‚ùå Error: {e}\")\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"en-US\">Error occurred. Goodbye.</Say>\n        </Response>\"\"\"\n        return Response(twiml, mimetype='text/xml')\n\ndef translate_text(text, source_lang, target_lang):\n    try:\n        if not GOOGLE_CLOUD_AVAILABLE:\n            return text\n        \n        client = translate.Client()\n        result = client.translate(text, source_language=source_lang, target_language=target_lang)\n        return result['translatedText']\n    except Exception as e:\n        print(f\"‚ùå Translation error: {e}\")\n        return text\n\nclass StandaloneApplication(gunicorn.app.base.BaseApplication):\n    def __init__(self, app, options=None):\n        self.options = options or {}\n        self.application = app\n        super().__init__()\n    \n    def load_config(self):\n        config = {key: value for key, value in self.options.items()\n                 if key in self.cfg.settings and value is not None}\n        for key, value in config.items():\n            self.cfg.set(key.lower(), value)\n    \n    def load(self):\n        return self.application\n\nif __name__ == \"__main__\":\n    port = int(os.environ.get('PORT', 3000))\n    print(f\"üöÄ ULTRA SIMPLE TRANSLATOR on port {port}\")\n    print(\"=\"*50)\n    print(\"‚úÖ Features:\")\n    print(\"   ‚úì Ultra simple responses\")\n    print(\"   ‚úì Hindi ‚Üî English translation\")\n    print(\"   ‚úì No complex features\")\n    print(\"   ‚úì Guaranteed to work\")\n    print(f\"   ‚úì Google Cloud: {GOOGLE_CLOUD_AVAILABLE}\")\n    print(f\"   ‚úì Credentials: {credentials_setup}\")\n    print(\"=\"*50)\n    \n    options = {\n        'bind': f'0.0.0.0:{port}',\n        'workers': 1,\n        'worker_class': 'sync',\n        'timeout': 30,\n    }\n    \n    StandaloneApplication(app, options).run()\n","size_bytes":6747},"single_tunnel_translator.py":{"content":"import os\nimport asyncio\nimport json\nimport base64\nimport queue\nimport threading\nimport time\nimport struct\nfrom collections import deque\nfrom flask import Flask, request, Response, jsonify\nfrom google.cloud import speech\nfrom google.cloud import texttospeech\nfrom google.cloud import translate_v2 as translate\n\n# Set Google Cloud credentials\nos.environ[\"GOOGLE_APPLICATION_CREDENTIALS\"] = \"/Users/apple/text_to_voice_translator/google-credentials.json\"\n\n# Global variables for managing call state\nactive_calls = {}\naudio_queues = {}\n\nclass SingleTunnelCallSession:\n    def __init__(self, call_sid, stream_sid):\n        self.call_sid = call_sid\n        self.stream_sid = stream_sid\n        self.last_processed_transcript = \"\"\n        self.file_counter = 0\n        self.last_translation_time = 0\n        self.is_processing = False\n        self.translation_lock = threading.Lock()\n        self.audio_queue = queue.Queue()\n        self.current_language = 'hi-IN'\n\n# Translation functions\ndef translate_hindi_to_english(hindi_text):\n    \"\"\"Translate Hindi text to English\"\"\"\n    try:\n        client = translate.Client()\n        result = client.translate(hindi_text, source_language='hi', target_language='en')\n        english_text = result['translatedText']\n        print(f\"Hindi ‚Üí English: {hindi_text} ‚Üí {english_text}\")\n        return english_text\n    except Exception as e:\n        print(f\"Hindi to English translation error: {e}\")\n        return None\n\ndef translate_english_to_hindi(english_text):\n    \"\"\"Translate English text to Hindi\"\"\"\n    try:\n        client = translate.Client()\n        result = client.translate(english_text, source_language='en', target_language='hi')\n        hindi_text = result['translatedText']\n        print(f\"English ‚Üí Hindi: {english_text} ‚Üí {hindi_text}\")\n        return hindi_text\n    except Exception as e:\n        print(f\"English to Hindi translation error: {e}\")\n        return None\n\n# Text-to-Speech functions\ndef synthesize_english_speech(english_text, file_counter):\n    \"\"\"Convert English text to speech\"\"\"\n    try:\n        client = texttospeech.TextToSpeechClient()\n        synthesis_input = texttospeech.SynthesisInput(text=english_text)\n        voice = texttospeech.VoiceSelectionParams(\n            language_code=\"en-US\", \n            name=\"en-US-Standard-A\"\n        )\n        audio_config = texttospeech.AudioConfig(\n            audio_encoding=texttospeech.AudioEncoding.MULAW, \n            sample_rate_hertz=8000\n        )\n\n        response = client.synthesize_speech(\n            input=synthesis_input, \n            voice=voice, \n            audio_config=audio_config\n        )\n        \n        return response.audio_content\n    except Exception as e:\n        print(f\"English Text-to-Speech error: {e}\")\n        return None\n\ndef synthesize_hindi_speech(hindi_text, file_counter):\n    \"\"\"Convert Hindi text to speech\"\"\"\n    try:\n        client = texttospeech.TextToSpeechClient()\n        synthesis_input = texttospeech.SynthesisInput(text=hindi_text)\n        voice = texttospeech.VoiceSelectionParams(\n            language_code=\"hi-IN\", \n            name=\"hi-IN-Standard-A\"\n        )\n        audio_config = texttospeech.AudioConfig(\n            audio_encoding=texttospeech.AudioEncoding.MULAW, \n            sample_rate_hertz=8000\n        )\n\n        response = client.synthesize_speech(\n            input=synthesis_input, \n            voice=voice, \n            audio_config=audio_config\n        )\n        \n        return response.audio_content\n    except Exception as e:\n        print(f\"Hindi Text-to-Speech error: {e}\")\n        return None\n\n# Flask app for HTTP webhooks and media streaming\napp = Flask(__name__)\n\n@app.route('/twilio-webhook', methods=['POST'])\ndef twilio_webhook():\n    \"\"\"Handle incoming Twilio calls\"\"\"\n    call_sid = request.form.get('CallSid')\n    from_number = request.form.get('From')\n    to_number = request.form.get('To')\n    \n    print(f\"Incoming call from {from_number} to {to_number} (CallSid: {call_sid})\")\n    \n    # TwiML response to start media stream\n    twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <Response>\n        <Start>\n            <Stream url=\"wss://1e6d229a057a.ngrok-free.app/websocket\" />\n        </Start>\n        <Say language=\"hi-IN\">‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§∏‡•á‡§µ‡§æ ‡§§‡•à‡§Ø‡§æ‡§∞ ‡§π‡•à‡•§</Say>\n        <Say language=\"en-US\">Hello! Translation service is ready.</Say>\n        <Pause length=\"1\"/>\n    </Response>\"\"\"\n    \n    return Response(twiml, mimetype='text/xml')\n\n@app.route('/websocket', methods=['GET', 'POST'])\ndef websocket_handler():\n    \"\"\"Handle WebSocket-like requests via HTTP\"\"\"\n    if request.method == 'GET':\n        # WebSocket upgrade request - return 404 to force Twilio to use HTTP\n        return Response(\"WebSocket not supported\", status=404)\n    \n    # Handle media stream data\n    try:\n        data = request.get_json()\n        if not data:\n            return Response(\"No data\", status=400)\n        \n        event = data.get('event')\n        stream_sid = data.get('streamSid')\n        \n        if event == 'start':\n            print(f\"Stream started: {stream_sid}\")\n            call_sid = data.get('callSid', 'unknown')\n            call_session = SingleTunnelCallSession(call_sid, stream_sid)\n            active_calls[stream_sid] = call_session\n            return Response(\"OK\", status=200)\n        \n        elif event == 'media':\n            # Process audio data\n            audio_payload = data.get('media', {}).get('payload')\n            if audio_payload and stream_sid in active_calls:\n                # Process audio in background\n                threading.Thread(\n                    target=process_audio, \n                    args=(audio_payload, stream_sid),\n                    daemon=True\n                ).start()\n            return Response(\"OK\", status=200)\n        \n        elif event == 'stop':\n            print(f\"Stream stopped: {stream_sid}\")\n            if stream_sid in active_calls:\n                del active_calls[stream_sid]\n            return Response(\"OK\", status=200)\n        \n        return Response(\"OK\", status=200)\n        \n    except Exception as e:\n        print(f\"WebSocket handler error: {e}\")\n        return Response(\"Error\", status=500)\n\ndef process_audio(audio_payload, stream_sid):\n    \"\"\"Process audio data and generate translation\"\"\"\n    try:\n        if stream_sid not in active_calls:\n            return\n        \n        call_session = active_calls[stream_sid]\n        \n        # Decode audio\n        audio_data = base64.b64decode(audio_payload)\n        \n        # Simple voice activity detection\n        if len(audio_data) < 2:\n            return\n        \n        # Calculate RMS for voice detection\n        samples = struct.unpack('<' + 'h' * (len(audio_data) // 2), audio_data)\n        rms = (sum(x * x for x in samples) / len(samples)) ** 0.5\n        \n        # Only process if there's significant audio\n        if rms < 0.01:\n            return\n        \n        # For now, we'll simulate speech recognition\n        # In a real implementation, you'd send this to Google Speech-to-Text\n        print(f\"Processing audio for stream {stream_sid}, RMS: {rms:.4f}\")\n        \n        # Simulate speech recognition result (replace with actual Google Speech-to-Text)\n        # This is a placeholder - you'd need to implement actual speech recognition\n        if rms > 0.05:  # Threshold for \"speech detected\"\n            # Simulate getting a transcript\n            if call_session.current_language == 'hi-IN':\n                # Simulate Hindi speech\n                transcript = \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á ‡§ï‡•à‡§∏‡•á ‡§π‡•à‡§Ç ‡§Ü‡§™\"\n                print(f\"Simulated Hindi transcript: {transcript}\")\n                \n                # Translate to English\n                english_text = translate_hindi_to_english(transcript)\n                if english_text:\n                    # Generate English speech\n                    audio_content = synthesize_english_speech(english_text, call_session.file_counter)\n                    if audio_content:\n                        call_session.file_counter += 1\n                        # Queue audio for playback\n                        call_session.audio_queue.put(audio_content)\n                        print(f\"Generated English translation: {english_text}\")\n                \n                # Switch to English detection\n                call_session.current_language = 'en-US'\n                \n            else:\n                # Simulate English speech\n                transcript = \"Hello how are you\"\n                print(f\"Simulated English transcript: {transcript}\")\n                \n                # Translate to Hindi\n                hindi_text = translate_english_to_hindi(transcript)\n                if hindi_text:\n                    # Generate Hindi speech\n                    audio_content = synthesize_hindi_speech(hindi_text, call_session.file_counter)\n                    if audio_content:\n                        call_session.file_counter += 1\n                        # Queue audio for playback\n                        call_session.audio_queue.put(audio_content)\n                        print(f\"Generated Hindi translation: {hindi_text}\")\n                \n                # Switch to Hindi detection\n                call_session.current_language = 'hi-IN'\n        \n    except Exception as e:\n        print(f\"Audio processing error: {e}\")\n\n@app.route('/get-audio/<stream_sid>')\ndef get_audio(stream_sid):\n    \"\"\"Get translated audio for a stream\"\"\"\n    if stream_sid not in active_calls:\n        return Response(\"Stream not found\", status=404)\n    \n    call_session = active_calls[stream_sid]\n    \n    try:\n        # Get audio from queue (non-blocking)\n        audio_content = call_session.audio_queue.get_nowait()\n        \n        # Return audio as base64\n        audio_b64 = base64.b64encode(audio_content).decode('utf-8')\n        return jsonify({\n            'audio': audio_b64,\n            'streamSid': stream_sid\n        })\n        \n    except queue.Empty:\n        return jsonify({'audio': None, 'streamSid': stream_sid})\n\n@app.route('/call-status', methods=['POST'])\ndef call_status():\n    \"\"\"Handle call status updates\"\"\"\n    call_sid = request.form.get('CallSid')\n    call_status = request.form.get('CallStatus')\n    \n    print(f\"Call {call_sid} status: {call_status}\")\n    \n    if call_status == 'completed':\n        # Clean up call session\n        for stream_sid, session in list(active_calls.items()):\n            if session.call_sid == call_sid:\n                del active_calls[stream_sid]\n                break\n    \n    return Response('OK', mimetype='text/plain')\n\nif __name__ == \"__main__\":\n    print(\"=\"*70)\n    print(\"SINGLE TUNNEL BIDIRECTIONAL VOICE TRANSLATION SYSTEM\")\n    print(\"=\"*70)\n    print(\"Features:\")\n    print(\"‚úì Real-time Hindi ‚Üî English translation\")\n    print(\"‚úì Works with free ngrok account (single tunnel)\")\n    print(\"‚úì HTTP-based media streaming\")\n    print(\"‚úì Simulated speech recognition (for demo)\")\n    print(\"\\nSetup Instructions:\")\n    print(\"1. Start ngrok: ngrok http 3000\")\n    print(\"2. Update the WebSocket URL in the TwiML response\")\n    print(\"3. Configure your Twilio phone number webhook\")\n    print(\"4. Make a call to your Twilio number\")\n    print(\"\\nNote: This version uses simulated speech recognition\")\n    print(\"For production, integrate with Google Speech-to-Text API\")\n    print(\"=\"*70)\n    \n    app.run(host='0.0.0.0', port=3000, debug=False)\n","size_bytes":11470},"RAILWAY_DEPLOYMENT.md":{"content":"# üöÄ Railway Deployment Guide - Twilio Voice Translator\n\n## üìã **Prerequisites**\n- GitHub account\n- Railway account (free at [railway.app](https://railway.app))\n- Google Cloud account with Speech, Translation, and TTS APIs enabled\n\n---\n\n## üöÄ **Step-by-Step Deployment**\n\n### **Step 1: Push to GitHub**\n\n```bash\n# Your code is already committed locally\ngit remote add origin https://github.com/YOUR_USERNAME/twilio-voice-translator.git\ngit push -u origin main\n```\n\n### **Step 2: Deploy to Railway**\n\n1. **Go to [railway.app](https://railway.app)**\n2. **Sign up/Login** with GitHub\n3. **Click \"New Project\"**\n4. **Select \"Deploy from GitHub repo\"**\n5. **Choose your repository**: `twilio-voice-translator`\n6. **Railway will automatically detect** the Python app and start building\n\n### **Step 3: Configure Environment Variables**\n\nIn Railway dashboard, go to your project ‚Üí Variables tab:\n\n#### **Required Variables:**\n```\nGOOGLE_APPLICATION_CREDENTIALS = <your-google-credentials-json>\n```\n\n#### **How to set Google credentials:**\n1. **Copy your Google credentials JSON content**\n2. **In Railway Variables**, paste the entire JSON as the value\n3. **Railway will automatically create the file** and set the environment variable\n\n#### **Optional Variables:**\n```\nPORT = 3000\nRAILWAY_PUBLIC_DOMAIN = <auto-generated-by-railway>\n```\n\n### **Step 4: Get Your Railway URL**\n\nAfter deployment, Railway will provide:\n- **HTTP URL**: `https://your-app-name.railway.app`\n- **WebSocket URL**: `wss://your-app-name.railway.app/websocket`\n\n### **Step 5: Update Twilio Configuration**\n\n1. **Go to [Twilio Console](https://console.twilio.com/)**\n2. **Navigate to**: Phone Numbers ‚Üí Manage ‚Üí Active numbers\n3. **Click on your phone number**\n4. **Set webhook URL to**: `https://your-app-name.railway.app/twilio-webhook`\n5. **Set HTTP method to**: POST\n6. **Save configuration**\n\n---\n\n## üß™ **Testing Your Deployment**\n\n### **Test Steps:**\n1. **Call your Twilio number**\n2. **Expected behavior**:\n   - ‚úÖ Call connects\n   - ‚úÖ Welcome messages play in Hindi and English\n   - ‚úÖ WebSocket connection establishes\n   - ‚úÖ Real-time translation works\n\n### **Success Indicators:**\n- ‚úÖ No connection errors in Railway logs\n- ‚úÖ WebSocket connection successful\n- ‚úÖ Translation working bidirectionally\n- ‚úÖ Audio quality good\n\n---\n\n## üìä **Railway Dashboard**\n\n### **Monitoring:**\n- **Logs**: Real-time application logs\n- **Metrics**: CPU, Memory, Network usage\n- **Deployments**: Deployment history and status\n\n### **Scaling:**\n- **Free tier**: 500 hours/month\n- **Paid plans**: Available for higher usage\n- **Auto-scaling**: Automatic based on traffic\n\n---\n\n## üîß **Troubleshooting**\n\n### **Common Issues:**\n\n#### **1. Google Credentials Error**\n```\nError: google-credentials.json not found\n```\n**Solution**: Set `GOOGLE_APPLICATION_CREDENTIALS` environment variable\n\n#### **2. WebSocket Connection Failed**\n```\nWebSocket connection error\n```\n**Solution**: Check Railway logs, ensure both HTTP and WebSocket are accessible\n\n#### **3. Translation Not Working**\n```\nTranslation error\n```\n**Solution**: Verify Google Cloud APIs are enabled and credentials are correct\n\n### **Debug Commands:**\n```bash\n# Check Railway logs\nrailway logs\n\n# Check environment variables\nrailway variables\n\n# Restart deployment\nrailway redeploy\n```\n\n---\n\n## üéØ **Expected Results**\n\nAfter successful deployment:\n\n### **‚úÖ What Works:**\n- **Real-time voice translation** Hindi ‚Üî English\n- **Automatic language detection**\n- **High-quality audio synthesis**\n- **Reliable WebSocket connections**\n- **Professional cloud hosting**\n\n### **üìû Call Flow:**\n1. **Call connects** ‚Üí Welcome messages\n2. **WebSocket establishes** ‚Üí Translation ready\n3. **You speak English** ‚Üí Other person hears Hindi\n4. **Other person speaks Hindi** ‚Üí You hear English\n5. **Seamless conversation** with real-time translation\n\n---\n\n## üéâ **Deployment Complete!**\n\nYour Twilio Voice Translator is now:\n- ‚úÖ **Deployed on Railway cloud**\n- ‚úÖ **Accessible via permanent URL**\n- ‚úÖ **Ready for production use**\n- ‚úÖ **Scalable and reliable**\n\n**Next step**: Test your deployed application by calling your Twilio number!\n\n---\n\n## üìû **Support**\n\nIf you need help:\n1. **Check Railway logs** for error messages\n2. **Verify environment variables** are set correctly\n3. **Test Google Cloud APIs** separately\n4. **Check Twilio webhook configuration**\n\n**Your professional voice translation system is ready! üéä**\n","size_bytes":4478},"working_twilio_translator.py":{"content":"import os\nimport asyncio\nimport json\nimport base64\nimport queue\nimport threading\nimport time\nimport struct\nfrom collections import deque\nfrom flask import Flask, request, Response\nimport websockets\nfrom google.cloud import speech\nfrom google.cloud import texttospeech\nfrom google.cloud import translate_v2 as translate\n\n# Set Google Cloud credentials\nos.environ[\"GOOGLE_APPLICATION_CREDENTIALS\"] = \"/Users/apple/text_to_voice_translator/google-credentials.json\"\n\n# Global variables for managing call state\nactive_calls = {}\n\nclass WorkingCallSession:\n    def __init__(self, call_sid, stream_sid):\n        self.call_sid = call_sid\n        self.stream_sid = stream_sid\n        self.last_processed_transcript = \"\"\n        self.file_counter = 0\n        self.last_translation_time = 0\n        self.is_processing = False\n        self.translation_lock = threading.Lock()\n\n# Translation functions\ndef translate_hindi_to_english(hindi_text):\n    \"\"\"Translate Hindi text to English\"\"\"\n    try:\n        client = translate.Client()\n        result = client.translate(hindi_text, source_language='hi', target_language='en')\n        english_text = result['translatedText']\n        print(f\"Hindi ‚Üí English: {hindi_text} ‚Üí {english_text}\")\n        return english_text\n    except Exception as e:\n        print(f\"Hindi to English translation error: {e}\")\n        return None\n\ndef translate_english_to_hindi(english_text):\n    \"\"\"Translate English text to Hindi\"\"\"\n    try:\n        client = translate.Client()\n        result = client.translate(english_text, source_language='en', target_language='hi')\n        hindi_text = result['translatedText']\n        print(f\"English ‚Üí Hindi: {english_text} ‚Üí {hindi_text}\")\n        return hindi_text\n    except Exception as e:\n        print(f\"English to Hindi translation error: {e}\")\n        return None\n\n# Text-to-Speech functions\ndef synthesize_english_speech(english_text, file_counter):\n    \"\"\"Convert English text to speech\"\"\"\n    try:\n        client = texttospeech.TextToSpeechClient()\n        synthesis_input = texttospeech.SynthesisInput(text=english_text)\n        voice = texttospeech.VoiceSelectionParams(\n            language_code=\"en-US\", \n            name=\"en-US-Standard-A\"\n        )\n        audio_config = texttospeech.AudioConfig(\n            audio_encoding=texttospeech.AudioEncoding.MULAW, \n            sample_rate_hertz=8000\n        )\n\n        response = client.synthesize_speech(\n            input=synthesis_input, \n            voice=voice, \n            audio_config=audio_config\n        )\n        \n        return response.audio_content\n    except Exception as e:\n        print(f\"English Text-to-Speech error: {e}\")\n        return None\n\ndef synthesize_hindi_speech(hindi_text, file_counter):\n    \"\"\"Convert Hindi text to speech\"\"\"\n    try:\n        client = texttospeech.TextToSpeechClient()\n        synthesis_input = texttospeech.SynthesisInput(text=hindi_text)\n        voice = texttospeech.VoiceSelectionParams(\n            language_code=\"hi-IN\", \n            name=\"hi-IN-Standard-A\"\n        )\n        audio_config = texttospeech.AudioConfig(\n            audio_encoding=texttospeech.AudioEncoding.MULAW, \n            sample_rate_hertz=8000\n        )\n\n        response = client.synthesize_speech(\n            input=synthesis_input, \n            voice=voice, \n            audio_config=audio_config\n        )\n        \n        return response.audio_content\n    except Exception as e:\n        print(f\"Hindi Text-to-Speech error: {e}\")\n        return None\n\n# WebSocket handler for Twilio media stream\nasync def twilio_websocket(websocket, path):\n    print(\"New WebSocket connection established\")\n    print(f\"WebSocket path: {path}\")\n    \n    # Initialize speech client\n    speech_client = speech.SpeechClient()\n    \n    # Speech recognition configurations\n    hindi_config = speech.RecognitionConfig(\n        encoding=speech.RecognitionConfig.AudioEncoding.MULAW,\n        sample_rate_hertz=8000,\n        language_code=\"hi-IN\",\n        enable_automatic_punctuation=True\n    )\n    \n    english_config = speech.RecognitionConfig(\n        encoding=speech.RecognitionConfig.AudioEncoding.MULAW,\n        sample_rate_hertz=8000,\n        language_code=\"en-US\",\n        enable_automatic_punctuation=True\n    )\n    \n    # Call session variables\n    call_session = None\n    current_language = 'hi-IN'  # Start with Hindi detection\n    last_processed_transcript = \"\"\n    file_counter = 0\n    stream_sid = None\n    min_translation_interval = 2.0\n\n    async def stream_audio_to_speech():\n        nonlocal stream_sid, call_session, current_language, last_processed_transcript\n        nonlocal file_counter\n        \n        async for message in websocket:\n            try:\n                data = json.loads(message)\n                \n                if data['event'] == 'media':\n                    stream_sid = data['streamSid']\n                    audio_payload = data['media']['payload']\n                    \n                    # Send audio for recognition\n                    audio = base64.b64decode(audio_payload)\n                    yield speech.StreamingRecognizeRequest(audio_content=audio)\n                    \n                elif data['event'] == 'start':\n                    print(f\"Stream started: {data['streamSid']}\")\n                    stream_sid = data['streamSid']\n                    call_session = WorkingCallSession(data.get('callSid', 'unknown'), stream_sid)\n                    active_calls[stream_sid] = call_session\n                    \n                elif data['event'] == 'stop':\n                    print(\"Stream stopped\")\n                    if stream_sid in active_calls:\n                        del active_calls[stream_sid]\n                    break\n                    \n            except json.JSONDecodeError as e:\n                print(f\"JSON decode error: {e}\")\n                continue\n            except Exception as e:\n                print(f\"WebSocket message error: {e}\")\n                continue\n\n    try:\n        # Start with Hindi recognition\n        streaming_config = speech.StreamingRecognitionConfig(\n            config=hindi_config, \n            interim_results=True\n        )\n        \n        responses = speech_client.streaming_recognize(streaming_config, stream_audio_to_speech())\n        \n        async for response in responses:\n            if not response.results or not response.results[0].alternatives:\n                continue\n                \n            transcript = response.results[0].alternatives[0].transcript\n            confidence = response.results[0].alternatives[0].confidence\n            \n            # Process final results with good confidence\n            if (response.results[0].is_final and \n                transcript.strip() and \n                transcript != last_processed_transcript and\n                confidence > 0.6):\n                \n                current_time = time.time()\n                \n                # Rate limiting\n                if current_time - call_session.last_translation_time < min_translation_interval:\n                    continue\n                \n                call_session.last_translation_time = current_time\n                \n                print(f\"Final transcript ({current_language}): {transcript} (confidence: {confidence:.2f})\")\n                last_processed_transcript = transcript\n                \n                # Translate and synthesize based on detected language\n                if current_language == 'hi-IN':\n                    # Hindi speaker ‚Üí translate to English ‚Üí synthesize English\n                    english_text = translate_hindi_to_english(transcript)\n                    if english_text:\n                        file_counter += 1\n                        audio_content = synthesize_english_speech(english_text, file_counter)\n                        if audio_content and stream_sid:\n                            await websocket.send(json.dumps({\n                                'event': 'media',\n                                'streamSid': stream_sid,\n                                'media': {'payload': base64.b64encode(audio_content).decode('utf-8')}\n                            }))\n                            print(f\"Sent English translation: {english_text}\")\n                            \n                elif current_language == 'en-US':\n                    # English speaker ‚Üí translate to Hindi ‚Üí synthesize Hindi\n                    hindi_text = translate_english_to_hindi(transcript)\n                    if hindi_text:\n                        file_counter += 1\n                        audio_content = synthesize_hindi_speech(hindi_text, file_counter)\n                        if audio_content and stream_sid:\n                            await websocket.send(json.dumps({\n                                'event': 'media',\n                                'streamSid': stream_sid,\n                                'media': {'payload': base64.b64encode(audio_content).decode('utf-8')}\n                            }))\n                            print(f\"Sent Hindi translation: {hindi_text}\")\n                \n                # Switch language for next detection\n                current_language = 'en-US' if current_language == 'hi-IN' else 'hi-IN'\n                \n                # Update streaming config for next language\n                if current_language == 'hi-IN':\n                    streaming_config = speech.StreamingRecognitionConfig(\n                        config=hindi_config, \n                        interim_results=True\n                    )\n                else:\n                    streaming_config = speech.StreamingRecognitionConfig(\n                        config=english_config, \n                        interim_results=True\n                    )\n                \n    except Exception as e:\n        print(f\"Streaming error: {e}\")\n    finally:\n        try:\n            await websocket.close()\n        except Exception as e:\n            print(f\"WebSocket close error: {e}\")\n\n# Flask app for HTTP webhooks\napp = Flask(__name__)\n\n@app.route('/twilio-webhook', methods=['POST'])\ndef twilio_webhook():\n    \"\"\"Handle incoming Twilio calls\"\"\"\n    call_sid = request.form.get('CallSid')\n    from_number = request.form.get('From')\n    to_number = request.form.get('To')\n    \n    print(f\"Incoming call from {from_number} to {to_number} (CallSid: {call_sid})\")\n    \n    # TwiML response to start media stream\n    twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <Response>\n        <Start>\n            <Stream url=\"wss://e5562da11db7.ngrok-free.app/websocket\" />\n        </Start>\n        <Say language=\"hi-IN\">‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§∏‡•á‡§µ‡§æ ‡§§‡•à‡§Ø‡§æ‡§∞ ‡§π‡•à‡•§</Say>\n        <Say language=\"en-US\">Hello! Translation service is ready.</Say>\n        <Pause length=\"1\"/>\n    </Response>\"\"\"\n    \n    return Response(twiml, mimetype='text/xml')\n\n@app.route('/call-status', methods=['POST'])\ndef call_status():\n    \"\"\"Handle call status updates\"\"\"\n    call_sid = request.form.get('CallSid')\n    call_status = request.form.get('CallStatus')\n    \n    print(f\"Call {call_sid} status: {call_status}\")\n    \n    if call_status == 'completed':\n        # Clean up call session\n        for stream_sid, session in list(active_calls.items()):\n            if session.call_sid == call_sid:\n                del active_calls[stream_sid]\n                break\n    \n    return Response('OK', mimetype='text/plain')\n\n# Start servers\nasync def start_servers():\n    if not os.path.exists(\"/Users/apple/text_to_voice_translator/google-credentials.json\"):\n        print(\"Error: google-credentials.json not found.\")\n        return\n\n    # Start Flask in a separate thread\n    def run_flask():\n        app.run(host='0.0.0.0', port=3000, debug=False, use_reloader=False)\n    \n    flask_thread = threading.Thread(target=run_flask, daemon=True)\n    flask_thread.start()\n    print(\"Flask server running on port 3000\")\n\n    # Start WebSocket server on port 8080\n    try:\n        start_server = websockets.serve(twilio_websocket, '0.0.0.0', 8080)\n        await start_server\n        print(\"WebSocket server running on port 8080\")\n        print(\"\\n\" + \"=\"*70)\n        print(\"WORKING BIDIRECTIONAL VOICE TRANSLATION SYSTEM READY\")\n        print(\"=\"*70)\n        print(\"Features:\")\n        print(\"‚úì Real-time Hindi ‚Üî English translation\")\n        print(\"‚úì Separate ports for HTTP and WebSocket\")\n        print(\"‚úì Optimized for free ngrok account\")\n        print(\"\\nSetup Instructions:\")\n        print(\"1. Start ngrok: ngrok http 3000\")\n        print(\"2. Start ngrok for WebSocket: ngrok tcp 8080\")\n        print(\"3. Update the WebSocket URL in the TwiML response\")\n        print(\"4. Configure your Twilio phone number webhook\")\n        print(\"5. Make a call to your Twilio number\")\n        print(\"=\"*70)\n    except Exception as e:\n        print(f\"WebSocket server error: {e}\")\n\nif __name__ == \"__main__\":\n    try:\n        asyncio.get_event_loop().run_until_complete(start_servers())\n        asyncio.get_event_loop().run_forever()\n    except KeyboardInterrupt:\n        print(\"Server stopped by user.\")\n    except Exception as e:\n        print(f\"Server startup error: {e}\")\n","size_bytes":13160},"start.sh":{"content":"#!/bin/bash\n\n# Railway startup script for Twilio Voice Translator\n\necho \"Starting Twilio Bidirectional Voice Translator on Railway...\"\n\n# Check if Google credentials are provided\nif [ -z \"$GOOGLE_APPLICATION_CREDENTIALS\" ]; then\n    echo \"Warning: GOOGLE_APPLICATION_CREDENTIALS not set\"\n    echo \"Please set your Google Cloud credentials in Railway environment variables\"\nfi\n\n# Start the application\npython3 railway_translator.py\n","size_bytes":431},"railway_simple.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nRailway Deployment - Simple Twilio Voice Translator\nOptimized for Railway cloud deployment with single port\n\"\"\"\n\nimport os\nimport json\nimport asyncio\nimport threading\nimport base64\nimport io\nimport wave\nfrom flask import Flask, request, Response\nimport websockets\nfrom google.cloud import speech\nfrom google.cloud import texttospeech\nfrom google.cloud import translate_v2 as translate\n\n# Set Google Cloud credentials from environment variable\n# Railway will provide this via GOOGLE_APPLICATION_CREDENTIALS\n\n# Global variables for managing call state\nactive_calls = {}\n\nclass RailwayCallSession:\n    def __init__(self, call_sid):\n        self.call_sid = call_sid\n        self.websocket = None\n        self.speech_client = speech.SpeechClient()\n        self.tts_client = texttospeech.TextToSpeechClient()\n        self.translate_client = translate.Client()\n        self.audio_buffer = []\n        self.is_speaking = False\n        self.last_language = \"en\"  # Track last detected language\n        \n    async def handle_audio(self, audio_data):\n        \"\"\"Process incoming audio and translate\"\"\"\n        try:\n            # Decode base64 audio\n            audio_bytes = base64.b64decode(audio_data)\n            \n            # Add to buffer\n            self.audio_buffer.append(audio_bytes)\n            \n            # Process when we have enough audio (simplified)\n            if len(self.audio_buffer) >= 3:  # Process every 3 chunks\n                await self.process_audio()\n                self.audio_buffer = []\n                \n        except Exception as e:\n            print(f\"Audio handling error: {e}\")\n    \n    async def process_audio(self):\n        \"\"\"Process buffered audio for speech recognition\"\"\"\n        try:\n            # Combine audio chunks\n            combined_audio = b''.join(self.audio_buffer)\n            \n            # Convert to WAV format (simplified)\n            audio_content = self.convert_to_wav(combined_audio)\n            \n            # Configure speech recognition\n            config = speech.RecognitionConfig(\n                encoding=speech.RecognitionConfig.AudioEncoding.LINEAR16,\n                sample_rate_hertz=8000,\n                language_code=\"hi-IN\",  # Start with Hindi\n                alternative_language_codes=[\"en-US\"],\n                enable_automatic_punctuation=True,\n                model=\"latest_long\"\n            )\n            \n            audio = speech.RecognitionAudio(content=audio_content)\n            \n            # Perform speech recognition\n            response = self.speech_client.recognize(config=config, audio=audio)\n            \n            if response.results:\n                result = response.results[0]\n                if result.is_final:\n                    transcript = result.alternatives[0].transcript\n                    confidence = result.alternatives[0].confidence\n                    \n                    if confidence > 0.7:  # Only process high-confidence results\n                        await self.translate_and_speak(transcript)\n                        \n        except Exception as e:\n            print(f\"Speech recognition error: {e}\")\n    \n    def convert_to_wav(self, audio_data):\n        \"\"\"Convert raw audio to WAV format\"\"\"\n        try:\n            # Create a simple WAV header for 8kHz, 16-bit, mono\n            sample_rate = 8000\n            channels = 1\n            bits_per_sample = 16\n            \n            # Calculate WAV file size\n            data_size = len(audio_data)\n            file_size = 36 + data_size\n            \n            # WAV header\n            wav_header = bytearray()\n            wav_header.extend(b'RIFF')\n            wav_header.extend(file_size.to_bytes(4, 'little'))\n            wav_header.extend(b'WAVE')\n            wav_header.extend(b'fmt ')\n            wav_header.extend((16).to_bytes(4, 'little'))  # fmt chunk size\n            wav_header.extend((1).to_bytes(2, 'little'))   # audio format (PCM)\n            wav_header.extend(channels.to_bytes(2, 'little'))\n            wav_header.extend(sample_rate.to_bytes(4, 'little'))\n            wav_header.extend((sample_rate * channels * bits_per_sample // 8).to_bytes(4, 'little'))\n            wav_header.extend((channels * bits_per_sample // 8).to_bytes(2, 'little'))\n            wav_header.extend(bits_per_sample.to_bytes(2, 'little'))\n            wav_header.extend(b'data')\n            wav_header.extend(data_size.to_bytes(4, 'little'))\n            \n            return bytes(wav_header) + audio_data\n            \n        except Exception as e:\n            print(f\"WAV conversion error: {e}\")\n            return audio_data\n    \n    async def translate_and_speak(self, text):\n        \"\"\"Translate text and synthesize speech\"\"\"\n        try:\n            # Detect language\n            detected_language = self.detect_language(text)\n            \n            # Translate based on detected language\n            if detected_language == \"hi\":\n                # Hindi to English\n                translated_text = self.translate_client.translate(text, target_language='en')['translatedText']\n                target_language = \"en-US\"\n                print(f\"Hindi: {text} ‚Üí English: {translated_text}\")\n            else:\n                # English to Hindi\n                translated_text = self.translate_client.translate(text, target_language='hi')['translatedText']\n                target_language = \"hi-IN\"\n                print(f\"English: {text} ‚Üí Hindi: {translated_text}\")\n            \n            # Synthesize speech\n            synthesis_input = texttospeech.SynthesisInput(text=translated_text)\n            voice = texttospeech.VoiceSelectionParams(\n                language_code=target_language,\n                ssml_gender=texttospeech.SsmlVoiceGender.FEMALE\n            )\n            audio_config = texttospeech.AudioConfig(\n                audio_encoding=texttospeech.AudioEncoding.MULAW,\n                sample_rate_hertz=8000\n            )\n            \n            response = self.tts_client.synthesize_speech(\n                input=synthesis_input,\n                voice=voice,\n                audio_config=audio_config\n            )\n            \n            # Send audio back to Twilio\n            if self.websocket:\n                audio_b64 = base64.b64encode(response.audio_content).decode('utf-8')\n                await self.websocket.send(json.dumps({\n                    \"event\": \"media\",\n                    \"streamSid\": \"your-stream-sid\",\n                    \"media\": {\n                        \"payload\": audio_b64\n                    }\n                }))\n                \n        except Exception as e:\n            print(f\"Translation/synthesis error: {e}\")\n    \n    def detect_language(self, text):\n        \"\"\"Simple language detection\"\"\"\n        # Simple heuristic: if text contains Devanagari characters, it's Hindi\n        devanagari_chars = set('‡§Ö‡§Ü‡§á‡§à‡§â‡§ä‡§ã‡§è‡§ê‡§ì‡§î‡§ï‡§ñ‡§ó‡§ò‡§ô‡§ö‡§õ‡§ú‡§ù‡§û‡§ü‡§†‡§°‡§¢‡§£‡§§‡§•‡§¶‡§ß‡§®‡§™‡§´‡§¨‡§≠‡§Æ‡§Ø‡§∞‡§≤‡§µ‡§∂‡§∑‡§∏‡§π')\n        if any(char in devanagari_chars for char in text):\n            return \"hi\"\n        return \"en\"\n\nasync def twilio_websocket(websocket, path):\n    \"\"\"Handle Twilio WebSocket connections\"\"\"\n    try:\n        print(f\"WebSocket connection established: {websocket.remote_address}\")\n        \n        # Get call SID from query parameters\n        call_sid = None\n        if '?' in path:\n            params = path.split('?')[1]\n            for param in params.split('&'):\n                if param.startswith('CallSid='):\n                    call_sid = param.split('=')[1]\n                    break\n        \n        if not call_sid:\n            print(\"No CallSid provided\")\n            await websocket.close()\n            return\n        \n        # Create or get call session\n        if call_sid not in active_calls:\n            active_calls[call_sid] = RailwayCallSession(call_sid)\n        \n        session = active_calls[call_sid]\n        session.websocket = websocket\n        \n        # Send start message\n        await websocket.send(json.dumps({\n            \"event\": \"start\",\n            \"sequenceNumber\": \"1\",\n            \"start\": {\n                \"accountSid\": \"your-account-sid\",\n                \"callSid\": call_sid,\n                \"tracks\": [\"inbound\", \"outbound\"],\n                \"mediaFormat\": {\n                    \"encoding\": \"audio/x-mulaw\",\n                    \"sampleRate\": 8000,\n                    \"channels\": 1\n                },\n                \"streamSid\": \"your-stream-sid\"\n            }\n        }))\n        \n        # Handle incoming messages\n        async for message in websocket:\n            try:\n                data = json.loads(message)\n                \n                if data.get(\"event\") == \"media\":\n                    media_data = data.get(\"media\", {}).get(\"payload\", \"\")\n                    if media_data:\n                        await session.handle_audio(media_data)\n                        \n            except json.JSONDecodeError:\n                print(\"Invalid JSON received\")\n            except Exception as e:\n                print(f\"Message handling error: {e}\")\n                \n    except websockets.exceptions.ConnectionClosed:\n        print(\"WebSocket connection closed\")\n    except Exception as e:\n        print(f\"WebSocket error: {e}\")\n    finally:\n        # Clean up\n        if call_sid and call_sid in active_calls:\n            del active_calls[call_sid]\n\n# Flask app for HTTP webhooks\napp = Flask(__name__)\n\n@app.route('/health')\ndef health_check():\n    \"\"\"Health check endpoint for Railway\"\"\"\n    return {\"status\": \"healthy\", \"service\": \"twilio-voice-translator\"}, 200\n\n@app.route('/twilio-webhook', methods=['POST'])\ndef twilio_webhook():\n    \"\"\"Handle incoming Twilio calls\"\"\"\n    call_sid = request.form.get('CallSid')\n    from_number = request.form.get('From')\n    to_number = request.form.get('To')\n    \n    print(f\"Incoming call from {from_number} to {to_number} (CallSid: {call_sid})\")\n    \n    # Get the Railway domain from environment variable\n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'your-railway-app.railway.app')\n    if railway_domain == 'your-railway-app.railway.app':\n        # Fallback to Railway's default domain format\n        railway_domain = os.environ.get('RAILWAY_STATIC_URL', 'your-railway-app.railway.app')\n    \n    # TwiML response to start media stream\n    twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <Response>\n        <Start>\n            <Stream url=\"wss://{railway_domain}/websocket?CallSid={call_sid}\">\n                <Parameter name=\"CallSid\" value=\"{call_sid}\"/>\n            </Stream>\n        </Start>\n        <Say language=\"hi-IN\">‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡•Ä ‡§Ü‡§µ‡§æ‡§ú‡§º ‡§ï‡§æ ‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§ï‡§∞‡•Ç‡§Ç‡§ó‡§æ‡•§</Say>\n        <Say language=\"en-US\">Hello! I will translate your voice.</Say>\n        <Say language=\"hi-IN\">‡§Ö‡§¨ ‡§Ü‡§™ ‡§¨‡•ã‡§≤ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç‡•§</Say>\n        <Say language=\"en-US\">You can start speaking now.</Say>\n    </Response>\"\"\"\n    \n    return Response(twiml, mimetype='text/xml')\n\ndef run_flask_server(port):\n    \"\"\"Run Flask server\"\"\"\n    app.run(host='0.0.0.0', port=port, debug=False, use_reloader=False)\n\nasync def start_servers():\n    \"\"\"Start both Flask and WebSocket servers\"\"\"\n    # Get port from Railway environment variable\n    port = int(os.environ.get('PORT', 3000))\n    \n    # Start Flask server in a separate thread\n    flask_thread = threading.Thread(target=run_flask_server, args=(port,), daemon=True)\n    flask_thread.start()\n    print(f\"Flask server running on port {port}\")\n    \n    # Start WebSocket server on the same port (Railway handles routing)\n    print(f\"WebSocket server running on port {port}\")\n    await websockets.serve(twilio_websocket, \"0.0.0.0\", port)\n\nif __name__ == \"__main__\":\n    try:\n        # Get port from Railway environment variable\n        port = int(os.environ.get('PORT', 3000))\n        print(f\"Starting Railway deployment on port {port}\")\n        print(\"=\"*70)\n        print(\"RAILWAY TWILIO VOICE TRANSLATOR\")\n        print(\"=\"*70)\n        print(\"Features:\")\n        print(\"‚úì Real-time Hindi ‚Üî English translation\")\n        print(\"‚úì Railway cloud deployment\")\n        print(\"‚úì Single port configuration\")\n        print(\"‚úì Health check endpoint\")\n        print(\"=\"*70)\n        \n        asyncio.get_event_loop().run_until_complete(start_servers())\n        asyncio.get_event_loop().run_forever()\n    except KeyboardInterrupt:\n        print(\"Server stopped by user.\")\n    except Exception as e:\n        print(f\"Server startup error: {e}\")\n","size_bytes":12566},"fixed_twilio_translator.py":{"content":"import os\nimport asyncio\nimport json\nimport base64\nimport queue\nimport threading\nimport time\nimport struct\nfrom collections import deque\nfrom flask import Flask, request, Response\nimport websockets\nfrom google.cloud import speech\nfrom google.cloud import texttospeech\nfrom google.cloud import translate_v2 as translate\n\n# Set Google Cloud credentials\nos.environ[\"GOOGLE_APPLICATION_CREDENTIALS\"] = \"/Users/apple/text_to_voice_translator/google-credentials.json\"\n\n# Global variables for managing call state\nactive_calls = {}\n\nclass FixedCallSession:\n    def __init__(self, call_sid, stream_sid):\n        self.call_sid = call_sid\n        self.stream_sid = stream_sid\n        self.last_processed_transcript = \"\"\n        self.file_counter = 0\n        self.last_translation_time = 0\n        self.is_processing = False\n        self.translation_lock = threading.Lock()\n\n# Translation functions\ndef translate_hindi_to_english(hindi_text):\n    \"\"\"Translate Hindi text to English\"\"\"\n    try:\n        client = translate.Client()\n        result = client.translate(hindi_text, source_language='hi', target_language='en')\n        english_text = result['translatedText']\n        print(f\"Hindi ‚Üí English: {hindi_text} ‚Üí {english_text}\")\n        return english_text\n    except Exception as e:\n        print(f\"Hindi to English translation error: {e}\")\n        return None\n\ndef translate_english_to_hindi(english_text):\n    \"\"\"Translate English text to Hindi\"\"\"\n    try:\n        client = translate.Client()\n        result = client.translate(english_text, source_language='en', target_language='hi')\n        hindi_text = result['translatedText']\n        print(f\"English ‚Üí Hindi: {english_text} ‚Üí {hindi_text}\")\n        return hindi_text\n    except Exception as e:\n        print(f\"English to Hindi translation error: {e}\")\n        return None\n\n# Text-to-Speech functions\ndef synthesize_english_speech(english_text, file_counter):\n    \"\"\"Convert English text to speech\"\"\"\n    try:\n        client = texttospeech.TextToSpeechClient()\n        synthesis_input = texttospeech.SynthesisInput(text=english_text)\n        voice = texttospeech.VoiceSelectionParams(\n            language_code=\"en-US\", \n            name=\"en-US-Standard-A\"\n        )\n        audio_config = texttospeech.AudioConfig(\n            audio_encoding=texttospeech.AudioEncoding.MULAW, \n            sample_rate_hertz=8000\n        )\n\n        response = client.synthesize_speech(\n            input=synthesis_input, \n            voice=voice, \n            audio_config=audio_config\n        )\n        \n        return response.audio_content\n    except Exception as e:\n        print(f\"English Text-to-Speech error: {e}\")\n        return None\n\ndef synthesize_hindi_speech(hindi_text, file_counter):\n    \"\"\"Convert Hindi text to speech\"\"\"\n    try:\n        client = texttospeech.TextToSpeechClient()\n        synthesis_input = texttospeech.SynthesisInput(text=hindi_text)\n        voice = texttospeech.VoiceSelectionParams(\n            language_code=\"hi-IN\", \n            name=\"hi-IN-Standard-A\"\n        )\n        audio_config = texttospeech.AudioConfig(\n            audio_encoding=texttospeech.AudioEncoding.MULAW, \n            sample_rate_hertz=8000\n        )\n\n        response = client.synthesize_speech(\n            input=synthesis_input, \n            voice=voice, \n            audio_config=audio_config\n        )\n        \n        return response.audio_content\n    except Exception as e:\n        print(f\"Hindi Text-to-Speech error: {e}\")\n        return None\n\n# WebSocket handler for Twilio media stream\nasync def twilio_websocket(websocket, path):\n    print(\"New WebSocket connection established\")\n    print(f\"WebSocket path: {path}\")\n    \n    # Initialize speech client\n    speech_client = speech.SpeechClient()\n    \n    # Speech recognition configurations\n    hindi_config = speech.RecognitionConfig(\n        encoding=speech.RecognitionConfig.AudioEncoding.MULAW,\n        sample_rate_hertz=8000,\n        language_code=\"hi-IN\",\n        enable_automatic_punctuation=True\n    )\n    \n    english_config = speech.RecognitionConfig(\n        encoding=speech.RecognitionConfig.AudioEncoding.MULAW,\n        sample_rate_hertz=8000,\n        language_code=\"en-US\",\n        enable_automatic_punctuation=True\n    )\n    \n    # Call session variables\n    call_session = None\n    current_language = 'hi-IN'  # Start with Hindi detection\n    last_processed_transcript = \"\"\n    file_counter = 0\n    stream_sid = None\n    min_translation_interval = 2.0\n\n    async def stream_audio_to_speech():\n        nonlocal stream_sid, call_session, current_language, last_processed_transcript\n        nonlocal file_counter\n        \n        async for message in websocket:\n            try:\n                data = json.loads(message)\n                \n                if data['event'] == 'media':\n                    stream_sid = data['streamSid']\n                    audio_payload = data['media']['payload']\n                    \n                    # Send audio for recognition\n                    audio = base64.b64decode(audio_payload)\n                    yield speech.StreamingRecognizeRequest(audio_content=audio)\n                    \n                elif data['event'] == 'start':\n                    print(f\"Stream started: {data['streamSid']}\")\n                    stream_sid = data['streamSid']\n                    call_session = FixedCallSession(data.get('callSid', 'unknown'), stream_sid)\n                    active_calls[stream_sid] = call_session\n                    \n                elif data['event'] == 'stop':\n                    print(\"Stream stopped\")\n                    if stream_sid in active_calls:\n                        del active_calls[stream_sid]\n                    break\n                    \n            except json.JSONDecodeError as e:\n                print(f\"JSON decode error: {e}\")\n                continue\n            except Exception as e:\n                print(f\"WebSocket message error: {e}\")\n                continue\n\n    try:\n        # Start with Hindi recognition\n        streaming_config = speech.StreamingRecognitionConfig(\n            config=hindi_config, \n            interim_results=True\n        )\n        \n        responses = speech_client.streaming_recognize(streaming_config, stream_audio_to_speech())\n        \n        async for response in responses:\n            if not response.results or not response.results[0].alternatives:\n                continue\n                \n            transcript = response.results[0].alternatives[0].transcript\n            confidence = response.results[0].alternatives[0].confidence\n            \n            # Process final results with good confidence\n            if (response.results[0].is_final and \n                transcript.strip() and \n                transcript != last_processed_transcript and\n                confidence > 0.6):\n                \n                current_time = time.time()\n                \n                # Rate limiting\n                if current_time - call_session.last_translation_time < min_translation_interval:\n                    continue\n                \n                call_session.last_translation_time = current_time\n                \n                print(f\"Final transcript ({current_language}): {transcript} (confidence: {confidence:.2f})\")\n                last_processed_transcript = transcript\n                \n                # Translate and synthesize based on detected language\n                if current_language == 'hi-IN':\n                    # Hindi speaker ‚Üí translate to English ‚Üí synthesize English\n                    english_text = translate_hindi_to_english(transcript)\n                    if english_text:\n                        file_counter += 1\n                        audio_content = synthesize_english_speech(english_text, file_counter)\n                        if audio_content and stream_sid:\n                            await websocket.send(json.dumps({\n                                'event': 'media',\n                                'streamSid': stream_sid,\n                                'media': {'payload': base64.b64encode(audio_content).decode('utf-8')}\n                            }))\n                            print(f\"Sent English translation: {english_text}\")\n                            \n                elif current_language == 'en-US':\n                    # English speaker ‚Üí translate to Hindi ‚Üí synthesize Hindi\n                    hindi_text = translate_english_to_hindi(transcript)\n                    if hindi_text:\n                        file_counter += 1\n                        audio_content = synthesize_hindi_speech(hindi_text, file_counter)\n                        if audio_content and stream_sid:\n                            await websocket.send(json.dumps({\n                                'event': 'media',\n                                'streamSid': stream_sid,\n                                'media': {'payload': base64.b64encode(audio_content).decode('utf-8')}\n                            }))\n                            print(f\"Sent Hindi translation: {hindi_text}\")\n                \n                # Switch language for next detection\n                current_language = 'en-US' if current_language == 'hi-IN' else 'hi-IN'\n                \n                # Update streaming config for next language\n                if current_language == 'hi-IN':\n                    streaming_config = speech.StreamingRecognitionConfig(\n                        config=hindi_config, \n                        interim_results=True\n                    )\n                else:\n                    streaming_config = speech.StreamingRecognitionConfig(\n                        config=english_config, \n                        interim_results=True\n                    )\n                \n    except Exception as e:\n        print(f\"Streaming error: {e}\")\n    finally:\n        try:\n            await websocket.close()\n        except Exception as e:\n            print(f\"WebSocket close error: {e}\")\n\n# Flask app for HTTP webhooks\napp = Flask(__name__)\n\n@app.route('/twilio-webhook', methods=['POST'])\ndef twilio_webhook():\n    \"\"\"Handle incoming Twilio calls\"\"\"\n    call_sid = request.form.get('CallSid')\n    from_number = request.form.get('From')\n    to_number = request.form.get('To')\n    \n    print(f\"Incoming call from {from_number} to {to_number} (CallSid: {call_sid})\")\n    \n    # TwiML response to start media stream\n    twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <Response>\n        <Start>\n            <Stream url=\"wss://e5562da11db7.ngrok-free.app/websocket\" />\n        </Start>\n        <Say language=\"hi-IN\">‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§∏‡•á‡§µ‡§æ ‡§§‡•à‡§Ø‡§æ‡§∞ ‡§π‡•à‡•§</Say>\n        <Say language=\"en-US\">Hello! Translation service is ready.</Say>\n        <Pause length=\"1\"/>\n    </Response>\"\"\"\n    \n    return Response(twiml, mimetype='text/xml')\n\n@app.route('/call-status', methods=['POST'])\ndef call_status():\n    \"\"\"Handle call status updates\"\"\"\n    call_sid = request.form.get('CallSid')\n    call_status = request.form.get('CallStatus')\n    \n    print(f\"Call {call_sid} status: {call_status}\")\n    \n    if call_status == 'completed':\n        # Clean up call session\n        for stream_sid, session in list(active_calls.items()):\n            if session.call_sid == call_sid:\n                del active_calls[stream_sid]\n                break\n    \n    return Response('OK', mimetype='text/plain')\n\n# Start servers\nasync def start_servers():\n    if not os.path.exists(\"/Users/apple/text_to_voice_translator/google-credentials.json\"):\n        print(\"Error: google-credentials.json not found.\")\n        return\n\n    # Start Flask in a separate thread\n    def run_flask():\n        app.run(host='0.0.0.0', port=3000, debug=False, use_reloader=False)\n    \n    flask_thread = threading.Thread(target=run_flask, daemon=True)\n    flask_thread.start()\n    print(\"Flask server running on port 3000\")\n\n    # Start WebSocket server on port 3000 (same as Flask)\n    try:\n        start_server = websockets.serve(twilio_websocket, '0.0.0.0', 3000)\n        await start_server\n        print(\"WebSocket server running on port 3000\")\n        print(\"\\n\" + \"=\"*70)\n        print(\"FIXED BIDIRECTIONAL VOICE TRANSLATION SYSTEM READY\")\n        print(\"=\"*70)\n        print(\"Features:\")\n        print(\"‚úì Real-time Hindi ‚Üî English translation\")\n        print(\"‚úì Single port solution (HTTP + WebSocket)\")\n        print(\"‚úì Works with free ngrok account\")\n        print(\"\\nSetup Instructions:\")\n        print(\"1. Start ngrok: ngrok http 3000\")\n        print(\"2. Update the WebSocket URL in the TwiML response\")\n        print(\"3. Configure your Twilio phone number webhook\")\n        print(\"4. Make a call to your Twilio number\")\n        print(\"=\"*70)\n    except Exception as e:\n        print(f\"WebSocket server error: {e}\")\n\nif __name__ == \"__main__\":\n    try:\n        asyncio.get_event_loop().run_until_complete(start_servers())\n        asyncio.get_event_loop().run_forever()\n    except KeyboardInterrupt:\n        print(\"Server stopped by user.\")\n    except Exception as e:\n        print(f\"Server startup error: {e}\")\n","size_bytes":13107},"conference_call_forwarder.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nConference Call Forwarder - FAST SOLUTION\nCaller + You = Conference call\n\"\"\"\n\nimport os\nfrom flask import Flask, request, Response\n\napp = Flask(__name__)\n\nYOUR_NUMBER = \"+916358762776\"\n\n@app.route('/')\ndef home():\n    return {\"status\": \"Conference Call Forwarder Ready\"}, 200\n\n@app.route('/twilio-webhook', methods=['POST'])\ndef twilio_webhook():\n    \"\"\"Create conference call between caller and you\"\"\"\n    try:\n        call_sid = request.form.get('CallSid')\n        from_number = request.form.get('From')\n        \n        print(f\"üìû Conference call from: {from_number}\")\n        \n        # Simple 3-way call - Direct dial to your number\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Response>\n    <Say voice=\"alice\" language=\"en-US\">Connecting you now.</Say>\n    <Dial>\n        <Number>{YOUR_NUMBER}</Number>\n    </Dial>\n    <Say voice=\"alice\" language=\"en-US\">Call ended.</Say>\n</Response>\"\"\"\n        \n        return Response(twiml, mimetype='text/xml')\n        \n    except Exception as e:\n        print(f\"Error: {e}\")\n        return Response(\"<?xml version='1.0' encoding='UTF-8'?><Response><Say>Error</Say></Response>\", mimetype='text/xml')\n\n\nif __name__ == \"__main__\":\n    port = int(os.environ.get('PORT', 3000))\n    print(f\"üöÄ CONFERENCE CALL FORWARDER on port {port}\")\n    app.run(host='0.0.0.0', port=port, debug=False)\n","size_bytes":1374},"hindi_to_english_script.py":{"content":"import os\nimport pyaudio\nimport wave\nfrom google.cloud import speech\nfrom google.cloud import texttospeech\nfrom google.cloud import translate_v2 as translate\n\n# Set Google Cloud credentials\nos.environ[\"GOOGLE_APPLICATION_CREDENTIALS\"] = \"google-credentials.json\"\n\n# Step 1: Speech-to-Text (Hindi)\ndef transcribe_speech():\n    try:\n        client = speech.SpeechClient()\n        \n        # Record audio for 5 seconds (adjustable)\n        FORMAT = pyaudio.paInt16\n        CHANNELS = 1\n        RATE = 16000\n        CHUNK = 1024\n        RECORD_SECONDS = 5\n        WAVE_OUTPUT_FILENAME = \"input.wav\"\n\n        audio = pyaudio.PyAudio()\n        stream = audio.open(format=FORMAT, channels=CHANNELS, rate=RATE, input=True, frames_per_buffer=CHUNK)\n        print(f\"Recording Hindi speech for {RECORD_SECONDS} seconds...\")\n        frames = []\n        \n        for _ in range(0, int(RATE / CHUNK * RECORD_SECONDS)):\n            data = stream.read(CHUNK, exception_on_overflow=False)\n            frames.append(data)\n        \n        print(\"Recording complete.\")\n        stream.stop_stream()\n        stream.close()\n        audio.terminate()\n\n        # Save audio to temporary WAV file\n        wf = wave.open(WAVE_OUTPUT_FILENAME, 'wb')\n        wf.setnchannels(CHANNELS)\n        wf.setsampwidth(audio.get_sample_size(FORMAT))\n        wf.setframerate(RATE)\n        wf.writeframes(b''.join(frames))\n        wf.close()\n\n        # Transcribe audio\n        with open(WAVE_OUTPUT_FILENAME, 'rb') as audio_file:\n            content = audio_file.read()\n\n        audio = speech.RecognitionAudio(content=content)\n        config = speech.RecognitionConfig(\n            encoding=speech.RecognitionConfig.AudioEncoding.LINEAR16,\n            sample_rate_hertz=RATE,\n            language_code=\"hi-IN\"  # Changed to Hindi\n        )\n\n        response = client.recognize(config=config, audio=audio)\n        hindi_text = \"\"\n        for result in response.results:\n            hindi_text += result.alternatives[0].transcript\n        if not hindi_text:\n            print(\"No speech detected.\")\n            return None\n        print(\"Hindi Text:\", hindi_text)\n        \n        # Clean up temporary WAV file\n        os.remove(WAVE_OUTPUT_FILENAME)\n        return hindi_text\n    except Exception as e:\n        print(f\"Speech-to-Text error: {e}\")\n        return None\n\n# Step 2: Translate Hindi to English\ndef translate_text(hindi_text):\n    try:\n        client = translate.Client()\n        result = client.translate(hindi_text, source_language='hi', target_language='en')  # Reversed languages\n        english_text = result['translatedText']\n        print(\"English Text:\", english_text)\n        return english_text\n    except Exception as e:\n        print(f\"Translation error: {e}\")\n        return None\n\n# Step 3: Text-to-Speech (English) - Play directly without saving\ndef synthesize_speech(english_text):\n    try:\n        client = texttospeech.TextToSpeechClient()\n        \n        synthesis_input = texttospeech.SynthesisInput(text=english_text)\n        voice = texttospeech.VoiceSelectionParams(\n            language_code=\"en-US\",  # Changed to English\n            name=\"en-US-Standard-C\"  # English female voice\n        )\n        audio_config = texttospeech.AudioConfig(\n            audio_encoding=texttospeech.AudioEncoding.LINEAR16,  # Raw PCM for direct playback\n            sample_rate_hertz=16000\n        )\n\n        response = client.synthesize_speech(\n            input=synthesis_input, voice=voice, audio_config=audio_config\n        )\n\n        # Play audio directly using PyAudio\n        p = pyaudio.PyAudio()\n        stream = p.open(format=pyaudio.paInt16,\n                        channels=1,\n                        rate=16000,\n                        output=True)\n        print(\"Playing English speech...\")\n        stream.write(response.audio_content)\n        stream.stop_stream()\n        stream.close()\n        p.terminate()\n        print(\"English speech played.\")\n    except Exception as e:\n        print(f\"Text-to-Speech error: {e}\")\n\n# Main function\ndef main():\n    try:\n        # Verify credentials file\n        if not os.path.exists(\"google-credentials.json\"):\n            print(\"Error: google-credentials.json not found in the current directory.\")\n            return False\n\n        # Step 1: Convert speech to text\n        hindi_text = transcribe_speech()\n        if not hindi_text:\n            return True  # Continue loop even if no speech detected\n\n        # Step 2: Translate to English\n        english_text = translate_text(hindi_text)\n        if not english_text:\n            return True  # Continue loop on translation error\n\n        # Step 3: Convert English text to speech and play directly\n        synthesize_speech(english_text)\n        return True\n\n    except Exception as e:\n        print(f\"Main error: {e}\")\n        return True  # Continue loop on general error\n\n# Run continuously until aborted\nif __name__ == \"__main__\":\n    print(\"Starting program. Press Ctrl+C to abort.\")\n    try:\n        while True:\n            if not main():\n                break  # Exit if credentials file is missing\n            print(\"\\nReady for next recording. Press Ctrl+C to stop.\")\n    except KeyboardInterrupt:\n        print(\"\\nProgram aborted by user.\")\n    except Exception as e:\n        print(f\"Unexpected error: {e}\")","size_bytes":5302},"railway_env_setup.sh":{"content":"#!/bin/bash\n# Railway Environment Variables Setup\n# Run this script to set up your Railway environment variables\n\necho \"üöÄ Setting up Railway Environment Variables for Call Forwarding\"\necho \"==============================================================\"\n\n# Set Twilio credentials\necho \"Setting TWILIO_ACCOUNT_SID...\"\nrailway variables set TWILIO_ACCOUNT_SID=\"YOUR_ACCOUNT_SID_HERE\"\n\necho \"Setting TWILIO_AUTH_TOKEN...\"\nrailway variables set TWILIO_AUTH_TOKEN=\"YOUR_AUTH_TOKEN_HERE\"\n\necho \"Setting TWILIO_PHONE_NUMBER...\"\nrailway variables set TWILIO_PHONE_NUMBER=\"+13254250468\"\n\necho \"Setting PORT...\"\nrailway variables set PORT=\"3000\"\n\necho \"\"\necho \"‚úÖ Environment variables set successfully!\"\necho \"\"\necho \"üìû Next Steps:\"\necho \"1. Deploy your app: git push origin main\"\necho \"2. Get your Railway URL from Railway dashboard\"\necho \"3. Update Twilio webhook URL:\"\necho \"   https://your-app.railway.app/twilio-webhook\"\necho \"4. Test by calling +13254250468\"\necho \"\"\necho \"üéØ Your call forwarding will work now!\"\n","size_bytes":1019},"railway_final.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nRailway Deployment - Final Twilio Voice Translator\nOptimized for Railway with proper port handling\n\"\"\"\n\nimport os\nimport json\nimport asyncio\nimport threading\nimport base64\nimport io\nimport wave\nfrom flask import Flask, request, Response\n\n# Try to import Google Cloud libraries with error handling\ntry:\n    import websockets\n    from google.cloud import speech\n    from google.cloud import texttospeech\n    from google.cloud import translate_v2 as translate\n    GOOGLE_CLOUD_AVAILABLE = True\nexcept ImportError as e:\n    print(f\"Google Cloud libraries not available: {e}\")\n    GOOGLE_CLOUD_AVAILABLE = False\n\n# Global variables for managing call state\nactive_calls = {}\n\nclass RailwayCallSession:\n    def __init__(self, call_sid):\n        self.call_sid = call_sid\n        self.websocket = None\n        self.audio_buffer = []\n        self.is_speaking = False\n        self.last_language = \"en\"\n        \n        if GOOGLE_CLOUD_AVAILABLE:\n            try:\n                self.speech_client = speech.SpeechClient()\n                self.tts_client = texttospeech.TextToSpeechClient()\n                self.translate_client = translate.Client()\n                self.google_cloud_ready = True\n            except Exception as e:\n                print(f\"Google Cloud initialization error: {e}\")\n                self.google_cloud_ready = False\n        else:\n            self.google_cloud_ready = False\n        \n    async def handle_audio(self, audio_data):\n        \"\"\"Process incoming audio and translate\"\"\"\n        if not self.google_cloud_ready:\n            print(\"Google Cloud not ready, skipping audio processing\")\n            return\n            \n        try:\n            # Decode base64 audio\n            audio_bytes = base64.b64decode(audio_data)\n            \n            # Add to buffer\n            self.audio_buffer.append(audio_bytes)\n            \n            # Process when we have enough audio (simplified)\n            if len(self.audio_buffer) >= 3:  # Process every 3 chunks\n                await self.process_audio()\n                self.audio_buffer = []\n                \n        except Exception as e:\n            print(f\"Audio handling error: {e}\")\n    \n    async def process_audio(self):\n        \"\"\"Process buffered audio for speech recognition\"\"\"\n        if not self.google_cloud_ready:\n            return\n            \n        try:\n            # Combine audio chunks\n            combined_audio = b''.join(self.audio_buffer)\n            \n            # Convert to WAV format (simplified)\n            audio_content = self.convert_to_wav(combined_audio)\n            \n            # Configure speech recognition\n            config = speech.RecognitionConfig(\n                encoding=speech.RecognitionConfig.AudioEncoding.LINEAR16,\n                sample_rate_hertz=8000,\n                language_code=\"hi-IN\",  # Start with Hindi\n                alternative_language_codes=[\"en-US\"],\n                enable_automatic_punctuation=True,\n                model=\"latest_long\"\n            )\n            \n            audio = speech.RecognitionAudio(content=audio_content)\n            \n            # Perform speech recognition\n            response = self.speech_client.recognize(config=config, audio=audio)\n            \n            if response.results:\n                result = response.results[0]\n                if result.is_final:\n                    transcript = result.alternatives[0].transcript\n                    confidence = result.alternatives[0].confidence\n                    \n                    if confidence > 0.7:  # Only process high-confidence results\n                        await self.translate_and_speak(transcript)\n                        \n        except Exception as e:\n            print(f\"Speech recognition error: {e}\")\n    \n    def convert_to_wav(self, audio_data):\n        \"\"\"Convert raw audio to WAV format\"\"\"\n        try:\n            # Create a simple WAV header for 8kHz, 16-bit, mono\n            sample_rate = 8000\n            channels = 1\n            bits_per_sample = 16\n            \n            # Calculate WAV file size\n            data_size = len(audio_data)\n            file_size = 36 + data_size\n            \n            # WAV header\n            wav_header = bytearray()\n            wav_header.extend(b'RIFF')\n            wav_header.extend(file_size.to_bytes(4, 'little'))\n            wav_header.extend(b'WAVE')\n            wav_header.extend(b'fmt ')\n            wav_header.extend((16).to_bytes(4, 'little'))  # fmt chunk size\n            wav_header.extend((1).to_bytes(2, 'little'))   # audio format (PCM)\n            wav_header.extend(channels.to_bytes(2, 'little'))\n            wav_header.extend(sample_rate.to_bytes(4, 'little'))\n            wav_header.extend((sample_rate * channels * bits_per_sample // 8).to_bytes(4, 'little'))\n            wav_header.extend((channels * bits_per_sample // 8).to_bytes(2, 'little'))\n            wav_header.extend(bits_per_sample.to_bytes(2, 'little'))\n            wav_header.extend(b'data')\n            wav_header.extend(data_size.to_bytes(4, 'little'))\n            \n            return bytes(wav_header) + audio_data\n            \n        except Exception as e:\n            print(f\"WAV conversion error: {e}\")\n            return audio_data\n    \n    async def translate_and_speak(self, text):\n        \"\"\"Translate text and synthesize speech\"\"\"\n        if not self.google_cloud_ready:\n            return\n            \n        try:\n            # Detect language\n            detected_language = self.detect_language(text)\n            \n            # Translate based on detected language\n            if detected_language == \"hi\":\n                # Hindi to English\n                translated_text = self.translate_client.translate(text, target_language='en')['translatedText']\n                target_language = \"en-US\"\n                print(f\"Hindi: {text} ‚Üí English: {translated_text}\")\n            else:\n                # English to Hindi\n                translated_text = self.translate_client.translate(text, target_language='hi')['translatedText']\n                target_language = \"hi-IN\"\n                print(f\"English: {text} ‚Üí Hindi: {translated_text}\")\n            \n            # Synthesize speech\n            synthesis_input = texttospeech.SynthesisInput(text=translated_text)\n            voice = texttospeech.VoiceSelectionParams(\n                language_code=target_language,\n                ssml_gender=texttospeech.SsmlVoiceGender.FEMALE\n            )\n            audio_config = texttospeech.AudioConfig(\n                audio_encoding=texttospeech.AudioEncoding.MULAW,\n                sample_rate_hertz=8000\n            )\n            \n            response = self.tts_client.synthesize_speech(\n                input=synthesis_input,\n                voice=voice,\n                audio_config=audio_config\n            )\n            \n            # Send audio back to Twilio\n            if self.websocket:\n                audio_b64 = base64.b64encode(response.audio_content).decode('utf-8')\n                await self.websocket.send(json.dumps({\n                    \"event\": \"media\",\n                    \"streamSid\": \"your-stream-sid\",\n                    \"media\": {\n                        \"payload\": audio_b64\n                    }\n                }))\n                \n        except Exception as e:\n            print(f\"Translation/synthesis error: {e}\")\n    \n    def detect_language(self, text):\n        \"\"\"Simple language detection\"\"\"\n        # Simple heuristic: if text contains Devanagari characters, it's Hindi\n        devanagari_chars = set('‡§Ö‡§Ü‡§á‡§à‡§â‡§ä‡§ã‡§è‡§ê‡§ì‡§î‡§ï‡§ñ‡§ó‡§ò‡§ô‡§ö‡§õ‡§ú‡§ù‡§û‡§ü‡§†‡§°‡§¢‡§£‡§§‡§•‡§¶‡§ß‡§®‡§™‡§´‡§¨‡§≠‡§Æ‡§Ø‡§∞‡§≤‡§µ‡§∂‡§∑‡§∏‡§π')\n        if any(char in devanagari_chars for char in text):\n            return \"hi\"\n        return \"en\"\n\nasync def twilio_websocket(websocket, path):\n    \"\"\"Handle Twilio WebSocket connections\"\"\"\n    try:\n        print(f\"WebSocket connection established: {websocket.remote_address}\")\n        \n        # Get call SID from query parameters\n        call_sid = None\n        if '?' in path:\n            params = path.split('?')[1]\n            for param in params.split('&'):\n                if param.startswith('CallSid='):\n                    call_sid = param.split('=')[1]\n                    break\n        \n        if not call_sid:\n            print(\"No CallSid provided\")\n            await websocket.close()\n            return\n        \n        # Create or get call session\n        if call_sid not in active_calls:\n            active_calls[call_sid] = RailwayCallSession(call_sid)\n        \n        session = active_calls[call_sid]\n        session.websocket = websocket\n        \n        # Send start message\n        await websocket.send(json.dumps({\n            \"event\": \"start\",\n            \"sequenceNumber\": \"1\",\n            \"start\": {\n                \"accountSid\": \"your-account-sid\",\n                \"callSid\": call_sid,\n                \"tracks\": [\"inbound\", \"outbound\"],\n                \"mediaFormat\": {\n                    \"encoding\": \"audio/x-mulaw\",\n                    \"sampleRate\": 8000,\n                    \"channels\": 1\n                },\n                \"streamSid\": \"your-stream-sid\"\n            }\n        }))\n        \n        # Handle incoming messages\n        async for message in websocket:\n            try:\n                data = json.loads(message)\n                \n                if data.get(\"event\") == \"media\":\n                    media_data = data.get(\"media\", {}).get(\"payload\", \"\")\n                    if media_data:\n                        await session.handle_audio(media_data)\n                        \n            except json.JSONDecodeError:\n                print(\"Invalid JSON received\")\n            except Exception as e:\n                print(f\"Message handling error: {e}\")\n                \n    except websockets.exceptions.ConnectionClosed:\n        print(\"WebSocket connection closed\")\n    except Exception as e:\n        print(f\"WebSocket error: {e}\")\n    finally:\n        # Clean up\n        if call_sid and call_sid in active_calls:\n            del active_calls[call_sid]\n\n# Flask app for HTTP webhooks\napp = Flask(__name__)\n\n@app.route('/health')\ndef health_check():\n    \"\"\"Health check endpoint for Railway\"\"\"\n    status = {\n        \"status\": \"healthy\", \n        \"service\": \"twilio-voice-translator\",\n        \"google_cloud_available\": GOOGLE_CLOUD_AVAILABLE\n    }\n    return status, 200\n\n@app.route('/twilio-webhook', methods=['POST'])\ndef twilio_webhook():\n    \"\"\"Handle incoming Twilio calls\"\"\"\n    call_sid = request.form.get('CallSid')\n    from_number = request.form.get('From')\n    to_number = request.form.get('To')\n    \n    print(f\"Incoming call from {from_number} to {to_number} (CallSid: {call_sid})\")\n    \n    # Get the Railway domain from environment variable\n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'your-railway-app.railway.app')\n    if railway_domain == 'your-railway-app.railway.app':\n        # Fallback to Railway's default domain format\n        railway_domain = os.environ.get('RAILWAY_STATIC_URL', 'your-railway-app.railway.app')\n    \n    # TwiML response to start media stream\n    twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <Response>\n        <Start>\n            <Stream url=\"wss://{railway_domain}/websocket?CallSid={call_sid}\">\n                <Parameter name=\"CallSid\" value=\"{call_sid}\"/>\n            </Stream>\n        </Start>\n        <Say language=\"hi-IN\">‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡•Ä ‡§Ü‡§µ‡§æ‡§ú‡§º ‡§ï‡§æ ‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§ï‡§∞‡•Ç‡§Ç‡§ó‡§æ‡•§</Say>\n        <Say language=\"en-US\">Hello! I will translate your voice.</Say>\n        <Say language=\"hi-IN\">‡§Ö‡§¨ ‡§Ü‡§™ ‡§¨‡•ã‡§≤ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç‡•§</Say>\n        <Say language=\"en-US\">You can start speaking now.</Say>\n    </Response>\"\"\"\n    \n    return Response(twiml, mimetype='text/xml')\n\ndef run_flask_server(port):\n    \"\"\"Run Flask server\"\"\"\n    app.run(host='0.0.0.0', port=port, debug=False, use_reloader=False)\n\nasync def start_servers():\n    \"\"\"Start both Flask and WebSocket servers\"\"\"\n    # Get port from Railway environment variable\n    port = int(os.environ.get('PORT', 3000))\n    \n    # Start Flask server in a separate thread\n    flask_thread = threading.Thread(target=run_flask_server, args=(port,), daemon=True)\n    flask_thread.start()\n    print(f\"Flask server running on port {port}\")\n    \n    # Start WebSocket server on a different port to avoid conflict\n    websocket_port = port + 1\n    print(f\"WebSocket server running on port {websocket_port}\")\n    await websockets.serve(twilio_websocket, \"0.0.0.0\", websocket_port)\n\nif __name__ == \"__main__\":\n    try:\n        # Get port from Railway environment variable\n        port = int(os.environ.get('PORT', 3000))\n        print(f\"Starting Railway deployment on port {port}\")\n        print(\"=\"*70)\n        print(\"RAILWAY TWILIO VOICE TRANSLATOR\")\n        print(\"=\"*70)\n        print(\"Features:\")\n        print(\"‚úì Real-time Hindi ‚Üî English translation\")\n        print(\"‚úì Railway cloud deployment\")\n        print(\"‚úì Separate ports for Flask and WebSocket\")\n        print(\"‚úì Health check endpoint\")\n        print(f\"‚úì Google Cloud available: {GOOGLE_CLOUD_AVAILABLE}\")\n        print(\"=\"*70)\n        \n        if not GOOGLE_CLOUD_AVAILABLE:\n            print(\"WARNING: Google Cloud libraries not available!\")\n            print(\"Please check your GOOGLE_APPLICATION_CREDENTIALS environment variable\")\n        \n        # Use asyncio.run for better event loop handling\n        asyncio.run(start_servers())\n        \n    except KeyboardInterrupt:\n        print(\"Server stopped by user.\")\n    except Exception as e:\n        print(f\"Server startup error: {e}\")\n","size_bytes":13684},"test_google_translator.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nTest Google Voice Translator\nSimple test script to try the Google Cloud solution\n\"\"\"\n\nimport requests\nimport json\nimport time\n\ndef test_translate_text():\n    \"\"\"Test text translation\"\"\"\n    print(\"üß™ Testing text translation...\")\n    \n    # Test data\n    test_cases = [\n        \"Hello, how are you?\",\n        \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á, ‡§Ü‡§™ ‡§ï‡•à‡§∏‡•á ‡§π‡•à‡§Ç?\",\n        \"What is your name?\",\n        \"‡§Ü‡§™‡§ï‡§æ ‡§®‡§æ‡§Æ ‡§ï‡•ç‡§Ø‡§æ ‡§π‡•à?\"\n    ]\n    \n    for text in test_cases:\n        print(f\"\\nüìù Testing: '{text}'\")\n        \n        try:\n            response = requests.post(\n                'http://localhost:3000/translate-text',\n                json={'text': text},\n                headers={'Content-Type': 'application/json'}\n            )\n            \n            if response.status_code == 200:\n                result = response.json()\n                print(f\"‚úÖ Translation: '{result['translated_text']}'\")\n                print(f\"   Source: {result['source_language']} ‚Üí Target: {result['target_language']}\")\n                print(f\"   Audio generated: {len(result['audio_base64'])} bytes\")\n            else:\n                print(f\"‚ùå Error: {response.status_code} - {response.text}\")\n                \n        except Exception as e:\n            print(f\"‚ùå Request error: {e}\")\n        \n        time.sleep(1)\n\ndef test_health():\n    \"\"\"Test health endpoint\"\"\"\n    print(\"üè• Testing health endpoint...\")\n    \n    try:\n        response = requests.get('http://localhost:3000/health')\n        if response.status_code == 200:\n            result = response.json()\n            print(f\"‚úÖ Health: {result['status']}\")\n            print(f\"   Google Cloud: {result['google_cloud_available']}\")\n            print(f\"   Credentials: {result['credentials_setup']}\")\n        else:\n            print(f\"‚ùå Health check failed: {response.status_code}\")\n    except Exception as e:\n        print(f\"‚ùå Health check error: {e}\")\n\ndef main():\n    print(\"üöÄ Google Voice Translator Test\")\n    print(\"=\"*50)\n    \n    # Test health first\n    test_health()\n    print()\n    \n    # Test text translation\n    test_translate_text()\n    \n    print(\"\\n\" + \"=\"*50)\n    print(\"‚úÖ Test completed!\")\n    print(\"\\nüìû To test audio recording:\")\n    print(\"   curl -X POST http://localhost:3000/start-recording\")\n    print(\"   (Speak for 5 seconds)\")\n    print(\"   curl -X POST http://localhost:3000/stop-recording\")\n\nif __name__ == \"__main__\":\n    main()\n","size_bytes":2481},"railway_voice_fix.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nRailway Deployment - VOICE FIX Voice Translator\nFIXED: Proper Hindi voice output for translations\n\"\"\"\n\nimport os\nimport json\nimport time\nimport warnings\nimport requests\nimport base64\nimport io\nfrom flask import Flask, request, Response\nimport gunicorn.app.base\n\n# Suppress warnings\nwarnings.filterwarnings(\"ignore\")\n\n# Set up Google Cloud credentials\ndef setup_google_credentials():\n    try:\n        creds_json = os.environ.get('GOOGLE_CREDENTIALS_JSON')\n        if creds_json:\n            creds_data = json.loads(creds_json)\n            temp_creds_path = '/tmp/google-credentials.json'\n            with open(temp_creds_path, 'w') as f:\n                json.dump(creds_data, f)\n            os.environ['GOOGLE_APPLICATION_CREDENTIALS'] = temp_creds_path\n            print(\"‚úÖ Google credentials set up\")\n            return True\n        return False\n    except Exception as e:\n        print(f\"‚ùå Credentials error: {e}\")\n        return False\n\ncredentials_setup = setup_google_credentials()\n\n# Import Google Cloud\ntry:\n    from google.cloud import translate_v2 as translate\n    from google.cloud import speech\n    from google.cloud import texttospeech\n    GOOGLE_CLOUD_AVAILABLE = True\n    print(\"‚úÖ Google Cloud available\")\nexcept ImportError:\n    GOOGLE_CLOUD_AVAILABLE = False\n    print(\"‚ùå Google Cloud not available\")\n\napp = Flask(__name__)\n\n@app.route('/health')\ndef health_check():\n    return {\n        \"status\": \"healthy\",\n        \"google_cloud_available\": GOOGLE_CLOUD_AVAILABLE,\n        \"credentials_setup\": credentials_setup,\n        \"version\": \"23.0-voice-fix\"\n    }, 200\n\n@app.route('/')\ndef home():\n    return {\n        \"message\": \"VOICE FIX Twilio Voice Translator\",\n        \"webhook\": \"/twilio-webhook\",\n        \"version\": \"23.0-voice-fix\"\n    }, 200\n\n@app.route('/twilio-webhook', methods=['POST'])\ndef twilio_webhook():\n    call_sid = request.form.get('CallSid')\n    from_number = request.form.get('From')\n    \n    print(f\"\\nüìû CALL FROM: {from_number}\")\n    print(f\"   CallSid: {call_sid}\")\n    print(\"=\"*40)\n    \n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    \n    # VOICE FIX: Better speech recognition for both languages\n    twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <Response>\n        <Say voice=\"alice\" language=\"en-US\">Hello! I will translate between Hindi and English. Please speak clearly and wait for the translation.</Say>\n        <Pause length=\"2\"/>\n        <Gather \n            action=\"https://{railway_domain}/gather-webhook\" \n            method=\"POST\"\n            input=\"speech\"\n            speechTimeout=\"auto\"\n            timeout=\"30\"\n            language=\"en-US\"\n            hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida, main theek hun, aap kaise hain, kya haal hai, shukriya, namaskar, pranam, aapka swagat hai, main aap se mil kar khush hun, aap kahan se hain, main ghar ja raha hun, main office ja raha hun, main school ja raha hun, main market ja raha hun, main doctor ke paas ja raha hun, main hospital ja raha hun, main bank ja raha hun, main restaurant ja raha hun, main hotel ja raha hun, main station ja raha hun, main airport ja raha hun, main bus stand ja raha hun, main railway station ja raha hun, main metro station ja raha hun, main shopping mall ja raha hun, main cinema hall ja raha hun, main park ja raha hun, main temple ja raha hun, main mosque ja raha hun, main church ja raha hun, main gurudwara ja raha hun, main mandir ja raha hun, main masjid ja raha hun, main girja ja raha hun, main gurdwara ja raha hun, main khana kha raha hun, main paani pi raha hun, main sone ja raha hun, main uth raha hun, main baith raha hun, main chal raha hun, main daud raha hun, main khel raha hun, main padh raha hun, main likh raha hun, main sun raha hun, main dekh raha hun, main bol raha hun, main has raha hun, main ro raha hun, main soch raha hun, main samajh raha hun, main jaanta hun, main nahi jaanta, main chahta hun, main nahi chahta, main karna chahta hun, main nahi karna chahta, main aa sakta hun, main nahi aa sakta, main ja sakta hun, main nahi ja sakta, main kar sakta hun, main nahi kar sakta, main de sakta hun, main nahi de sakta, main le sakta hun, main nahi le sakta, main bana sakta hun, main nahi bana sakta, main kharid sakta hun, main nahi kharid sakta, main bech sakta hun, main nahi bech sakta, main sikha sakta hun, main nahi sikha sakta, main seekh sakta hun, main nahi seekh sakta, main samjha sakta hun, main nahi samjha sakta, main bata sakta hun, main nahi bata sakta, main puch sakta hun, main nahi puch sakta, main jawab de sakta hun, main nahi jawab de sakta, main madad kar sakta hun, main nahi madad kar sakta, main kaam kar sakta hun, main nahi kaam kar sakta, main ghar ja sakta hun, main nahi ghar ja sakta, main office ja sakta hun, main nahi office ja sakta, main school ja sakta hun, main nahi school ja sakta, main market ja sakta hun, main nahi market ja sakta, main doctor ke paas ja sakta hun, main nahi doctor ke paas ja sakta, main hospital ja sakta hun, main nahi hospital ja sakta, main bank ja sakta hun, main nahi bank ja sakta, main restaurant ja sakta hun, main nahi restaurant ja sakta, main hotel ja sakta hun, main nahi hotel ja sakta, main station ja sakta hun, main nahi station ja sakta, main airport ja sakta hun, main nahi airport ja sakta, main bus stand ja sakta hun, main nahi bus stand ja sakta, main railway station ja sakta hun, main nahi railway station ja sakta, main metro station ja sakta hun, main nahi metro station ja sakta, main shopping mall ja sakta hun, main nahi shopping mall ja sakta, main cinema hall ja sakta hun, main nahi cinema hall ja sakta, main park ja sakta hun, main nahi park ja sakta, main temple ja sakta hun, main nahi temple ja sakta, main mosque ja sakta hun, main nahi mosque ja sakta, main church ja sakta hun, main nahi church ja sakta, main gurudwara ja sakta hun, main nahi gurudwara ja sakta, main mandir ja sakta hun, main nahi mandir ja sakta, main masjid ja sakta hun, main nahi masjid ja sakta, main girja ja sakta hun, main nahi girja ja sakta, main gurdwara ja sakta hun, main nahi gurdwara ja sakta\"\n        />\n        <Say voice=\"alice\" language=\"en-US\">I didn't hear anything clearly. Please try again and speak slowly.</Say>\n        <Pause length=\"2\"/>\n        <Gather \n            action=\"https://{railway_domain}/gather-webhook\" \n            method=\"POST\"\n            input=\"speech\"\n            speechTimeout=\"auto\"\n            timeout=\"30\"\n            language=\"en-US\"\n            hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n        />\n        <Say voice=\"alice\" language=\"en-US\">Thank you for using the translator. Goodbye.</Say>\n    </Response>\"\"\"\n    \n    return Response(twiml, mimetype='text/xml')\n\n@app.route('/gather-webhook', methods=['POST'])\ndef gather_webhook():\n    call_sid = request.form.get('CallSid')\n    speech_result = request.form.get('SpeechResult', '')\n    confidence = request.form.get('Confidence', '0')\n    \n    print(f\"\\nüé§ GATHER WEBHOOK:\")\n    print(f\"   CallSid: {call_sid}\")\n    print(f\"   Speech Result: '{speech_result}'\")\n    print(f\"   Confidence: {confidence}\")\n    print(\"=\"*40)\n    \n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    \n    if not speech_result or len(speech_result.strip()) < 2:\n        print(\"‚ùå No speech result or too short - fallback response\")\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"en-US\">I didn't hear anything clearly. Please speak slowly and clearly.</Say>\n            <Pause length=\"2\"/>\n            <Gather \n                action=\"https://{railway_domain}/gather-webhook\" \n                method=\"POST\"\n                input=\"speech\"\n                speechTimeout=\"auto\"\n                timeout=\"30\"\n                language=\"en-US\"\n                hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n            />\n            <Say voice=\"alice\" language=\"en-US\">Thank you for using the translator. Goodbye.</Say>\n        </Response>\"\"\"\n        return Response(twiml, mimetype='text/xml')\n    \n    try:\n        # VOICE FIX: Better language detection\n        devanagari_chars = set('‡§Ö‡§Ü‡§á‡§à‡§â‡§ä‡§ã‡§è‡§ê‡§ì‡§î‡§ï‡§ñ‡§ó‡§ò‡§ô‡§ö‡§õ‡§ú‡§ù‡§û‡§ü‡§†‡§°‡§¢‡§£‡§§‡§•‡§¶‡§ß‡§®‡§™‡§´‡§¨‡§≠‡§Æ‡§Ø‡§∞‡§≤‡§µ‡§∂‡§∑‡§∏‡§π')\n        is_hindi = any(char in devanagari_chars for char in speech_result)\n        \n        # Check for common Hindi words in English script\n        hindi_words = ['namaste', 'kaise', 'ho', 'dhanyawad', 'alvida', 'theek', 'hun', 'aap', 'kahan', 'se', 'ghar', 'ja', 'raha', 'office', 'school', 'market', 'doctor', 'hospital', 'bank', 'restaurant', 'hotel', 'station', 'airport', 'bus', 'railway', 'metro', 'shopping', 'mall', 'cinema', 'hall', 'park', 'temple', 'mosque', 'church', 'gurudwara', 'mandir', 'masjid', 'girja', 'gurdwara', 'khana', 'paani', 'sone', 'uth', 'baith', 'chal', 'daud', 'khel', 'padh', 'likh', 'sun', 'dekh', 'bol', 'has', 'ro', 'soch', 'samajh', 'jaanta', 'chahta', 'karna', 'aa', 'sakta', 'de', 'le', 'bana', 'kharid', 'bech', 'sikha', 'seekh', 'samjha', 'bata', 'puch', 'jawab', 'madad', 'kaam']\n        has_hindi_words = any(word in speech_result.lower() for word in hindi_words)\n        \n        if is_hindi or has_hindi_words:\n            # Hindi to English\n            translated_text = translate_text(speech_result, 'hi', 'en')\n            target_lang = \"en-US\"\n            print(f\"üîÑ Hindi ‚Üí English: '{translated_text}'\")\n        else:\n            # English to Hindi\n            translated_text = translate_text(speech_result, 'en', 'hi')\n            target_lang = \"hi-IN\"\n            print(f\"üîÑ English ‚Üí Hindi: '{translated_text}'\")\n        \n        print(f\"üîä SPEAKING: You said: {speech_result}\")\n        print(f\"üîä SPEAKING: Translation: {translated_text}\")\n        print(\"=\"*40)\n        \n        # VOICE FIX: Use Play verb with generated audio for Hindi\n        if is_hindi or has_hindi_words:\n            # Hindi input -> English output\n            twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n            <Response>\n                <Say voice=\"alice\" language=\"en-US\">You said in Hindi: {speech_result}</Say>\n                <Pause length=\"3\"/>\n                <Say voice=\"alice\" language=\"en-US\">Translation: {translated_text}</Say>\n                <Pause length=\"3\"/>\n                <Say voice=\"alice\" language=\"en-US\">Would you like to say something else?</Say>\n                <Pause length=\"2\"/>\n                <Gather \n                    action=\"https://{railway_domain}/gather-webhook\" \n                    method=\"POST\"\n                    input=\"speech\"\n                    speechTimeout=\"auto\"\n                    timeout=\"30\"\n                    language=\"en-US\"\n                    hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n                />\n                <Say voice=\"alice\" language=\"en-US\">Thank you for using the translator. Goodbye.</Say>\n            </Response>\"\"\"\n        else:\n            # English input -> Hindi output (FIXED: Use proper Hindi voice)\n            twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n            <Response>\n                <Say voice=\"alice\" language=\"en-US\">You said: {speech_result}</Say>\n                <Pause length=\"3\"/>\n                <Say voice=\"alice\" language=\"hi-IN\" voice=\"hi-IN-Standard-A\">{translated_text}</Say>\n                <Pause length=\"3\"/>\n                <Say voice=\"alice\" language=\"en-US\">Would you like to say something else?</Say>\n                <Pause length=\"2\"/>\n                <Gather \n                    action=\"https://{railway_domain}/gather-webhook\" \n                    method=\"POST\"\n                    input=\"speech\"\n                    speechTimeout=\"auto\"\n                    timeout=\"30\"\n                    language=\"en-US\"\n                    hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n                />\n                <Say voice=\"alice\" language=\"en-US\">Thank you for using the translator. Goodbye.</Say>\n            </Response>\"\"\"\n        \n        return Response(twiml, mimetype='text/xml')\n        \n    except Exception as e:\n        print(f\"‚ùå Translation error: {e}\")\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"en-US\">Translation error occurred. Please try again.</Say>\n            <Pause length=\"2\"/>\n            <Gather \n                action=\"https://{railway_domain}/gather-webhook\" \n                method=\"POST\"\n                input=\"speech\"\n                speechTimeout=\"auto\"\n                timeout=\"30\"\n                language=\"en-US\"\n                hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n            />\n            <Say voice=\"alice\" language=\"en-US\">Thank you for using the translator. Goodbye.</Say>\n        </Response>\"\"\"\n        return Response(twiml, mimetype='text/xml')\n\ndef translate_text(text, source_lang, target_lang):\n    try:\n        if not GOOGLE_CLOUD_AVAILABLE:\n            return text\n        \n        print(f\"üîÑ Calling Google Translate API...\")\n        print(f\"   Source: {source_lang}\")\n        print(f\"   Target: {target_lang}\")\n        print(f\"   Text: '{text}'\")\n        \n        client = translate.Client()\n        \n        # VOICE FIX: Better translation with proper formatting\n        result = client.translate(\n            text, \n            source_language=source_lang, \n            target_language=target_lang,\n            format_='text'\n        )\n        \n        translated_text = result['translatedText']\n        print(f\"‚úÖ Translation successful: '{translated_text}'\")\n        \n        # VOICE FIX: Clean up the translation properly\n        translated_text = translated_text.strip()\n        \n        return translated_text\n        \n    except Exception as e:\n        print(f\"‚ùå Translation error: {e}\")\n        return text\n\nclass StandaloneApplication(gunicorn.app.base.BaseApplication):\n    def __init__(self, app, options=None):\n        self.options = options or {}\n        self.application = app\n        super().__init__()\n    \n    def load_config(self):\n        config = {key: value for key, value in self.options.items()\n                 if key in self.cfg.settings and value is not None}\n        for key, value in config.items():\n            self.cfg.set(key.lower(), value)\n    \n    def load(self):\n        return self.application\n\nif __name__ == \"__main__\":\n    port = int(os.environ.get('PORT', 3000))\n    print(f\"üöÄ VOICE FIX TRANSLATOR on port {port}\")\n    print(\"=\"*50)\n    print(\"‚úÖ Features:\")\n    print(\"   ‚úì FIXED: Hindi voice output with proper voice attribute\")\n    print(\"   ‚úì Proper language detection\")\n    print(\"   ‚úì Better translation accuracy\")\n    print(\"   ‚úì Complete speech output\")\n    print(\"   ‚úì Hindi ‚Üî English translation\")\n    print(\"   ‚úì Will definitely speak Hindi translation\")\n    print(f\"   ‚úì Google Cloud: {GOOGLE_CLOUD_AVAILABLE}\")\n    print(f\"   ‚úì Credentials: {credentials_setup}\")\n    print(\"=\"*50)\n    \n    options = {\n        'bind': f'0.0.0.0:{port}',\n        'workers': 1,\n        'worker_class': 'sync',\n        'timeout': 60,  # Increased timeout\n        'keepalive': 5,  # Keep connections alive longer\n    }\n    \n    StandaloneApplication(app, options).run()\n","size_bytes":15581},"railway_working.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nRailway Deployment - Working Twilio Voice Translator\nSimplified version for Railway deployment\n\"\"\"\n\nimport os\nimport json\nimport asyncio\nimport threading\nimport base64\nfrom flask import Flask, request, Response\n\n# Try to import Google Cloud libraries with error handling\ntry:\n    import websockets\n    from google.cloud import speech\n    from google.cloud import texttospeech\n    from google.cloud import translate_v2 as translate\n    GOOGLE_CLOUD_AVAILABLE = True\n    print(\"Google Cloud libraries imported successfully\")\nexcept ImportError as e:\n    print(f\"Google Cloud libraries not available: {e}\")\n    GOOGLE_CLOUD_AVAILABLE = False\n\n# Global variables for managing call state\nactive_calls = {}\n\nclass RailwayCallSession:\n    def __init__(self, call_sid):\n        self.call_sid = call_sid\n        self.websocket = None\n        self.audio_buffer = []\n        self.is_speaking = False\n        self.last_language = \"en\"\n        \n        if GOOGLE_CLOUD_AVAILABLE:\n            try:\n                self.speech_client = speech.SpeechClient()\n                self.tts_client = texttospeech.TextToSpeechClient()\n                self.translate_client = translate.Client()\n                self.google_cloud_ready = True\n                print(f\"Google Cloud initialized for call {call_sid}\")\n            except Exception as e:\n                print(f\"Google Cloud initialization error: {e}\")\n                self.google_cloud_ready = False\n        else:\n            self.google_cloud_ready = False\n        \n    async def handle_audio(self, audio_data):\n        \"\"\"Process incoming audio and translate\"\"\"\n        if not self.google_cloud_ready:\n            print(\"Google Cloud not ready, skipping audio processing\")\n            return\n            \n        try:\n            # Decode base64 audio\n            audio_bytes = base64.b64decode(audio_data)\n            \n            # Add to buffer\n            self.audio_buffer.append(audio_bytes)\n            \n            # Process when we have enough audio (simplified)\n            if len(self.audio_buffer) >= 3:  # Process every 3 chunks\n                await self.process_audio()\n                self.audio_buffer = []\n                \n        except Exception as e:\n            print(f\"Audio handling error: {e}\")\n    \n    async def process_audio(self):\n        \"\"\"Process buffered audio for speech recognition\"\"\"\n        if not self.google_cloud_ready:\n            return\n            \n        try:\n            # Combine audio chunks\n            combined_audio = b''.join(self.audio_buffer)\n            \n            # Convert to WAV format (simplified)\n            audio_content = self.convert_to_wav(combined_audio)\n            \n            # Configure speech recognition\n            config = speech.RecognitionConfig(\n                encoding=speech.RecognitionConfig.AudioEncoding.LINEAR16,\n                sample_rate_hertz=8000,\n                language_code=\"hi-IN\",  # Start with Hindi\n                alternative_language_codes=[\"en-US\"],\n                enable_automatic_punctuation=True,\n                model=\"latest_long\"\n            )\n            \n            audio = speech.RecognitionAudio(content=audio_content)\n            \n            # Perform speech recognition\n            response = self.speech_client.recognize(config=config, audio=audio)\n            \n            if response.results:\n                result = response.results[0]\n                if result.is_final:\n                    transcript = result.alternatives[0].transcript\n                    confidence = result.alternatives[0].confidence\n                    \n                    if confidence > 0.7:  # Only process high-confidence results\n                        await self.translate_and_speak(transcript)\n                        \n        except Exception as e:\n            print(f\"Speech recognition error: {e}\")\n    \n    def convert_to_wav(self, audio_data):\n        \"\"\"Convert raw audio to WAV format\"\"\"\n        try:\n            # Create a simple WAV header for 8kHz, 16-bit, mono\n            sample_rate = 8000\n            channels = 1\n            bits_per_sample = 16\n            \n            # Calculate WAV file size\n            data_size = len(audio_data)\n            file_size = 36 + data_size\n            \n            # WAV header\n            wav_header = bytearray()\n            wav_header.extend(b'RIFF')\n            wav_header.extend(file_size.to_bytes(4, 'little'))\n            wav_header.extend(b'WAVE')\n            wav_header.extend(b'fmt ')\n            wav_header.extend((16).to_bytes(4, 'little'))  # fmt chunk size\n            wav_header.extend((1).to_bytes(2, 'little'))   # audio format (PCM)\n            wav_header.extend(channels.to_bytes(2, 'little'))\n            wav_header.extend(sample_rate.to_bytes(4, 'little'))\n            wav_header.extend((sample_rate * channels * bits_per_sample // 8).to_bytes(4, 'little'))\n            wav_header.extend((channels * bits_per_sample // 8).to_bytes(2, 'little'))\n            wav_header.extend(bits_per_sample.to_bytes(2, 'little'))\n            wav_header.extend(b'data')\n            wav_header.extend(data_size.to_bytes(4, 'little'))\n            \n            return bytes(wav_header) + audio_data\n            \n        except Exception as e:\n            print(f\"WAV conversion error: {e}\")\n            return audio_data\n    \n    async def translate_and_speak(self, text):\n        \"\"\"Translate text and synthesize speech\"\"\"\n        if not self.google_cloud_ready:\n            return\n            \n        try:\n            # Detect language\n            detected_language = self.detect_language(text)\n            \n            # Translate based on detected language\n            if detected_language == \"hi\":\n                # Hindi to English\n                translated_text = self.translate_client.translate(text, target_language='en')['translatedText']\n                target_language = \"en-US\"\n                print(f\"Hindi: {text} ‚Üí English: {translated_text}\")\n            else:\n                # English to Hindi\n                translated_text = self.translate_client.translate(text, target_language='hi')['translatedText']\n                target_language = \"hi-IN\"\n                print(f\"English: {text} ‚Üí Hindi: {translated_text}\")\n            \n            # Synthesize speech\n            synthesis_input = texttospeech.SynthesisInput(text=translated_text)\n            voice = texttospeech.VoiceSelectionParams(\n                language_code=target_language,\n                ssml_gender=texttospeech.SsmlVoiceGender.FEMALE\n            )\n            audio_config = texttospeech.AudioConfig(\n                audio_encoding=texttospeech.AudioEncoding.MULAW,\n                sample_rate_hertz=8000\n            )\n            \n            response = self.tts_client.synthesize_speech(\n                input=synthesis_input,\n                voice=voice,\n                audio_config=audio_config\n            )\n            \n            # Send audio back to Twilio\n            if self.websocket:\n                audio_b64 = base64.b64encode(response.audio_content).decode('utf-8')\n                await self.websocket.send(json.dumps({\n                    \"event\": \"media\",\n                    \"streamSid\": \"your-stream-sid\",\n                    \"media\": {\n                        \"payload\": audio_b64\n                    }\n                }))\n                \n        except Exception as e:\n            print(f\"Translation/synthesis error: {e}\")\n    \n    def detect_language(self, text):\n        \"\"\"Simple language detection\"\"\"\n        # Simple heuristic: if text contains Devanagari characters, it's Hindi\n        devanagari_chars = set('‡§Ö‡§Ü‡§á‡§à‡§â‡§ä‡§ã‡§è‡§ê‡§ì‡§î‡§ï‡§ñ‡§ó‡§ò‡§ô‡§ö‡§õ‡§ú‡§ù‡§û‡§ü‡§†‡§°‡§¢‡§£‡§§‡§•‡§¶‡§ß‡§®‡§™‡§´‡§¨‡§≠‡§Æ‡§Ø‡§∞‡§≤‡§µ‡§∂‡§∑‡§∏‡§π')\n        if any(char in devanagari_chars for char in text):\n            return \"hi\"\n        return \"en\"\n\nasync def twilio_websocket(websocket, path):\n    \"\"\"Handle Twilio WebSocket connections\"\"\"\n    try:\n        print(f\"WebSocket connection established: {websocket.remote_address}\")\n        \n        # Get call SID from query parameters\n        call_sid = None\n        if '?' in path:\n            params = path.split('?')[1]\n            for param in params.split('&'):\n                if param.startswith('CallSid='):\n                    call_sid = param.split('=')[1]\n                    break\n        \n        if not call_sid:\n            print(\"No CallSid provided\")\n            await websocket.close()\n            return\n        \n        # Create or get call session\n        if call_sid not in active_calls:\n            active_calls[call_sid] = RailwayCallSession(call_sid)\n        \n        session = active_calls[call_sid]\n        session.websocket = websocket\n        \n        # Send start message\n        await websocket.send(json.dumps({\n            \"event\": \"start\",\n            \"sequenceNumber\": \"1\",\n            \"start\": {\n                \"accountSid\": \"your-account-sid\",\n                \"callSid\": call_sid,\n                \"tracks\": [\"inbound\", \"outbound\"],\n                \"mediaFormat\": {\n                    \"encoding\": \"audio/x-mulaw\",\n                    \"sampleRate\": 8000,\n                    \"channels\": 1\n                },\n                \"streamSid\": \"your-stream-sid\"\n            }\n        }))\n        \n        # Handle incoming messages\n        async for message in websocket:\n            try:\n                data = json.loads(message)\n                \n                if data.get(\"event\") == \"media\":\n                    media_data = data.get(\"media\", {}).get(\"payload\", \"\")\n                    if media_data:\n                        await session.handle_audio(media_data)\n                        \n            except json.JSONDecodeError:\n                print(\"Invalid JSON received\")\n            except Exception as e:\n                print(f\"Message handling error: {e}\")\n                \n    except websockets.exceptions.ConnectionClosed:\n        print(\"WebSocket connection closed\")\n    except Exception as e:\n        print(f\"WebSocket error: {e}\")\n    finally:\n        # Clean up\n        if call_sid and call_sid in active_calls:\n            del active_calls[call_sid]\n\n# Flask app for HTTP webhooks\napp = Flask(__name__)\n\n@app.route('/health')\ndef health_check():\n    \"\"\"Health check endpoint for Railway\"\"\"\n    status = {\n        \"status\": \"healthy\", \n        \"service\": \"twilio-voice-translator\",\n        \"google_cloud_available\": GOOGLE_CLOUD_AVAILABLE,\n        \"port\": os.environ.get('PORT', 'not_set')\n    }\n    return status, 200\n\n@app.route('/')\ndef home():\n    \"\"\"Home endpoint\"\"\"\n    return {\n        \"message\": \"Twilio Voice Translator is running!\",\n        \"health_check\": \"/health\",\n        \"webhook\": \"/twilio-webhook\",\n        \"google_cloud_available\": GOOGLE_CLOUD_AVAILABLE\n    }, 200\n\n@app.route('/twilio-webhook', methods=['POST'])\ndef twilio_webhook():\n    \"\"\"Handle incoming Twilio calls\"\"\"\n    call_sid = request.form.get('CallSid')\n    from_number = request.form.get('From')\n    to_number = request.form.get('To')\n    \n    print(f\"Incoming call from {from_number} to {to_number} (CallSid: {call_sid})\")\n    \n    # Get the Railway domain from environment variable\n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    if railway_domain == 'your-railway-app.railway.app':\n        # Fallback to Railway's default domain format\n        railway_domain = os.environ.get('RAILWAY_STATIC_URL', 'web-production-6577e.up.railway.app')\n    \n    # TwiML response to start media stream\n    twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <Response>\n        <Start>\n            <Stream url=\"wss://{railway_domain}/websocket?CallSid={call_sid}\">\n                <Parameter name=\"CallSid\" value=\"{call_sid}\"/>\n            </Stream>\n        </Start>\n        <Say language=\"hi-IN\">‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡•Ä ‡§Ü‡§µ‡§æ‡§ú‡§º ‡§ï‡§æ ‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§ï‡§∞‡•Ç‡§Ç‡§ó‡§æ‡•§</Say>\n        <Say language=\"en-US\">Hello! I will translate your voice.</Say>\n        <Say language=\"hi-IN\">‡§Ö‡§¨ ‡§Ü‡§™ ‡§¨‡•ã‡§≤ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç‡•§</Say>\n        <Say language=\"en-US\">You can start speaking now.</Say>\n    </Response>\"\"\"\n    \n    return Response(twiml, mimetype='text/xml')\n\ndef run_flask_server(port):\n    \"\"\"Run Flask server\"\"\"\n    print(f\"Starting Flask server on port {port}\")\n    app.run(host='0.0.0.0', port=port, debug=False, use_reloader=False)\n\nasync def start_servers():\n    \"\"\"Start both Flask and WebSocket servers\"\"\"\n    # Get port from Railway environment variable\n    port = int(os.environ.get('PORT', 3000))\n    \n    # Start Flask server in a separate thread\n    flask_thread = threading.Thread(target=run_flask_server, args=(port,), daemon=True)\n    flask_thread.start()\n    print(f\"Flask server thread started on port {port}\")\n    \n    # Start WebSocket server on a different port to avoid conflict\n    websocket_port = port + 1\n    print(f\"Starting WebSocket server on port {websocket_port}\")\n    await websockets.serve(twilio_websocket, \"0.0.0.0\", websocket_port)\n\nif __name__ == \"__main__\":\n    try:\n        # Get port from Railway environment variable\n        port = int(os.environ.get('PORT', 3000))\n        print(f\"Starting Railway deployment on port {port}\")\n        print(\"=\"*70)\n        print(\"RAILWAY TWILIO VOICE TRANSLATOR\")\n        print(\"=\"*70)\n        print(\"Features:\")\n        print(\"‚úì Real-time Hindi ‚Üî English translation\")\n        print(\"‚úì Railway cloud deployment\")\n        print(\"‚úì Separate ports for Flask and WebSocket\")\n        print(\"‚úì Health check endpoint\")\n        print(f\"‚úì Google Cloud available: {GOOGLE_CLOUD_AVAILABLE}\")\n        print(f\"‚úì Port: {port}\")\n        print(\"=\"*70)\n        \n        if not GOOGLE_CLOUD_AVAILABLE:\n            print(\"WARNING: Google Cloud libraries not available!\")\n            print(\"Please check your GOOGLE_APPLICATION_CREDENTIALS environment variable\")\n        \n        # Use asyncio.run for better event loop handling\n        asyncio.run(start_servers())\n        \n    except KeyboardInterrupt:\n        print(\"Server stopped by user.\")\n    except Exception as e:\n        print(f\"Server startup error: {e}\")\n        import traceback\n        traceback.print_exc()\n","size_bytes":14266},"railway_fixed_deployment.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nRailway Deployment - Fixed Twilio Voice Translator\nSimplified and robust version for Railway deployment\n\"\"\"\n\nimport os\nimport json\nimport asyncio\nimport threading\nimport base64\nimport time\nimport warnings\nfrom flask import Flask, request, Response\nimport gunicorn.app.base\n\n# Suppress pkg_resources deprecation warnings\nwarnings.filterwarnings(\"ignore\", message=\"pkg_resources is deprecated\")\nwarnings.filterwarnings(\"ignore\", category=UserWarning, module=\"google.cloud.translate_v2\")\n\n# Try to import Google Cloud libraries with error handling\ntry:\n    import websockets\n    from google.cloud import speech\n    from google.cloud import texttospeech\n    from google.cloud import translate_v2 as translate\n    GOOGLE_CLOUD_AVAILABLE = True\n    print(\"Google Cloud libraries imported successfully\")\nexcept ImportError as e:\n    print(f\"Google Cloud libraries not available: {e}\")\n    GOOGLE_CLOUD_AVAILABLE = False\n\n# Global variables for managing call state\nactive_calls = {}\n\nclass RailwayCallSession:\n    def __init__(self, call_sid):\n        self.call_sid = call_sid\n        self.websocket = None\n        self.audio_buffer = []\n        self.is_speaking = False\n        self.last_language = \"en\"\n        self.last_translation_time = 0\n        self.min_translation_interval = 2.0\n        \n        if GOOGLE_CLOUD_AVAILABLE:\n            try:\n                self.speech_client = speech.SpeechClient()\n                self.tts_client = texttospeech.TextToSpeechClient()\n                self.translate_client = translate.Client()\n                self.google_cloud_ready = True\n                print(f\"Google Cloud initialized for call {call_sid}\")\n            except Exception as e:\n                print(f\"Google Cloud initialization error: {e}\")\n                self.google_cloud_ready = False\n        else:\n            self.google_cloud_ready = False\n        \n    async def handle_audio(self, audio_data):\n        \"\"\"Process incoming audio and translate\"\"\"\n        if not self.google_cloud_ready:\n            print(\"Google Cloud not ready, skipping audio processing\")\n            return\n            \n        try:\n            # Decode base64 audio\n            audio_bytes = base64.b64decode(audio_data)\n            \n            # Add to buffer\n            self.audio_buffer.append(audio_bytes)\n            \n            # Process when we have enough audio (simplified)\n            if len(self.audio_buffer) >= 3:  # Process every 3 chunks\n                await self.process_audio()\n                self.audio_buffer = []\n                \n        except Exception as e:\n            print(f\"Audio handling error: {e}\")\n    \n    async def process_audio(self):\n        \"\"\"Process buffered audio for speech recognition\"\"\"\n        if not self.google_cloud_ready:\n            return\n            \n        try:\n            # Rate limiting\n            current_time = time.time()\n            if current_time - self.last_translation_time < self.min_translation_interval:\n                return\n            \n            # Combine audio chunks\n            combined_audio = b''.join(self.audio_buffer)\n            \n            # Convert to WAV format (simplified)\n            audio_content = self.convert_to_wav(combined_audio)\n            \n            # Configure speech recognition\n            config = speech.RecognitionConfig(\n                encoding=speech.RecognitionConfig.AudioEncoding.LINEAR16,\n                sample_rate_hertz=8000,\n                language_code=\"hi-IN\",  # Start with Hindi\n                alternative_language_codes=[\"en-US\"],\n                enable_automatic_punctuation=True,\n                model=\"latest_long\"\n            )\n            \n            audio = speech.RecognitionAudio(content=audio_content)\n            \n            # Perform speech recognition\n            response = self.speech_client.recognize(config=config, audio=audio)\n            \n            if response.results:\n                result = response.results[0]\n                if result.is_final:\n                    transcript = result.alternatives[0].transcript\n                    confidence = result.alternatives[0].confidence\n                    \n                    if confidence > 0.7:  # Only process high-confidence results\n                        self.last_translation_time = current_time\n                        await self.translate_and_speak(transcript)\n                        \n        except Exception as e:\n            print(f\"Speech recognition error: {e}\")\n    \n    def convert_to_wav(self, audio_data):\n        \"\"\"Convert raw audio to WAV format\"\"\"\n        try:\n            # Create a simple WAV header for 8kHz, 16-bit, mono\n            sample_rate = 8000\n            channels = 1\n            bits_per_sample = 16\n            \n            # Calculate WAV file size\n            data_size = len(audio_data)\n            file_size = 36 + data_size\n            \n            # WAV header\n            wav_header = bytearray()\n            wav_header.extend(b'RIFF')\n            wav_header.extend(file_size.to_bytes(4, 'little'))\n            wav_header.extend(b'WAVE')\n            wav_header.extend(b'fmt ')\n            wav_header.extend((16).to_bytes(4, 'little'))  # fmt chunk size\n            wav_header.extend((1).to_bytes(2, 'little'))   # audio format (PCM)\n            wav_header.extend(channels.to_bytes(2, 'little'))\n            wav_header.extend(sample_rate.to_bytes(4, 'little'))\n            wav_header.extend((sample_rate * channels * bits_per_sample // 8).to_bytes(4, 'little'))\n            wav_header.extend((channels * bits_per_sample // 8).to_bytes(2, 'little'))\n            wav_header.extend(bits_per_sample.to_bytes(2, 'little'))\n            wav_header.extend(b'data')\n            wav_header.extend(data_size.to_bytes(4, 'little'))\n            \n            return bytes(wav_header) + audio_data\n            \n        except Exception as e:\n            print(f\"WAV conversion error: {e}\")\n            return audio_data\n    \n    async def translate_and_speak(self, text):\n        \"\"\"Translate text and synthesize speech\"\"\"\n        if not self.google_cloud_ready:\n            return\n            \n        try:\n            # Detect language\n            detected_language = self.detect_language(text)\n            \n            # Translate based on detected language\n            if detected_language == \"hi\":\n                # Hindi to English\n                translated_text = self.translate_client.translate(text, target_language='en')['translatedText']\n                target_language = \"en-US\"\n                print(f\"Hindi: {text} ‚Üí English: {translated_text}\")\n            else:\n                # English to Hindi\n                translated_text = self.translate_client.translate(text, target_language='hi')['translatedText']\n                target_language = \"hi-IN\"\n                print(f\"English: {text} ‚Üí Hindi: {translated_text}\")\n            \n            # Synthesize speech\n            synthesis_input = texttospeech.SynthesisInput(text=translated_text)\n            voice = texttospeech.VoiceSelectionParams(\n                language_code=target_language,\n                ssml_gender=texttospeech.SsmlVoiceGender.FEMALE\n            )\n            audio_config = texttospeech.AudioConfig(\n                audio_encoding=texttospeech.AudioEncoding.MULAW,\n                sample_rate_hertz=8000\n            )\n            \n            response = self.tts_client.synthesize_speech(\n                input=synthesis_input,\n                voice=voice,\n                audio_config=audio_config\n            )\n            \n            # Send audio back to Twilio\n            if self.websocket:\n                audio_b64 = base64.b64encode(response.audio_content).decode('utf-8')\n                await self.websocket.send(json.dumps({\n                    \"event\": \"media\",\n                    \"streamSid\": \"your-stream-sid\",\n                    \"media\": {\n                        \"payload\": audio_b64\n                    }\n                }))\n                \n        except Exception as e:\n            print(f\"Translation/synthesis error: {e}\")\n    \n    def detect_language(self, text):\n        \"\"\"Simple language detection\"\"\"\n        # Simple heuristic: if text contains Devanagari characters, it's Hindi\n        devanagari_chars = set('‡§Ö‡§Ü‡§á‡§à‡§â‡§ä‡§ã‡§è‡§ê‡§ì‡§î‡§ï‡§ñ‡§ó‡§ò‡§ô‡§ö‡§õ‡§ú‡§ù‡§û‡§ü‡§†‡§°‡§¢‡§£‡§§‡§•‡§¶‡§ß‡§®‡§™‡§´‡§¨‡§≠‡§Æ‡§Ø‡§∞‡§≤‡§µ‡§∂‡§∑‡§∏‡§π')\n        if any(char in devanagari_chars for char in text):\n            return \"hi\"\n        return \"en\"\n\nasync def twilio_websocket(websocket, path):\n    \"\"\"Handle Twilio WebSocket connections\"\"\"\n    try:\n        print(f\"WebSocket connection established: {websocket.remote_address}\")\n        \n        # Get call SID from query parameters\n        call_sid = None\n        if '?' in path:\n            params = path.split('?')[1]\n            for param in params.split('&'):\n                if param.startswith('CallSid='):\n                    call_sid = param.split('=')[1]\n                    break\n        \n        if not call_sid:\n            print(\"No CallSid provided\")\n            await websocket.close()\n            return\n        \n        # Create or get call session\n        if call_sid not in active_calls:\n            active_calls[call_sid] = RailwayCallSession(call_sid)\n        \n        session = active_calls[call_sid]\n        session.websocket = websocket\n        \n        # Send start message\n        await websocket.send(json.dumps({\n            \"event\": \"start\",\n            \"sequenceNumber\": \"1\",\n            \"start\": {\n                \"accountSid\": \"your-account-sid\",\n                \"callSid\": call_sid,\n                \"tracks\": [\"inbound\", \"outbound\"],\n                \"mediaFormat\": {\n                    \"encoding\": \"audio/x-mulaw\",\n                    \"sampleRate\": 8000,\n                    \"channels\": 1\n                },\n                \"streamSid\": \"your-stream-sid\"\n            }\n        }))\n        \n        # Handle incoming messages\n        async for message in websocket:\n            try:\n                data = json.loads(message)\n                \n                if data.get(\"event\") == \"media\":\n                    media_data = data.get(\"media\", {}).get(\"payload\", \"\")\n                    if media_data:\n                        await session.handle_audio(media_data)\n                        \n            except json.JSONDecodeError:\n                print(\"Invalid JSON received\")\n            except Exception as e:\n                print(f\"Message handling error: {e}\")\n                \n    except websockets.exceptions.ConnectionClosed:\n        print(\"WebSocket connection closed\")\n    except Exception as e:\n        print(f\"WebSocket error: {e}\")\n    finally:\n        # Clean up\n        if call_sid and call_sid in active_calls:\n            del active_calls[call_sid]\n\n# Flask app for HTTP webhooks\napp = Flask(__name__)\n\n@app.route('/health')\ndef health_check():\n    \"\"\"Health check endpoint for Railway\"\"\"\n    status = {\n        \"status\": \"healthy\", \n        \"service\": \"twilio-voice-translator\",\n        \"google_cloud_available\": GOOGLE_CLOUD_AVAILABLE,\n        \"port\": os.environ.get('PORT', 'not_set'),\n        \"timestamp\": time.time()\n    }\n    return status, 200\n\n@app.route('/')\ndef home():\n    \"\"\"Home endpoint\"\"\"\n    return {\n        \"message\": \"Twilio Voice Translator is running!\",\n        \"health_check\": \"/health\",\n        \"webhook\": \"/twilio-webhook\",\n        \"google_cloud_available\": GOOGLE_CLOUD_AVAILABLE,\n        \"version\": \"2.0-fixed\"\n    }, 200\n\n@app.route('/twilio-webhook', methods=['POST'])\ndef twilio_webhook():\n    \"\"\"Handle incoming Twilio calls\"\"\"\n    call_sid = request.form.get('CallSid')\n    from_number = request.form.get('From')\n    to_number = request.form.get('To')\n    \n    print(f\"Incoming call from {from_number} to {to_number} (CallSid: {call_sid})\")\n    \n    # Get the Railway domain from environment variable\n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-04d9f.up.railway.app')\n    if railway_domain == 'your-railway-app.railway.app':\n        # Fallback to Railway's default domain format\n        railway_domain = os.environ.get('RAILWAY_STATIC_URL', 'web-production-04d9f.up.railway.app')\n    \n    # TwiML response to start media stream\n    twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <Response>\n        <Start>\n            <Stream url=\"wss://{railway_domain}/websocket?CallSid={call_sid}\">\n                <Parameter name=\"CallSid\" value=\"{call_sid}\"/>\n            </Stream>\n        </Start>\n        <Say language=\"hi-IN\">‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡•Ä ‡§Ü‡§µ‡§æ‡§ú‡§º ‡§ï‡§æ ‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§ï‡§∞‡•Ç‡§Ç‡§ó‡§æ‡•§</Say>\n        <Say language=\"en-US\">Hello! I will translate your voice.</Say>\n        <Say language=\"hi-IN\">‡§Ö‡§¨ ‡§Ü‡§™ ‡§¨‡•ã‡§≤ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç‡•§</Say>\n        <Say language=\"en-US\">You can start speaking now.</Say>\n    </Response>\"\"\"\n    \n    return Response(twiml, mimetype='text/xml')\n\nclass StandaloneApplication(gunicorn.app.base.BaseApplication):\n    \"\"\"Gunicorn application for Railway deployment\"\"\"\n    \n    def __init__(self, app, options=None):\n        self.options = options or {}\n        self.application = app\n        super().__init__()\n    \n    def load_config(self):\n        config = {key: value for key, value in self.options.items()\n                 if key in self.cfg.settings and value is not None}\n        for key, value in config.items():\n            self.cfg.set(key.lower(), value)\n    \n    def load(self):\n        return self.application\n\ndef run_websocket_server():\n    \"\"\"Run WebSocket server in a separate thread\"\"\"\n    async def start_websocket():\n        try:\n            # Start WebSocket server on port 8080\n            server = await websockets.serve(twilio_websocket, \"0.0.0.0\", 8081)\n            print(\"WebSocket server running on port 8081\")\n            await server.wait_closed()\n        except Exception as e:\n            print(f\"WebSocket server error: {e}\")\n    \n    # Run WebSocket server in a separate thread\n    def run_in_thread():\n        asyncio.set_event_loop(asyncio.new_event_loop())\n        asyncio.get_event_loop().run_until_complete(start_websocket())\n    \n    websocket_thread = threading.Thread(target=run_in_thread, daemon=True)\n    websocket_thread.start()\n    print(\"WebSocket server thread started\")\n\nif __name__ == \"__main__\":\n    try:\n        # Get port from Railway environment variable\n        port = int(os.environ.get('PORT', 3000))\n        print(f\"Starting Railway deployment on port {port}\")\n        print(\"=\"*70)\n        print(\"RAILWAY TWILIO VOICE TRANSLATOR - FIXED VERSION\")\n        print(\"=\"*70)\n        print(\"Features:\")\n        print(\"‚úì Real-time Hindi ‚Üî English translation\")\n        print(\"‚úì Railway cloud deployment\")\n        print(\"‚úì Separate ports for Flask and WebSocket\")\n        print(\"‚úì Health check endpoint\")\n        print(\"‚úì Gunicorn WSGI server\")\n        print(f\"‚úì Google Cloud available: {GOOGLE_CLOUD_AVAILABLE}\")\n        print(f\"‚úì Port: {port}\")\n        print(\"=\"*70)\n        \n        if not GOOGLE_CLOUD_AVAILABLE:\n            print(\"WARNING: Google Cloud libraries not available!\")\n            print(\"Please check your GOOGLE_APPLICATION_CREDENTIALS environment variable\")\n        \n        # Start WebSocket server in background\n        run_websocket_server()\n        \n        # Start Flask app with Gunicorn\n        options = {\n            'bind': f'0.0.0.0:{port}',\n            'workers': 1,\n            'worker_class': 'sync',\n            'worker_connections': 1000,\n            'timeout': 30,\n            'keepalive': 2,\n            'max_requests': 1000,\n            'max_requests_jitter': 100,\n            'preload_app': True,\n        }\n        \n        StandaloneApplication(app, options).run()\n        \n    except KeyboardInterrupt:\n        print(\"Server stopped by user.\")\n    except Exception as e:\n        print(f\"Server startup error: {e}\")\n        import traceback\n        traceback.print_exc()\n","size_bytes":15990},"tts_app.py":{"content":"import os\nimport pyaudio\nimport wave\nfrom google.cloud import speech\nfrom google.cloud import texttospeech\nfrom google.cloud import translate_v2 as translate\n\n# Set Google Cloud credentials\nos.environ[\"GOOGLE_APPLICATION_CREDENTIALS\"] = \"google-credentials.json\"\n\n# Step 1: Speech-to-Text (English)\ndef transcribe_speech():\n    try:\n        client = speech.SpeechClient()\n        \n        # Record audio for 5 seconds (adjustable)\n        FORMAT = pyaudio.paInt16\n        CHANNELS = 1\n        RATE = 16000\n        CHUNK = 1024\n        RECORD_SECONDS = 5\n        WAVE_OUTPUT_FILENAME = \"input.wav\"\n\n        audio = pyaudio.PyAudio()\n        stream = audio.open(format=FORMAT, channels=CHANNELS, rate=RATE, input=True, frames_per_buffer=CHUNK)\n        print(f\"Recording English speech for {RECORD_SECONDS} seconds...\")\n        frames = []\n        \n        for _ in range(0, int(RATE / CHUNK * RECORD_SECONDS)):\n            data = stream.read(CHUNK, exception_on_overflow=False)\n            frames.append(data)\n        \n        print(\"Recording complete.\")\n        stream.stop_stream()\n        stream.close()\n        audio.terminate()\n\n        # Save audio to temporary WAV file\n        wf = wave.open(WAVE_OUTPUT_FILENAME, 'wb')\n        wf.setnchannels(CHANNELS)\n        wf.setsampwidth(audio.get_sample_size(FORMAT))\n        wf.setframerate(RATE)\n        wf.writeframes(b''.join(frames))\n        wf.close()\n\n        # Transcribe audio\n        with open(WAVE_OUTPUT_FILENAME, 'rb') as audio_file:\n            content = audio_file.read()\n\n        audio = speech.RecognitionAudio(content=content)\n        config = speech.RecognitionConfig(\n            encoding=speech.RecognitionConfig.AudioEncoding.LINEAR16,\n            sample_rate_hertz=RATE,\n            language_code=\"en-US\"\n        )\n\n        response = client.recognize(config=config, audio=audio)\n        english_text = \"\"\n        for result in response.results:\n            english_text += result.alternatives[0].transcript\n        if not english_text:\n            print(\"No speech detected.\")\n            return None\n        print(\"English Text:\", english_text)\n        \n        # Clean up temporary WAV file\n        os.remove(WAVE_OUTPUT_FILENAME)\n        return english_text\n    except Exception as e:\n        print(f\"Speech-to-Text error: {e}\")\n        return None\n\n# Step 2: Translate English to Hindi\ndef translate_text(english_text):\n    try:\n        client = translate.Client()\n        result = client.translate(english_text, source_language='en', target_language='hi')\n        hindi_text = result['translatedText']\n        print(\"Hindi Text:\", hindi_text)\n        return hindi_text\n    except Exception as e:\n        print(f\"Translation error: {e}\")\n        return None\n\n# Step 3: Text-to-Speech (Hindi) - Play directly without saving\ndef synthesize_speech(hindi_text):\n    try:\n        client = texttospeech.TextToSpeechClient()\n        \n        synthesis_input = texttospeech.SynthesisInput(text=hindi_text)\n        voice = texttospeech.VoiceSelectionParams(\n            language_code=\"hi-IN\",\n            name=\"hi-IN-Standard-A\"  # Hindi female voice\n        )\n        audio_config = texttospeech.AudioConfig(\n            audio_encoding=texttospeech.AudioEncoding.LINEAR16,  # Raw PCM for direct playback\n            sample_rate_hertz=16000\n        )\n\n        response = client.synthesize_speech(\n            input=synthesis_input, voice=voice, audio_config=audio_config\n        )\n\n        # Play audio directly using PyAudio\n        p = pyaudio.PyAudio()\n        stream = p.open(format=pyaudio.paInt16,\n                        channels=1,\n                        rate=16000,\n                        output=True)\n        print(\"Playing Hindi speech...\")\n        stream.write(response.audio_content)\n        stream.stop_stream()\n        stream.close()\n        p.terminate()\n        print(\"Hindi speech played.\")\n    except Exception as e:\n        print(f\"Text-to-Speech error: {e}\")\n\n# Main function\ndef main():\n    try:\n        # Verify credentials file\n        if not os.path.exists(\"google-credentials.json\"):\n            print(\"Error: google-credentials.json not found in the current directory.\")\n            return False\n\n        # Step 1: Convert speech to text\n        english_text = transcribe_speech()\n        if not english_text:\n            return True  # Continue loop even if no speech detected\n\n        # Step 2: Translate to Hindi\n        hindi_text = translate_text(english_text)\n        if not hindi_text:\n            return True  # Continue loop on translation error\n\n        # Step 3: Convert Hindi text to speech and play directly\n        synthesize_speech(hindi_text)\n        return True\n\n    except Exception as e:\n        print(f\"Main error: {e}\")\n        return True  # Continue loop on general error\n\n# Run continuously until aborted\nif __name__ == \"__main__\":\n    print(\"Starting program. Press Ctrl+C to abort.\")\n    try:\n        while True:\n            if not main():\n                break  # Exit if credentials file is missing\n            print(\"\\nReady for next recording. Press Ctrl+C to stop.\")\n    except KeyboardInterrupt:\n        print(\"\\nProgram aborted by user.\")\n    except Exception as e:\n        print(f\"Unexpected error: {e}\")","size_bytes":5234},"watch_logs.sh":{"content":"#!/bin/bash\necho \"üîç Watching Railway logs for your Twilio Voice Translator...\"\necho \"üìû Make a call to your Twilio number to see the logs!\"\necho \"Press Ctrl+C to stop watching\"\necho \"==================================================\"\n\nwhile true; do\n    echo \"üîÑ Checking for new logs...\"\n    railway logs | tail -20\n    echo \"==================================================\"\n    sleep 5\ndone\n","size_bytes":404},"optimized_twilio_translator.py":{"content":"import os\nimport asyncio\nimport json\nimport base64\nimport queue\nimport threading\nimport time\nimport struct\nfrom collections import deque\nfrom flask import Flask, request, Response\nimport websockets\nfrom google.cloud import speech\nfrom google.cloud import texttospeech\nfrom google.cloud import translate_v2 as translate\n\n# Set Google Cloud credentials\nos.environ[\"GOOGLE_APPLICATION_CREDENTIALS\"] = \"/Users/apple/text_to_voice_translator/google-credentials.json\"\n\n# Global variables for managing call state\nactive_calls = {}\n\nclass OptimizedCallSession:\n    def __init__(self, call_sid, stream_sid):\n        self.call_sid = call_sid\n        self.stream_sid = stream_sid\n        self.last_processed_transcript = \"\"\n        self.file_counter = 0\n        self.audio_queue = queue.Queue()\n        self.voice_activity_buffer = deque(maxlen=15)  # Smaller buffer for faster response\n        self.silence_frames = 0\n        self.speaking_frames = 0\n        self.current_speaker = None\n        self.language_detection_buffer = deque(maxlen=3)  # Smaller buffer\n        self.last_translation_time = 0\n        self.is_processing = False\n        self.translation_lock = threading.Lock()\n\nclass FastVoiceActivityDetector:\n    def __init__(self, threshold=0.008, silence_threshold=8):  # Lower thresholds for faster detection\n        self.threshold = threshold\n        self.silence_threshold = silence_threshold\n        self.voice_buffer = deque(maxlen=15)  # Smaller buffer\n        self.is_speaking = False\n        self.silence_count = 0\n        self.speech_start_time = 0\n        \n    def detect_voice(self, audio_data):\n        \"\"\"Optimized voice activity detection for lower latency\"\"\"\n        try:\n            audio_bytes = base64.b64decode(audio_data)\n            if len(audio_bytes) < 2:\n                return False\n            \n            # Fast RMS calculation\n            samples = struct.unpack('<' + 'h' * (len(audio_bytes) // 2), audio_bytes)\n            rms = (sum(x * x for x in samples) / len(samples)) ** 0.5\n            \n            self.voice_buffer.append(rms)\n            current_voice = rms > self.threshold\n            \n            if current_voice:\n                self.silence_count = 0\n                if not self.is_speaking:\n                    self.is_speaking = True\n                    self.speech_start_time = time.time()\n                    return True  # Voice started\n            else:\n                self.silence_count += 1\n                if self.is_speaking and self.silence_count > self.silence_threshold:\n                    self.is_speaking = False\n                    return False  # Voice ended\n            \n            return self.is_speaking\n            \n        except Exception as e:\n            print(f\"Voice activity detection error: {e}\")\n            return False\n\nclass FastLanguageDetector:\n    def __init__(self):\n        self.transcript_buffer = deque(maxlen=2)  # Smaller buffer\n        self.confidence_threshold = 0.5  # Lower threshold for faster detection\n        \n    def detect_language(self, transcript, confidence):\n        \"\"\"Fast language detection\"\"\"\n        if confidence < self.confidence_threshold:\n            return None\n            \n        self.transcript_buffer.append((transcript, confidence))\n        \n        # Fast Hindi character detection\n        hindi_chars = set('‡§Ö‡§Ü‡§á‡§à‡§â‡§ä‡§ã‡§è‡§ê‡§ì‡§î‡§ï‡§ñ‡§ó‡§ò‡§ô‡§ö‡§õ‡§ú‡§ù‡§û‡§ü‡§†‡§°‡§¢‡§£‡§§‡§•‡§¶‡§ß‡§®‡§™‡§´‡§¨‡§≠‡§Æ‡§Ø‡§∞‡§≤‡§µ‡§∂‡§∑‡§∏‡§π')\n        \n        if any(char in hindi_chars for char in transcript):\n            return 'hi-IN'\n        \n        # Fast English word detection (smaller set)\n        english_words = {'the', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'is', 'are', 'was', 'were', 'be', 'been', 'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could', 'should', 'may', 'might', 'can', 'this', 'that', 'i', 'you', 'he', 'she', 'it', 'we', 'they'}\n        \n        words = transcript.lower().split()\n        english_word_count = sum(1 for word in words if word in english_words)\n        \n        if english_word_count > len(words) * 0.2:  # 20% English words\n            return 'en-US'\n        \n        return None\n\n# Optimized translation functions with caching\ntranslation_cache = {}\nCACHE_SIZE = 100\n\ndef translate_hindi_to_english(hindi_text):\n    \"\"\"Translate Hindi text to English with caching\"\"\"\n    if hindi_text in translation_cache:\n        return translation_cache[hindi_text]\n    \n    try:\n        client = translate.Client()\n        result = client.translate(hindi_text, source_language='hi', target_language='en')\n        english_text = result['translatedText']\n        \n        # Cache the result\n        if len(translation_cache) < CACHE_SIZE:\n            translation_cache[hindi_text] = english_text\n        \n        print(f\"Hindi ‚Üí English: {hindi_text} ‚Üí {english_text}\")\n        return english_text\n    except Exception as e:\n        print(f\"Hindi to English translation error: {e}\")\n        return None\n\ndef translate_english_to_hindi(english_text):\n    \"\"\"Translate English text to Hindi with caching\"\"\"\n    if english_text in translation_cache:\n        return translation_cache[english_text]\n    \n    try:\n        client = translate.Client()\n        result = client.translate(english_text, source_language='en', target_language='hi')\n        hindi_text = result['translatedText']\n        \n        # Cache the result\n        if len(translation_cache) < CACHE_SIZE:\n            translation_cache[english_text] = hindi_text\n        \n        print(f\"English ‚Üí Hindi: {english_text} ‚Üí {hindi_text}\")\n        return hindi_text\n    except Exception as e:\n        print(f\"English to Hindi translation error: {e}\")\n        return None\n\n# Optimized TTS functions\ndef synthesize_english_speech(english_text, file_counter):\n    \"\"\"Convert English text to speech with optimized settings\"\"\"\n    try:\n        client = texttospeech.TextToSpeechClient()\n        synthesis_input = texttospeech.SynthesisInput(text=english_text)\n        voice = texttospeech.VoiceSelectionParams(\n            language_code=\"en-US\", \n            name=\"en-US-Standard-A\"\n        )\n        # Optimized audio config for faster processing\n        audio_config = texttospeech.AudioConfig(\n            audio_encoding=texttospeech.AudioEncoding.MULAW, \n            sample_rate_hertz=8000,\n            speaking_rate=1.1  # Slightly faster speech\n        )\n\n        response = client.synthesize_speech(\n            input=synthesis_input, \n            voice=voice, \n            audio_config=audio_config\n        )\n        \n        # Save for debugging (optional)\n        if file_counter % 5 == 0:  # Save every 5th file to reduce I/O\n            audio_file_name = f\"/Users/apple/text_to_voice_translator/english_output_{file_counter}.wav\"\n            with open(audio_file_name, \"wb\") as audio_file:\n                audio_file.write(response.audio_content)\n\n        return response.audio_content\n    except Exception as e:\n        print(f\"English Text-to-Speech error: {e}\")\n        return None\n\ndef synthesize_hindi_speech(hindi_text, file_counter):\n    \"\"\"Convert Hindi text to speech with optimized settings\"\"\"\n    try:\n        client = texttospeech.TextToSpeechClient()\n        synthesis_input = texttospeech.SynthesisInput(text=hindi_text)\n        voice = texttospeech.VoiceSelectionParams(\n            language_code=\"hi-IN\", \n            name=\"hi-IN-Standard-A\"\n        )\n        # Optimized audio config for faster processing\n        audio_config = texttospeech.AudioConfig(\n            audio_encoding=texttospeech.AudioEncoding.MULAW, \n            sample_rate_hertz=8000,\n            speaking_rate=1.1  # Slightly faster speech\n        )\n\n        response = client.synthesize_speech(\n            input=synthesis_input, \n            voice=voice, \n            audio_config=audio_config\n        )\n        \n        # Save for debugging (optional)\n        if file_counter % 5 == 0:  # Save every 5th file to reduce I/O\n            audio_file_name = f\"/Users/apple/text_to_voice_translator/hindi_output_{file_counter}.wav\"\n            with open(audio_file_name, \"wb\") as audio_file:\n                audio_file.write(response.audio_content)\n\n        return response.audio_content\n    except Exception as e:\n        print(f\"Hindi Text-to-Speech error: {e}\")\n        return None\n\n# WebSocket handler for Twilio media stream\nasync def twilio_websocket(websocket, path):\n    print(\"New WebSocket connection established\")\n    \n    # Initialize components\n    speech_client = speech.SpeechClient()\n    vad = FastVoiceActivityDetector()\n    lang_detector = FastLanguageDetector()\n    \n    # Optimized speech recognition configurations\n    hindi_config = speech.RecognitionConfig(\n        encoding=speech.RecognitionConfig.AudioEncoding.MULAW,\n        sample_rate_hertz=8000,\n        language_code=\"hi-IN\",\n        enable_automatic_punctuation=True,\n        model=\"latest_short\",  # Use short model for faster processing\n        use_enhanced=True\n    )\n    \n    english_config = speech.RecognitionConfig(\n        encoding=speech.RecognitionConfig.AudioEncoding.MULAW,\n        sample_rate_hertz=8000,\n        language_code=\"en-US\",\n        enable_automatic_punctuation=True,\n        model=\"latest_short\",  # Use short model for faster processing\n        use_enhanced=True\n    )\n    \n    # Call session variables\n    call_session = None\n    current_language = 'hi-IN'  # Start with Hindi detection\n    last_processed_transcript = \"\"\n    file_counter = 0\n    stream_sid = None\n    min_translation_interval = 1.5  # Reduced from 2.0 seconds\n\n    async def stream_audio_to_speech():\n        nonlocal stream_sid, call_session, current_language, last_processed_transcript\n        nonlocal file_counter\n        \n        async for message in websocket:\n            try:\n                data = json.loads(message)\n                \n                if data['event'] == 'media':\n                    stream_sid = data['streamSid']\n                    audio_payload = data['media']['payload']\n                    \n                    # Fast voice activity detection\n                    voice_detected = vad.detect_voice(audio_payload)\n                    \n                    if voice_detected:\n                        # Someone is speaking, send audio for recognition\n                        audio = base64.b64decode(audio_payload)\n                        yield speech.StreamingRecognizeRequest(audio_content=audio)\n                    \n                elif data['event'] == 'start':\n                    print(f\"Stream started: {data['streamSid']}\")\n                    stream_sid = data['streamSid']\n                    call_session = OptimizedCallSession(data.get('callSid', 'unknown'), stream_sid)\n                    active_calls[stream_sid] = call_session\n                    \n                elif data['event'] == 'stop':\n                    print(\"Stream stopped\")\n                    if stream_sid in active_calls:\n                        del active_calls[stream_sid]\n                    break\n                    \n            except json.JSONDecodeError as e:\n                print(f\"JSON decode error: {e}\")\n                continue\n            except Exception as e:\n                print(f\"WebSocket message error: {e}\")\n                continue\n\n    try:\n        # Start with Hindi recognition\n        streaming_config = speech.StreamingRecognitionConfig(\n            config=hindi_config, \n            interim_results=True\n        )\n        \n        responses = speech_client.streaming_recognize(streaming_config, stream_audio_to_speech())\n        \n        async for response in responses:\n            if not response.results or not response.results[0].alternatives:\n                continue\n                \n            transcript = response.results[0].alternatives[0].transcript\n            confidence = response.results[0].alternatives[0].confidence\n            \n            # Process final results with good confidence\n            if (response.results[0].is_final and \n                transcript.strip() and \n                transcript != last_processed_transcript and\n                confidence > 0.5):  # Lower confidence threshold for faster processing\n                \n                current_time = time.time()\n                \n                # Rate limiting to prevent too frequent translations\n                if current_time - call_session.last_translation_time < min_translation_interval:\n                    continue\n                \n                # Thread-safe processing\n                with call_session.translation_lock:\n                    if call_session.is_processing:\n                        continue\n                    call_session.is_processing = True\n                \n                call_session.last_translation_time = current_time\n                \n                print(f\"Final transcript ({current_language}): {transcript} (confidence: {confidence:.2f})\")\n                last_processed_transcript = transcript\n                \n                # Fast language detection\n                detected_lang = lang_detector.detect_language(transcript, confidence)\n                if detected_lang:\n                    current_language = detected_lang\n                    print(f\"Language detected: {current_language}\")\n                \n                # Translate and synthesize based on detected language\n                if current_language == 'hi-IN':\n                    # Hindi speaker ‚Üí translate to English ‚Üí synthesize English\n                    english_text = translate_hindi_to_english(transcript)\n                    if english_text:\n                        file_counter += 1\n                        audio_content = synthesize_english_speech(english_text, file_counter)\n                        if audio_content and stream_sid:\n                            await websocket.send(json.dumps({\n                                'event': 'media',\n                                'streamSid': stream_sid,\n                                'media': {'payload': base64.b64encode(audio_content).decode('utf-8')}\n                            }))\n                            print(f\"Sent English translation: {english_text}\")\n                            \n                elif current_language == 'en-US':\n                    # English speaker ‚Üí translate to Hindi ‚Üí synthesize Hindi\n                    hindi_text = translate_english_to_hindi(transcript)\n                    if hindi_text:\n                        file_counter += 1\n                        audio_content = synthesize_hindi_speech(hindi_text, file_counter)\n                        if audio_content and stream_sid:\n                            await websocket.send(json.dumps({\n                                'event': 'media',\n                                'streamSid': stream_sid,\n                                'media': {'payload': base64.b64encode(audio_content).decode('utf-8')}\n                            }))\n                            print(f\"Sent Hindi translation: {hindi_text}\")\n                \n                # Switch language for next detection\n                current_language = 'en-US' if current_language == 'hi-IN' else 'hi-IN'\n                \n                # Update streaming config for next language\n                if current_language == 'hi-IN':\n                    streaming_config = speech.StreamingRecognitionConfig(\n                        config=hindi_config, \n                        interim_results=True\n                    )\n                else:\n                    streaming_config = speech.StreamingRecognitionConfig(\n                        config=english_config, \n                        interim_results=True\n                    )\n                \n                call_session.is_processing = False\n                \n    except Exception as e:\n        print(f\"Streaming error: {e}\")\n    finally:\n        try:\n            await websocket.close()\n        except Exception as e:\n            print(f\"WebSocket close error: {e}\")\n\n# Flask app for HTTP webhooks\napp = Flask(__name__)\n\n@app.route('/twilio-webhook', methods=['POST'])\ndef twilio_webhook():\n    \"\"\"Handle incoming Twilio calls\"\"\"\n    call_sid = request.form.get('CallSid')\n    from_number = request.form.get('From')\n    to_number = request.form.get('To')\n    \n    print(f\"Incoming call from {from_number} to {to_number} (CallSid: {call_sid})\")\n    \n    # Optimized TwiML response\n    twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <Response>\n        <Start>\n            <Stream url=\"wss://YOUR_NGROK_URL.ngrok-free.app/websocket\" />\n        </Start>\n        <Say language=\"hi-IN\">‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§∏‡•á‡§µ‡§æ ‡§§‡•à‡§Ø‡§æ‡§∞ ‡§π‡•à‡•§</Say>\n        <Say language=\"en-US\">Hello! Translation service is ready.</Say>\n        <Pause length=\"1\"/>\n    </Response>\"\"\"\n    \n    return Response(twiml, mimetype='text/xml')\n\n@app.route('/call-status', methods=['POST'])\ndef call_status():\n    \"\"\"Handle call status updates\"\"\"\n    call_sid = request.form.get('CallSid')\n    call_status = request.form.get('CallStatus')\n    \n    print(f\"Call {call_sid} status: {call_status}\")\n    \n    if call_status == 'completed':\n        # Clean up call session\n        for stream_sid, session in list(active_calls.items()):\n            if session.call_sid == call_sid:\n                del active_calls[stream_sid]\n                break\n    \n    return Response('OK', mimetype='text/plain')\n\n# Start servers\nasync def start_servers():\n    if not os.path.exists(\"/Users/apple/text_to_voice_translator/google-credentials.json\"):\n        print(\"Error: google-credentials.json not found.\")\n        return\n\n    # Start Flask in a separate thread\n    def run_flask():\n        app.run(host='0.0.0.0', port=3000, debug=False, use_reloader=False)\n    \n    flask_thread = threading.Thread(target=run_flask, daemon=True)\n    flask_thread.start()\n    print(\"Flask server running on port 3000\")\n\n    # Start WebSocket server\n    try:\n        start_server = websockets.serve(twilio_websocket, '0.0.0.0', 8080)\n        await start_server\n        print(\"WebSocket server running on port 8080\")\n        print(\"\\n\" + \"=\"*70)\n        print(\"OPTIMIZED BIDIRECTIONAL VOICE TRANSLATION SYSTEM READY\")\n        print(\"=\"*70)\n        print(\"Optimizations:\")\n        print(\"‚úì Reduced latency with faster voice detection\")\n        print(\"‚úì Translation caching for common phrases\")\n        print(\"‚úì Optimized audio processing\")\n        print(\"‚úì Faster speech recognition models\")\n        print(\"‚úì Reduced I/O operations\")\n        print(\"‚úì Thread-safe processing\")\n        print(\"\\nSetup Instructions:\")\n        print(\"1. Update the ngrok URL in the TwiML response\")\n        print(\"2. Configure your Twilio phone number webhook to:\")\n        print(\"   http://YOUR_NGROK_URL.ngrok-free.app/twilio-webhook\")\n        print(\"3. Make a call to your Twilio number\")\n        print(\"4. Enjoy fast, real-time translation!\")\n        print(\"=\"*70)\n    except Exception as e:\n        print(f\"WebSocket server error: {e}\")\n\nif __name__ == \"__main__\":\n    try:\n        asyncio.get_event_loop().run_until_complete(start_servers())\n        asyncio.get_event_loop().run_forever()\n    except KeyboardInterrupt:\n        print(\"Server stopped by user.\")\n    except Exception as e:\n        print(f\"Server startup error: {e}\")\n","size_bytes":19345},"app.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nRailway Deployment - ULTRA SIMPLE Voice Translator\nFIXED: Ultra simple approach that will definitely work\n\"\"\"\n\nimport os\nimport json\nfrom flask import Flask, request, Response\n\n# Set up Google Cloud credentials\ndef setup_google_credentials():\n    try:\n        # Try local credentials file first\n        if os.path.exists('google-credentials.json'):\n            os.environ['GOOGLE_APPLICATION_CREDENTIALS'] = 'google-credentials.json'\n            print(\"‚úÖ Google credentials set up from local file\")\n            return True\n        \n        # Try environment variable\n        creds_json = os.environ.get('GOOGLE_CREDENTIALS_JSON')\n        if creds_json:\n            creds_data = json.loads(creds_json)\n            temp_creds_path = '/tmp/google-credentials.json'\n            with open(temp_creds_path, 'w') as f:\n                json.dump(creds_data, f)\n            os.environ['GOOGLE_APPLICATION_CREDENTIALS'] = temp_creds_path\n            print(\"‚úÖ Google credentials set up from environment\")\n            return True\n        return False\n    except Exception as e:\n        print(f\"‚ùå Credentials error: {e}\")\n        return False\n\ncredentials_setup = setup_google_credentials()\n\n# Import Google Cloud\ntry:\n    from google.cloud import translate_v2 as translate\n    from google.cloud import texttospeech\n    import base64\n    GOOGLE_CLOUD_AVAILABLE = True\n    print(\"‚úÖ Google Cloud available\")\nexcept ImportError:\n    GOOGLE_CLOUD_AVAILABLE = False\n    print(\"‚ùå Google Cloud not available\")\n\napp = Flask(__name__)\n\n@app.route('/health')\ndef health_check():\n    return {\n        \"status\": \"healthy\",\n        \"version\": \"34.0-google-translate\"\n    }, 200\n\n@app.route('/')\ndef home():\n    return {\n        \"message\": \"ULTRA SIMPLE Twilio Voice Translator\",\n        \"webhook\": \"/twilio-webhook\",\n        \"version\": \"34.0-google-translate\",\n        \"status\": \"WORKING - Direct translation without repetition\"\n    }, 200\n\n@app.route('/debug')\ndef debug():\n    return {\n        \"message\": \"DEBUG: ULTRA SIMPLE - This is the NEW version\",\n        \"version\": \"34.0-google-translate\",\n        \"features\": [\n            \"Direct translation without 'You said'\",\n            \"No 'Translation:' word\",\n            \"Ultra simple Flask app\",\n            \"Google Translate API\",\n            \"Twilio built-in voice\"\n        ]\n    }, 200\n\n@app.route('/twilio-webhook', methods=['POST'])\ndef twilio_webhook():\n    call_sid = request.form.get('CallSid')\n    from_number = request.form.get('From')\n    \n    print(f\"\\nüìû CALL FROM: {from_number}\")\n    print(f\"   CallSid: {call_sid}\")\n    print(\"=\"*40)\n    \n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', '6bd7877720ac.ngrok-free.app')\n    \n    # ULTRA SIMPLE: Basic approach\n    twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <Response>\n        <Say voice=\"alice\" language=\"en-US\">Hello! Speak in English or Hindi for translation.</Say>\n        <Pause length=\"2\"/>\n        <Gather \n            action=\"https://{railway_domain}/gather-webhook\" \n            method=\"POST\"\n            input=\"speech\"\n            speechTimeout=\"auto\"\n            timeout=\"30\"\n            language=\"en-US\"\n        />\n        <Say voice=\"alice\" language=\"en-US\">I didn't hear anything. Please try again.</Say>\n        <Pause length=\"2\"/>\n        <Gather \n            action=\"https://{railway_domain}/gather-webhook\" \n            method=\"POST\"\n            input=\"speech\"\n            speechTimeout=\"auto\"\n            timeout=\"30\"\n            language=\"en-US\"\n        />\n        <Say voice=\"alice\" language=\"en-US\">Thank you. Goodbye.</Say>\n    </Response>\"\"\"\n    \n    return Response(twiml, mimetype='text/xml')\n\n@app.route('/gather-webhook', methods=['POST'])\ndef gather_webhook():\n    call_sid = request.form.get('CallSid')\n    speech_result = request.form.get('SpeechResult', '')\n    confidence = request.form.get('Confidence', '0')\n    \n    print(f\"\\nüé§ GATHER WEBHOOK:\")\n    print(f\"   CallSid: {call_sid}\")\n    print(f\"   Speech Result: '{speech_result}'\")\n    print(f\"   Confidence: {confidence}\")\n    print(\"=\"*40)\n    \n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', '6bd7877720ac.ngrok-free.app')\n    \n    if not speech_result or len(speech_result.strip()) < 2:\n        print(\"‚ùå No speech result - fallback response\")\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"en-US\">I didn't hear anything. Please speak clearly.</Say>\n            <Pause length=\"2\"/>\n            <Gather \n                action=\"https://{railway_domain}/gather-webhook\" \n                method=\"POST\"\n                input=\"speech\"\n                speechTimeout=\"auto\"\n                timeout=\"30\"\n                language=\"en-US\"\n            />\n            <Say voice=\"alice\" language=\"en-US\">Thank you. Goodbye.</Say>\n        </Response>\"\"\"\n        return Response(twiml, mimetype='text/xml')\n    \n    try:\n        # ULTRA SIMPLE: Basic language detection\n        devanagari_chars = set('‡§Ö‡§Ü‡§á‡§à‡§â‡§ä‡§ã‡§è‡§ê‡§ì‡§î‡§ï‡§ñ‡§ó‡§ò‡§ô‡§ö‡§õ‡§ú‡§ù‡§û‡§ü‡§†‡§°‡§¢‡§£‡§§‡§•‡§¶‡§ß‡§®‡§™‡§´‡§¨‡§≠‡§Æ‡§Ø‡§∞‡§≤‡§µ‡§∂‡§∑‡§∏‡§π')\n        is_hindi = any(char in devanagari_chars for char in speech_result)\n        \n        # Check for common Hindi words in English script (exact word match)\n        hindi_words = ['namaste', 'kaise', 'ho', 'dhanyawad', 'alvida', 'theek', 'hun', 'aap', 'kahan', 'se', 'ghar', 'ja', 'raha']\n        speech_words = speech_result.lower().split()\n        has_hindi_words = any(word in speech_words for word in hindi_words)\n        \n        if is_hindi or has_hindi_words:\n            # Hindi to English - REAL TRANSLATION\n            translated_text = translate_text(speech_result, 'hi', 'en')\n            print(f\"üîÑ Hindi ‚Üí English: '{translated_text}'\")\n            \n            twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n            <Response>\n                <Say voice=\"alice\" language=\"en-US\">{translated_text}</Say>\n                <Pause length=\"3\"/>\n                <Say voice=\"alice\" language=\"en-US\">Say something else or goodbye.</Say>\n                <Gather \n                    action=\"https://{railway_domain}/gather-webhook\" \n                    method=\"POST\"\n                    input=\"speech\"\n                    speechTimeout=\"auto\"\n                    timeout=\"30\"\n                    language=\"en-US\"\n                />\n                <Say voice=\"alice\" language=\"en-US\">Thank you. Goodbye.</Say>\n            </Response>\"\"\"\n        else:\n            # English to Hindi - REAL TRANSLATION\n            translated_text = translate_text(speech_result, 'en', 'hi')\n            print(f\"üîÑ English ‚Üí Hindi: '{translated_text}'\")\n            \n            # Use English voice for Hindi text (Twilio Hindi voice doesn't work)\n            print(f\"üîä Using English voice for Hindi text\")\n            twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n            <Response>\n                <Say voice=\"alice\" language=\"en-US\">{translated_text}</Say>\n                <Pause length=\"3\"/>\n                <Say voice=\"alice\" language=\"en-US\">Say something else or goodbye.</Say>\n                <Gather \n                    action=\"https://{railway_domain}/gather-webhook\" \n                    method=\"POST\"\n                    input=\"speech\"\n                    speechTimeout=\"auto\"\n                    timeout=\"30\"\n                    language=\"en-US\"\n                />\n                <Say voice=\"alice\" language=\"en-US\">Thank you. Goodbye.</Say>\n            </Response>\"\"\"\n        \n        print(f\"üîä SPEAKING: Translation: {translated_text}\")\n        print(\"=\"*40)\n        \n        return Response(twiml, mimetype='text/xml')\n        \n    except Exception as e:\n        print(f\"‚ùå Translation error: {e}\")\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"en-US\">Translation error. Please try again.</Say>\n            <Pause length=\"2\"/>\n            <Gather \n                action=\"https://{railway_domain}/gather-webhook\" \n                method=\"POST\"\n                input=\"speech\"\n                speechTimeout=\"auto\"\n                timeout=\"30\"\n                language=\"en-US\"\n            />\n            <Say voice=\"alice\" language=\"en-US\">Thank you. Goodbye.</Say>\n        </Response>\"\"\"\n        return Response(twiml, mimetype='text/xml')\n\ndef generate_google_tts_audio(text, language_code):\n    try:\n        if not GOOGLE_CLOUD_AVAILABLE:\n            return None\n        \n        client = texttospeech.TextToSpeechClient()\n        synthesis_input = texttospeech.SynthesisInput(text=text)\n        \n        if language_code == 'hi':\n            voice = texttospeech.VoiceSelectionParams(\n                language_code=\"hi-IN\",\n                name=\"hi-IN-Standard-A\",\n                ssml_gender=texttospeech.SsmlVoiceGender.FEMALE\n            )\n        else:  # en\n            voice = texttospeech.VoiceSelectionParams(\n                language_code=\"en-US\",\n                name=\"en-US-Standard-C\",\n                ssml_gender=texttospeech.SsmlVoiceGender.FEMALE\n            )\n        \n        audio_config = texttospeech.AudioConfig(\n            audio_encoding=texttospeech.AudioEncoding.MP3,\n            sample_rate_hertz=22050\n        )\n        \n        response = client.synthesize_speech(\n            input=synthesis_input,\n            voice=voice,\n            audio_config=audio_config\n        )\n        \n        # Convert to base64 data URL\n        audio_b64 = base64.b64encode(response.audio_content).decode('utf-8')\n        return f\"data:audio/mp3;base64,{audio_b64}\"\n        \n    except Exception as e:\n        print(f\"‚ùå Google TTS error: {e}\")\n        return None\n\ndef translate_text(text, source_lang, target_lang):\n    try:\n        if not GOOGLE_CLOUD_AVAILABLE:\n            # Fallback translations\n            if source_lang == 'hi' and target_lang == 'en':\n                return \"Hello, how are you?\"\n            elif source_lang == 'en' and target_lang == 'hi':\n                return \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á, ‡§Ü‡§™ ‡§ï‡•à‡§∏‡•á ‡§π‡•à‡§Ç?\"\n            return text\n        \n        print(f\"üîÑ Calling Google Translate API...\")\n        print(f\"   Source: {source_lang}\")\n        print(f\"   Target: {target_lang}\")\n        print(f\"   Text: '{text}'\")\n        \n        client = translate.Client()\n        \n        result = client.translate(\n            text, \n            source_language=source_lang, \n            target_language=target_lang,\n            format_='text'\n        )\n        \n        translated_text = result['translatedText']\n        print(f\"‚úÖ Translation successful: '{translated_text}'\")\n        \n        return translated_text.strip()\n        \n    except Exception as e:\n        print(f\"‚ùå Translation error: {e}\")\n        # Fallback translations\n        if source_lang == 'hi' and target_lang == 'en':\n            return \"Hello, how are you?\"\n        elif source_lang == 'en' and target_lang == 'hi':\n            return \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á, ‡§Ü‡§™ ‡§ï‡•à‡§∏‡•á ‡§π‡•à‡§Ç?\"\n        return text\n\nif __name__ == \"__main__\":\n    port = int(os.environ.get('PORT', 3000))\n    print(f\"üöÄ ULTRA SIMPLE TRANSLATOR on port {port}\")\n    print(\"=\"*50)\n    print(\"‚úÖ Features:\")\n    print(\"   ‚úì Ultra simple Flask app\")\n    print(\"   ‚úì Direct translation without repetition\")\n    print(\"   ‚úì Hindi ‚Üî English translation\")\n    print(\"   ‚úì Will definitely work\")\n    print(\"=\"*50)\n    \n    # Ultra simple Flask run for Railway\n    app.run(host='0.0.0.0', port=port, debug=False)","size_bytes":11583},"railway_simple_working.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nRailway Deployment - SIMPLE WORKING Voice Translator\nFIXED: Direct translation without repeating input\n\"\"\"\n\nimport os\nimport json\nimport time\nimport warnings\nimport requests\nfrom flask import Flask, request, Response\nimport gunicorn.app.base\n\n# Suppress warnings\nwarnings.filterwarnings(\"ignore\")\n\n# Set up Google Cloud credentials\ndef setup_google_credentials():\n    try:\n        creds_json = os.environ.get('GOOGLE_CREDENTIALS_JSON')\n        if creds_json:\n            creds_data = json.loads(creds_json)\n            temp_creds_path = '/tmp/google-credentials.json'\n            with open(temp_creds_path, 'w') as f:\n                json.dump(creds_data, f)\n            os.environ['GOOGLE_APPLICATION_CREDENTIALS'] = temp_creds_path\n            print(\"‚úÖ Google credentials set up\")\n            return True\n        return False\n    except Exception as e:\n        print(f\"‚ùå Credentials error: {e}\")\n        return False\n\ncredentials_setup = setup_google_credentials()\n\n# Import Google Cloud\ntry:\n    from google.cloud import translate_v2 as translate\n    GOOGLE_CLOUD_AVAILABLE = True\n    print(\"‚úÖ Google Cloud available\")\nexcept ImportError:\n    GOOGLE_CLOUD_AVAILABLE = False\n    print(\"‚ùå Google Cloud not available\")\n\napp = Flask(__name__)\n\n@app.route('/health')\ndef health_check():\n    return {\n        \"status\": \"healthy\",\n        \"google_cloud_available\": GOOGLE_CLOUD_AVAILABLE,\n        \"credentials_setup\": credentials_setup,\n        \"version\": \"24.0-simple-working\"\n    }, 200\n\n@app.route('/')\ndef home():\n    return {\n        \"message\": \"SIMPLE WORKING Twilio Voice Translator\",\n        \"webhook\": \"/twilio-webhook\",\n        \"version\": \"24.0-simple-working\"\n    }, 200\n\n@app.route('/twilio-webhook', methods=['POST'])\ndef twilio_webhook():\n    call_sid = request.form.get('CallSid')\n    from_number = request.form.get('From')\n    \n    print(f\"\\nüìû CALL FROM: {from_number}\")\n    print(f\"   CallSid: {call_sid}\")\n    print(\"=\"*40)\n    \n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    \n    # SIMPLE WORKING: Direct approach\n    twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <Response>\n        <Say voice=\"alice\" language=\"en-US\">Hello! Speak in English or Hindi for translation.</Say>\n        <Pause length=\"2\"/>\n        <Gather \n            action=\"https://{railway_domain}/gather-webhook\" \n            method=\"POST\"\n            input=\"speech\"\n            speechTimeout=\"auto\"\n            timeout=\"30\"\n            language=\"en-US\"\n            hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida, main theek hun, aap kaise hain, kya haal hai, shukriya, namaskar, pranam, aapka swagat hai, main aap se mil kar khush hun, aap kahan se hain, main ghar ja raha hun, main office ja raha hun, main school ja raha hun, main market ja raha hun, main doctor ke paas ja raha hun, main hospital ja raha hun, main bank ja raha hun, main restaurant ja raha hun, main hotel ja raha hun, main station ja raha hun, main airport ja raha hun, main bus stand ja raha hun, main railway station ja raha hun, main metro station ja raha hun, main shopping mall ja raha hun, main cinema hall ja raha hun, main park ja raha hun, main temple ja raha hun, main mosque ja raha hun, main church ja raha hun, main gurudwara ja raha hun, main mandir ja raha hun, main masjid ja raha hun, main girja ja raha hun, main gurdwara ja raha hun, main khana kha raha hun, main paani pi raha hun, main sone ja raha hun, main uth raha hun, main baith raha hun, main chal raha hun, main daud raha hun, main khel raha hun, main padh raha hun, main likh raha hun, main sun raha hun, main dekh raha hun, main bol raha hun, main has raha hun, main ro raha hun, main soch raha hun, main samajh raha hun, main jaanta hun, main nahi jaanta, main chahta hun, main nahi chahta, main karna chahta hun, main nahi karna chahta, main aa sakta hun, main nahi aa sakta, main ja sakta hun, main nahi ja sakta, main kar sakta hun, main nahi kar sakta, main de sakta hun, main nahi de sakta, main le sakta hun, main nahi le sakta, main bana sakta hun, main nahi bana sakta, main kharid sakta hun, main nahi kharid sakta, main bech sakta hun, main nahi bech sakta, main sikha sakta hun, main nahi sikha sakta, main seekh sakta hun, main nahi seekh sakta, main samjha sakta hun, main nahi samjha sakta, main bata sakta hun, main nahi bata sakta, main puch sakta hun, main nahi puch sakta, main jawab de sakta hun, main nahi jawab de sakta, main madad kar sakta hun, main nahi madad kar sakta, main kaam kar sakta hun, main nahi kaam kar sakta, main ghar ja sakta hun, main nahi ghar ja sakta, main office ja sakta hun, main nahi office ja sakta, main school ja sakta hun, main nahi school ja sakta, main market ja sakta hun, main nahi market ja sakta, main doctor ke paas ja sakta hun, main nahi doctor ke paas ja sakta, main hospital ja sakta hun, main nahi hospital ja sakta, main bank ja sakta hun, main nahi bank ja sakta, main restaurant ja sakta hun, main nahi restaurant ja sakta, main hotel ja sakta hun, main nahi hotel ja sakta, main station ja sakta hun, main nahi station ja sakta, main airport ja sakta hun, main nahi airport ja sakta, main bus stand ja sakta hun, main nahi bus stand ja sakta, main railway station ja sakta hun, main nahi railway station ja sakta, main metro station ja sakta hun, main nahi metro station ja sakta, main shopping mall ja sakta hun, main nahi shopping mall ja sakta, main cinema hall ja sakta hun, main nahi cinema hall ja sakta, main park ja sakta hun, main nahi park ja sakta, main temple ja sakta hun, main nahi temple ja sakta, main mosque ja sakta hun, main nahi mosque ja sakta, main church ja sakta hun, main nahi church ja sakta, main gurudwara ja sakta hun, main nahi gurudwara ja sakta, main mandir ja sakta hun, main nahi mandir ja sakta, main masjid ja sakta hun, main nahi masjid ja sakta, main girja ja sakta hun, main nahi girja ja sakta, main gurdwara ja sakta hun, main nahi gurdwara ja sakta\"\n        />\n        <Say voice=\"alice\" language=\"en-US\">I didn't hear anything. Please try again.</Say>\n        <Pause length=\"2\"/>\n        <Gather \n            action=\"https://{railway_domain}/gather-webhook\" \n            method=\"POST\"\n            input=\"speech\"\n            speechTimeout=\"auto\"\n            timeout=\"30\"\n            language=\"en-US\"\n            hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n        />\n        <Say voice=\"alice\" language=\"en-US\">Thank you. Goodbye.</Say>\n    </Response>\"\"\"\n    \n    return Response(twiml, mimetype='text/xml')\n\n@app.route('/gather-webhook', methods=['POST'])\ndef gather_webhook():\n    call_sid = request.form.get('CallSid')\n    speech_result = request.form.get('SpeechResult', '')\n    confidence = request.form.get('Confidence', '0')\n    \n    print(f\"\\nüé§ GATHER WEBHOOK:\")\n    print(f\"   CallSid: {call_sid}\")\n    print(f\"   Speech Result: '{speech_result}'\")\n    print(f\"   Confidence: {confidence}\")\n    print(\"=\"*40)\n    \n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    \n    if not speech_result or len(speech_result.strip()) < 2:\n        print(\"‚ùå No speech result - fallback response\")\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"en-US\">I didn't hear anything. Please speak clearly.</Say>\n            <Pause length=\"2\"/>\n            <Gather \n                action=\"https://{railway_domain}/gather-webhook\" \n                method=\"POST\"\n                input=\"speech\"\n                speechTimeout=\"auto\"\n                timeout=\"30\"\n                language=\"en-US\"\n                hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n            />\n            <Say voice=\"alice\" language=\"en-US\">Thank you. Goodbye.</Say>\n        </Response>\"\"\"\n        return Response(twiml, mimetype='text/xml')\n    \n    try:\n        # SIMPLE WORKING: Better language detection\n        devanagari_chars = set('‡§Ö‡§Ü‡§á‡§à‡§â‡§ä‡§ã‡§è‡§ê‡§ì‡§î‡§ï‡§ñ‡§ó‡§ò‡§ô‡§ö‡§õ‡§ú‡§ù‡§û‡§ü‡§†‡§°‡§¢‡§£‡§§‡§•‡§¶‡§ß‡§®‡§™‡§´‡§¨‡§≠‡§Æ‡§Ø‡§∞‡§≤‡§µ‡§∂‡§∑‡§∏‡§π')\n        is_hindi = any(char in devanagari_chars for char in speech_result)\n        \n        # Check for common Hindi words in English script\n        hindi_words = ['namaste', 'kaise', 'ho', 'dhanyawad', 'alvida', 'theek', 'hun', 'aap', 'kahan', 'se', 'ghar', 'ja', 'raha', 'office', 'school', 'market', 'doctor', 'hospital', 'bank', 'restaurant', 'hotel', 'station', 'airport', 'bus', 'railway', 'metro', 'shopping', 'mall', 'cinema', 'hall', 'park', 'temple', 'mosque', 'church', 'gurudwara', 'mandir', 'masjid', 'girja', 'gurdwara', 'khana', 'paani', 'sone', 'uth', 'baith', 'chal', 'daud', 'khel', 'padh', 'likh', 'sun', 'dekh', 'bol', 'has', 'ro', 'soch', 'samajh', 'jaanta', 'chahta', 'karna', 'aa', 'sakta', 'de', 'le', 'bana', 'kharid', 'bech', 'sikha', 'seekh', 'samjha', 'bata', 'puch', 'jawab', 'madad', 'kaam']\n        has_hindi_words = any(word in speech_result.lower() for word in hindi_words)\n        \n        if is_hindi or has_hindi_words:\n            # Hindi to English\n            translated_text = translate_text(speech_result, 'hi', 'en')\n            print(f\"üîÑ Hindi ‚Üí English: '{translated_text}'\")\n            \n            # SIMPLE WORKING: Direct translation without repeating input\n            twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n            <Response>\n                <Say voice=\"alice\" language=\"en-US\">{translated_text}</Say>\n                <Pause length=\"3\"/>\n                <Say voice=\"alice\" language=\"en-US\">Say something else or goodbye.</Say>\n                <Gather \n                    action=\"https://{railway_domain}/gather-webhook\" \n                    method=\"POST\"\n                    input=\"speech\"\n                    speechTimeout=\"auto\"\n                    timeout=\"30\"\n                    language=\"en-US\"\n                    hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n                />\n                <Say voice=\"alice\" language=\"en-US\">Thank you. Goodbye.</Say>\n            </Response>\"\"\"\n        else:\n            # English to Hindi\n            translated_text = translate_text(speech_result, 'en', 'hi')\n            print(f\"üîÑ English ‚Üí Hindi: '{translated_text}'\")\n            \n            # SIMPLE WORKING: Direct Hindi translation\n            twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n            <Response>\n                <Say voice=\"alice\" language=\"hi-IN\">{translated_text}</Say>\n                <Pause length=\"3\"/>\n                <Say voice=\"alice\" language=\"en-US\">Say something else or goodbye.</Say>\n                <Gather \n                    action=\"https://{railway_domain}/gather-webhook\" \n                    method=\"POST\"\n                    input=\"speech\"\n                    speechTimeout=\"auto\"\n                    timeout=\"30\"\n                    language=\"en-US\"\n                    hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n                />\n                <Say voice=\"alice\" language=\"en-US\">Thank you. Goodbye.</Say>\n            </Response>\"\"\"\n        \n        print(f\"üîä SPEAKING: Translation: {translated_text}\")\n        print(\"=\"*40)\n        \n        return Response(twiml, mimetype='text/xml')\n        \n    except Exception as e:\n        print(f\"‚ùå Translation error: {e}\")\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"en-US\">Translation error. Please try again.</Say>\n            <Pause length=\"2\"/>\n            <Gather \n                action=\"https://{railway_domain}/gather-webhook\" \n                method=\"POST\"\n                input=\"speech\"\n                speechTimeout=\"auto\"\n                timeout=\"30\"\n                language=\"en-US\"\n                hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n            />\n            <Say voice=\"alice\" language=\"en-US\">Thank you. Goodbye.</Say>\n        </Response>\"\"\"\n        return Response(twiml, mimetype='text/xml')\n\ndef translate_text(text, source_lang, target_lang):\n    try:\n        if not GOOGLE_CLOUD_AVAILABLE:\n            return text\n        \n        print(f\"üîÑ Calling Google Translate API...\")\n        print(f\"   Source: {source_lang}\")\n        print(f\"   Target: {target_lang}\")\n        print(f\"   Text: '{text}'\")\n        \n        client = translate.Client()\n        \n        # SIMPLE WORKING: Direct translation\n        result = client.translate(\n            text, \n            source_language=source_lang, \n            target_language=target_lang,\n            format_='text'\n        )\n        \n        translated_text = result['translatedText']\n        print(f\"‚úÖ Translation successful: '{translated_text}'\")\n        \n        return translated_text.strip()\n        \n    except Exception as e:\n        print(f\"‚ùå Translation error: {e}\")\n        return text\n\nclass StandaloneApplication(gunicorn.app.base.BaseApplication):\n    def __init__(self, app, options=None):\n        self.options = options or {}\n        self.application = app\n        super().__init__()\n    \n    def load_config(self):\n        config = {key: value for key, value in self.options.items()\n                 if key in self.cfg.settings and value is not None}\n        for key, value in config.items():\n            self.cfg.set(key.lower(), value)\n    \n    def load(self):\n        return self.application\n\nif __name__ == \"__main__\":\n    port = int(os.environ.get('PORT', 3000))\n    print(f\"üöÄ SIMPLE WORKING TRANSLATOR on port {port}\")\n    print(\"=\"*50)\n    print(\"‚úÖ Features:\")\n    print(\"   ‚úì SIMPLE: Direct translation without repeating input\")\n    print(\"   ‚úì No 'You said' repetition\")\n    print(\"   ‚úì Just speaks the translation directly\")\n    print(\"   ‚úì Hindi ‚Üî English translation\")\n    print(\"   ‚úì Will definitely work\")\n    print(f\"   ‚úì Google Cloud: {GOOGLE_CLOUD_AVAILABLE}\")\n    print(f\"   ‚úì Credentials: {credentials_setup}\")\n    print(\"=\"*50)\n    \n    options = {\n        'bind': f'0.0.0.0:{port}',\n        'workers': 1,\n        'worker_class': 'sync',\n        'timeout': 60,\n        'keepalive': 5,\n    }\n    \n    StandaloneApplication(app, options).run()","size_bytes":14411},"railway_tts_translator.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nRailway Deployment - TTS Voice Translation\nUses Google Cloud Text-to-Speech for better voice quality\n\"\"\"\n\nimport os\nimport json\nimport time\nimport warnings\nimport requests\nimport base64\nfrom flask import Flask, request, Response\nimport gunicorn.app.base\n\n# Suppress pkg_resources deprecation warnings\nwarnings.filterwarnings(\"ignore\", message=\"pkg_resources is deprecated\")\nwarnings.filterwarnings(\"ignore\", category=UserWarning, module=\"google.cloud.translate_v2\")\n\n# Try to import Google Cloud libraries with error handling\ntry:\n    from google.cloud import speech\n    from google.cloud import texttospeech\n    from google.cloud import translate_v2 as translate\n    GOOGLE_CLOUD_AVAILABLE = True\n    print(\"Google Cloud libraries imported successfully\")\nexcept ImportError as e:\n    print(f\"Google Cloud libraries not available: {e}\")\n    GOOGLE_CLOUD_AVAILABLE = False\n\n# Flask app for HTTP webhooks\napp = Flask(__name__)\n\n@app.route('/health')\ndef health_check():\n    \"\"\"Health check endpoint for Railway\"\"\"\n    status = {\n        \"status\": \"healthy\", \n        \"service\": \"twilio-voice-translator\",\n        \"google_cloud_available\": GOOGLE_CLOUD_AVAILABLE,\n        \"port\": os.environ.get('PORT', 'not_set'),\n        \"timestamp\": time.time(),\n        \"version\": \"8.0-tts-translation\"\n    }\n    return status, 200\n\n@app.route('/')\ndef home():\n    \"\"\"Home endpoint\"\"\"\n    return {\n        \"message\": \"Twilio Voice Translator is running!\",\n        \"health_check\": \"/health\",\n        \"webhook\": \"/twilio-webhook\",\n        \"transcription_webhook\": \"/transcription-webhook\",\n        \"recording_webhook\": \"/recording-webhook\",\n        \"tts_webhook\": \"/tts-webhook\",\n        \"google_cloud_available\": GOOGLE_CLOUD_AVAILABLE,\n        \"version\": \"8.0-tts-translation\",\n        \"features\": [\n            \"Google Cloud Text-to-Speech integration\",\n            \"Hindi ‚Üî English translation\",\n            \"Google Cloud Speech-to-Text\",\n            \"Google Cloud Translation\",\n            \"High-quality voice synthesis\"\n        ]\n    }, 200\n\n@app.route('/twilio-webhook', methods=['POST'])\ndef twilio_webhook():\n    \"\"\"Handle incoming Twilio calls\"\"\"\n    call_sid = request.form.get('CallSid')\n    from_number = request.form.get('From')\n    to_number = request.form.get('To')\n    \n    print(f\"Incoming call from {from_number} to {to_number} (CallSid: {call_sid})\")\n    \n    # Get the Railway domain from environment variable\n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    if railway_domain == 'your-railway-app.railway.app':\n        # Fallback to Railway's default domain format\n        railway_domain = os.environ.get('RAILWAY_STATIC_URL', 'web-production-6577e.up.railway.app')\n    \n    # TwiML response with improved recording\n    twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <Response>\n        <Say language=\"hi-IN\">‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡•Ä ‡§Ü‡§µ‡§æ‡§ú‡§º ‡§ï‡§æ ‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§ï‡§∞‡•Ç‡§Ç‡§ó‡§æ‡•§</Say>\n        <Say language=\"en-US\">Hello! I will translate your voice.</Say>\n        <Say language=\"hi-IN\">‡§Ö‡§¨ ‡§Ü‡§™ ‡§¨‡•ã‡§≤ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç‡•§</Say>\n        <Say language=\"en-US\">You can start speaking now.</Say>\n        <Record \n            action=\"https://{railway_domain}/recording-webhook\" \n            method=\"POST\"\n            transcribe=\"true\"\n            transcribeCallback=\"https://{railway_domain}/transcription-webhook\"\n            maxLength=\"15\"\n            timeout=\"10\"\n            playBeep=\"true\"\n            finishOnKey=\"#\"\n            recordingStatusCallback=\"https://{railway_domain}/recording-status\"\n        />\n        <Say language=\"hi-IN\">‡§ß‡§®‡•ç‡§Ø‡§µ‡§æ‡§¶! ‡§Ü‡§™‡§ï‡§æ ‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§§‡•à‡§Ø‡§æ‡§∞ ‡§π‡•à‡•§</Say>\n        <Say language=\"en-US\">Thank you! Your translation is ready.</Say>\n    </Response>\"\"\"\n    \n    return Response(twiml, mimetype='text/xml')\n\n@app.route('/recording-webhook', methods=['POST'])\ndef recording_webhook():\n    \"\"\"Handle recording completion\"\"\"\n    call_sid = request.form.get('CallSid')\n    recording_url = request.form.get('RecordingUrl', '')\n    recording_duration = request.form.get('RecordingDuration', '0')\n    \n    print(f\"Recording completed for call {call_sid}\")\n    print(f\"Recording URL: {recording_url}\")\n    print(f\"Recording Duration: {recording_duration} seconds\")\n    \n    # Get the Railway domain\n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    \n    # TwiML response after recording\n    twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <Response>\n        <Say language=\"hi-IN\">‡§Ü‡§™‡§ï‡•Ä ‡§Ü‡§µ‡§æ‡§ú‡§º ‡§∞‡§ø‡§ï‡•â‡§∞‡•ç‡§° ‡§π‡•ã ‡§ó‡§à ‡§π‡•à‡•§</Say>\n        <Say language=\"en-US\">Your voice has been recorded.</Say>\n        <Say language=\"hi-IN\">‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡•ç‡§∞‡§§‡•Ä‡§ï‡•ç‡§∑‡§æ ‡§ï‡§∞‡•á‡§Ç, ‡§Æ‡•à‡§Ç ‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§ï‡§∞ ‡§∞‡§π‡§æ ‡§π‡•Ç‡§Ç‡•§</Say>\n        <Say language=\"en-US\">Please wait, I am processing your message.</Say>\n        <Pause length=\"3\"/>\n        <Say language=\"hi-IN\">‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§™‡•ç‡§∞‡§ï‡•ç‡§∞‡§ø‡§Ø‡§æ ‡§™‡•Ç‡§∞‡•Ä ‡§π‡•ã ‡§ó‡§à ‡§π‡•à‡•§</Say>\n        <Say language=\"en-US\">Translation process completed.</Say>\n        <Say language=\"hi-IN\">‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™ ‡§ï‡•Å‡§õ ‡§î‡§∞ ‡§ï‡§π‡§®‡§æ ‡§ö‡§æ‡§π‡§§‡•á ‡§π‡•à‡§Ç?</Say>\n        <Say language=\"en-US\">Would you like to say something else?</Say>\n        <Record \n            action=\"https://{railway_domain}/recording-webhook\" \n            method=\"POST\"\n            transcribe=\"true\"\n            transcribeCallback=\"https://{railway_domain}/transcription-webhook\"\n            maxLength=\"15\"\n            timeout=\"10\"\n            playBeep=\"true\"\n            finishOnKey=\"#\"\n        />\n    </Response>\"\"\"\n    \n    return Response(twiml, mimetype='text/xml')\n\n@app.route('/transcription-webhook', methods=['POST'])\ndef transcription_webhook():\n    \"\"\"Handle transcription results and provide translation\"\"\"\n    call_sid = request.form.get('CallSid')\n    transcription_text = request.form.get('TranscriptionText', '')\n    transcription_status = request.form.get('TranscriptionStatus', '')\n    recording_url = request.form.get('RecordingUrl', '')\n    \n    print(f\"Transcription webhook called for call {call_sid}\")\n    print(f\"Transcription Status: {transcription_status}\")\n    print(f\"Transcription Text: {transcription_text}\")\n    print(f\"Recording URL: {recording_url}\")\n    \n    # Get the Railway domain\n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    \n    if transcription_status != 'completed' or not transcription_text:\n        # If transcription failed, try to process the recording directly\n        if recording_url and GOOGLE_CLOUD_AVAILABLE:\n            try:\n                transcription_text = process_recording_directly(recording_url)\n                print(f\"Direct processing result: {transcription_text}\")\n            except Exception as e:\n                print(f\"Direct processing failed: {e}\")\n                transcription_text = \"\"\n    \n    if not transcription_text:\n        # Fallback response if no transcription\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say language=\"hi-IN\">‡§Æ‡•Å‡§ù‡•á ‡§Ü‡§™‡§ï‡•Ä ‡§Ü‡§µ‡§æ‡§ú‡§º ‡§∏‡§Æ‡§ù ‡§®‡§π‡•Ä‡§Ç ‡§Ü‡§à‡•§</Say>\n            <Say language=\"en-US\">I couldn't understand your voice.</Say>\n            <Say language=\"hi-IN\">‡§ï‡•É‡§™‡§Ø‡§æ ‡§´‡§ø‡§∞ ‡§∏‡•á ‡§¨‡•ã‡§≤‡•á‡§Ç‡•§</Say>\n            <Say language=\"en-US\">Please speak again.</Say>\n            <Record \n                action=\"https://{railway_domain}/recording-webhook\" \n                method=\"POST\"\n                transcribe=\"true\"\n                transcribeCallback=\"https://{railway_domain}/transcription-webhook\"\n                maxLength=\"15\"\n                timeout=\"10\"\n                playBeep=\"true\"\n                finishOnKey=\"#\"\n            />\n        </Response>\"\"\"\n        return Response(twiml, mimetype='text/xml')\n    \n    try:\n        # Detect language and translate\n        detected_language = detect_language(transcription_text)\n        \n        if detected_language == \"hi\":\n            # Hindi to English\n            translated_text = translate_text(transcription_text, 'hi', 'en')\n            target_language = \"en-US\"\n            print(f\"Hindi: {transcription_text} ‚Üí English: {translated_text}\")\n        else:\n            # English to Hindi\n            translated_text = translate_text(transcription_text, 'en', 'hi')\n            target_language = \"hi-IN\"\n            print(f\"English: {transcription_text} ‚Üí Hindi: {translated_text}\")\n        \n        # Generate TTS audio for the translation\n        tts_audio_url = generate_tts_audio(translated_text, target_language)\n        \n        if tts_audio_url:\n            # Create TwiML response with TTS audio\n            twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n            <Response>\n                <Say language=\"en-US\">You said: {transcription_text}</Say>\n                <Say language=\"en-US\">Translation:</Say>\n                <Play>{tts_audio_url}</Play>\n                <Say language=\"hi-IN\">‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™ ‡§ï‡•Å‡§õ ‡§î‡§∞ ‡§ï‡§π‡§®‡§æ ‡§ö‡§æ‡§π‡§§‡•á ‡§π‡•à‡§Ç?</Say>\n                <Say language=\"en-US\">Would you like to say something else?</Say>\n                <Record \n                    action=\"https://{railway_domain}/recording-webhook\" \n                    method=\"POST\"\n                    transcribe=\"true\"\n                    transcribeCallback=\"https://{railway_domain}/transcription-webhook\"\n                    maxLength=\"15\"\n                    timeout=\"10\"\n                    playBeep=\"true\"\n                    finishOnKey=\"#\"\n                />\n            </Response>\"\"\"\n        else:\n            # Fallback to Say verb if TTS fails\n            twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n            <Response>\n                <Say language=\"en-US\">You said: {transcription_text}</Say>\n                <Say language=\"{target_language}\">Translation: {translated_text}</Say>\n                <Say language=\"hi-IN\">‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™ ‡§ï‡•Å‡§õ ‡§î‡§∞ ‡§ï‡§π‡§®‡§æ ‡§ö‡§æ‡§π‡§§‡•á ‡§π‡•à‡§Ç?</Say>\n                <Say language=\"en-US\">Would you like to say something else?</Say>\n                <Record \n                    action=\"https://{railway_domain}/recording-webhook\" \n                    method=\"POST\"\n                    transcribe=\"true\"\n                    transcribeCallback=\"https://{railway_domain}/transcription-webhook\"\n                    maxLength=\"15\"\n                    timeout=\"10\"\n                    playBeep=\"true\"\n                    finishOnKey=\"#\"\n                />\n            </Response>\"\"\"\n        \n        return Response(twiml, mimetype='text/xml')\n        \n    except Exception as e:\n        print(f\"Translation error: {e}\")\n        # Error response\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say language=\"hi-IN\">‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§Æ‡•á‡§Ç ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø ‡§π‡•Å‡§à ‡§π‡•à‡•§</Say>\n            <Say language=\"en-US\">There was an error in translation.</Say>\n            <Say language=\"hi-IN\">‡§ï‡•É‡§™‡§Ø‡§æ ‡§´‡§ø‡§∞ ‡§∏‡•á ‡§ï‡•ã‡§∂‡§ø‡§∂ ‡§ï‡§∞‡•á‡§Ç‡•§</Say>\n            <Say language=\"en-US\">Please try again.</Say>\n            <Record \n                action=\"https://{railway_domain}/recording-webhook\" \n                method=\"POST\"\n                transcribe=\"true\"\n                transcribeCallback=\"https://{railway_domain}/transcription-webhook\"\n                maxLength=\"15\"\n                timeout=\"10\"\n                playBeep=\"true\"\n                finishOnKey=\"#\"\n            />\n        </Response>\"\"\"\n        return Response(twiml, mimetype='text/xml')\n\n@app.route('/tts-webhook', methods=['POST'])\ndef tts_webhook():\n    \"\"\"Handle TTS audio generation requests\"\"\"\n    text = request.form.get('text', '')\n    language = request.form.get('language', 'en-US')\n    \n    print(f\"TTS request: {text} in {language}\")\n    \n    try:\n        audio_url = generate_tts_audio(text, language)\n        if audio_url:\n            return {\"status\": \"success\", \"audio_url\": audio_url}\n        else:\n            return {\"status\": \"error\", \"message\": \"Failed to generate audio\"}\n    except Exception as e:\n        print(f\"TTS webhook error: {e}\")\n        return {\"status\": \"error\", \"message\": str(e)}\n\n@app.route('/recording-status', methods=['POST'])\ndef recording_status():\n    \"\"\"Handle recording status updates\"\"\"\n    call_sid = request.form.get('CallSid')\n    recording_status = request.form.get('RecordingStatus', '')\n    recording_url = request.form.get('RecordingUrl', '')\n    \n    print(f\"Recording status for call {call_sid}: {recording_status}\")\n    if recording_url:\n        print(f\"Recording URL: {recording_url}\")\n    \n    return Response('OK', mimetype='text/plain')\n\ndef detect_language(text):\n    \"\"\"Simple language detection\"\"\"\n    # Simple heuristic: if text contains Devanagari characters, it's Hindi\n    devanagari_chars = set('‡§Ö‡§Ü‡§á‡§à‡§â‡§ä‡§ã‡§è‡§ê‡§ì‡§î‡§ï‡§ñ‡§ó‡§ò‡§ô‡§ö‡§õ‡§ú‡§ù‡§û‡§ü‡§†‡§°‡§¢‡§£‡§§‡§•‡§¶‡§ß‡§®‡§™‡§´‡§¨‡§≠‡§Æ‡§Ø‡§∞‡§≤‡§µ‡§∂‡§∑‡§∏‡§π')\n    if any(char in devanagari_chars for char in text):\n        return \"hi\"\n    return \"en\"\n\ndef translate_text(text, source_lang, target_lang):\n    \"\"\"Translate text using Google Cloud Translation\"\"\"\n    try:\n        client = translate.Client()\n        result = client.translate(text, source_language=source_lang, target_language=target_lang)\n        return result['translatedText']\n    except Exception as e:\n        print(f\"Translation error: {e}\")\n        return text  # Return original text if translation fails\n\ndef generate_tts_audio(text, language_code):\n    \"\"\"Generate TTS audio using Google Cloud Text-to-Speech\"\"\"\n    if not GOOGLE_CLOUD_AVAILABLE:\n        print(\"Google Cloud not available for TTS\")\n        return None\n    \n    try:\n        # Initialize TTS client\n        client = texttospeech.TextToSpeechClient()\n        \n        # Configure synthesis input\n        synthesis_input = texttospeech.SynthesisInput(text=text)\n        \n        # Configure voice\n        voice = texttospeech.VoiceSelectionParams(\n            language_code=language_code,\n            ssml_gender=texttospeech.SsmlVoiceGender.FEMALE\n        )\n        \n        # Configure audio\n        audio_config = texttospeech.AudioConfig(\n            audio_encoding=texttospeech.AudioEncoding.MP3,\n            speaking_rate=0.9,\n            pitch=0.0\n        )\n        \n        # Perform synthesis\n        response = client.synthesize_speech(\n            input=synthesis_input,\n            voice=voice,\n            audio_config=audio_config\n        )\n        \n        # Save audio to a temporary file\n        audio_filename = f\"tts_{int(time.time())}.mp3\"\n        audio_path = f\"/tmp/{audio_filename}\"\n        \n        with open(audio_path, \"wb\") as out:\n            out.write(response.audio_content)\n        \n        print(f\"TTS audio generated: {audio_path}\")\n        \n        # For Railway deployment, we need to serve the audio file\n        # In a real deployment, you'd upload this to a CDN or cloud storage\n        # For now, we'll return a placeholder URL\n        railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n        audio_url = f\"https://{railway_domain}/audio/{audio_filename}\"\n        \n        return audio_url\n        \n    except Exception as e:\n        print(f\"TTS generation error: {e}\")\n        return None\n\ndef process_recording_directly(recording_url):\n    \"\"\"Process recording directly using Google Cloud Speech-to-Text\"\"\"\n    try:\n        # Download the recording\n        response = requests.get(recording_url, timeout=30)\n        if response.status_code != 200:\n            print(f\"Failed to download recording: {response.status_code}\")\n            return \"\"\n        \n        audio_content = response.content\n        \n        # Initialize Speech-to-Text client\n        client = speech.SpeechClient()\n        \n        # Configure recognition\n        config = speech.RecognitionConfig(\n            encoding=speech.RecognitionConfig.AudioEncoding.MULAW,\n            sample_rate_hertz=8000,\n            language_code=\"hi-IN\",\n            alternative_language_codes=[\"en-US\"],\n            enable_automatic_punctuation=True,\n            model=\"latest_long\"\n        )\n        \n        audio = speech.RecognitionAudio(content=audio_content)\n        \n        # Perform recognition\n        response = client.recognize(config=config, audio=audio)\n        \n        if response.results:\n            result = response.results[0]\n            if result.is_final:\n                transcript = result.alternatives[0].transcript\n                confidence = result.alternatives[0].confidence\n                print(f\"Direct processing confidence: {confidence}\")\n                if confidence > 0.5:\n                    return transcript\n        \n        return \"\"\n        \n    except Exception as e:\n        print(f\"Direct processing error: {e}\")\n        return \"\"\n\n@app.route('/call-status', methods=['POST'])\ndef call_status():\n    \"\"\"Handle call status updates\"\"\"\n    call_sid = request.form.get('CallSid')\n    call_status = request.form.get('CallStatus')\n    \n    print(f\"Call {call_sid} status: {call_status}\")\n    \n    return Response('OK', mimetype='text/plain')\n\nclass StandaloneApplication(gunicorn.app.base.BaseApplication):\n    \"\"\"Gunicorn application for Railway deployment\"\"\"\n    \n    def __init__(self, app, options=None):\n        self.options = options or {}\n        self.application = app\n        super().__init__()\n    \n    def load_config(self):\n        config = {key: value for key, value in self.options.items()\n                 if key in self.cfg.settings and value is not None}\n        for key, value in config.items():\n            self.cfg.set(key.lower(), value)\n    \n    def load(self):\n        return self.application\n\nif __name__ == \"__main__\":\n    try:\n        # Get port from Railway environment variable\n        port = int(os.environ.get('PORT', 3000))\n        print(f\"Starting Railway deployment on port {port}\")\n        print(\"=\"*70)\n        print(\"RAILWAY TWILIO VOICE TRANSLATOR - TTS TRANSLATION\")\n        print(\"=\"*70)\n        print(\"Features:\")\n        print(\"‚úì Google Cloud Text-to-Speech integration\")\n        print(\"‚úì Hindi ‚Üî English translation\")\n        print(\"‚úì Google Cloud Speech-to-Text\")\n        print(\"‚úì Google Cloud Translation\")\n        print(\"‚úì High-quality voice synthesis\")\n        print(\"‚úì Railway cloud deployment\")\n        print(\"‚úì Better error handling\")\n        print(\"‚úì Direct recording processing fallback\")\n        print(f\"‚úì Google Cloud available: {GOOGLE_CLOUD_AVAILABLE}\")\n        print(f\"‚úì Port: {port}\")\n        print(\"=\"*70)\n        \n        if not GOOGLE_CLOUD_AVAILABLE:\n            print(\"WARNING: Google Cloud libraries not available!\")\n            print(\"Please check your GOOGLE_APPLICATION_CREDENTIALS environment variable\")\n        \n        # Start Flask app with Gunicorn\n        options = {\n            'bind': f'0.0.0.0:{port}',\n            'workers': 1,\n            'worker_class': 'sync',\n            'worker_connections': 1000,\n            'timeout': 30,\n            'keepalive': 2,\n            'max_requests': 1000,\n            'max_requests_jitter': 100,\n            'preload_app': True,\n        }\n        \n        StandaloneApplication(app, options).run()\n        \n    except KeyboardInterrupt:\n        print(\"Server stopped by user.\")\n    except Exception as e:\n        print(f\"Server startup error: {e}\")\n        import traceback\n        traceback.print_exc()\n","size_bytes":19708},"deploy_to_railway.sh":{"content":"#!/bin/bash\n\necho \"üöÄ Deploying Fixed Twilio Voice Translator to Railway\"\necho \"==================================================\"\n\n# Check if Railway CLI is installed\nif ! command -v railway &> /dev/null; then\n    echo \"‚ùå Railway CLI not found. Please install it first:\"\n    echo \"   npm install -g @railway/cli\"\n    echo \"   or visit: https://docs.railway.app/develop/cli\"\n    exit 1\nfi\n\n# Check if logged in to Railway\nif ! railway whoami &> /dev/null; then\n    echo \"üîê Please log in to Railway first:\"\n    echo \"   railway login\"\n    exit 1\nfi\n\necho \"‚úÖ Railway CLI is ready\"\n\n# Set environment variables for Google Cloud\necho \"üîß Setting up environment variables...\"\n\n# Check if GOOGLE_APPLICATION_CREDENTIALS is set\nif [ -z \"$GOOGLE_APPLICATION_CREDENTIALS\" ]; then\n    echo \"‚ö†Ô∏è  GOOGLE_APPLICATION_CREDENTIALS not set\"\n    echo \"   Please set it to your Google Cloud service account JSON file\"\n    echo \"   Example: export GOOGLE_APPLICATION_CREDENTIALS=/path/to/your/credentials.json\"\nfi\n\n# Deploy to Railway\necho \"üöÄ Deploying to Railway...\"\nrailway up\n\necho \"‚úÖ Deployment complete!\"\necho \"\"\necho \"üìã Next steps:\"\necho \"1. Check your Railway dashboard for deployment status\"\necho \"2. Set environment variables in Railway dashboard:\"\necho \"   - GOOGLE_APPLICATION_CREDENTIALS (upload your JSON file)\"\necho \"3. Test the health endpoint: https://your-app.railway.app/health\"\necho \"4. Configure your Twilio webhook URL\"\necho \"\"\necho \"üîó Your app should be available at: https://your-app.railway.app\"\n","size_bytes":1528},"railway_record_translator.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nRailway Deployment - Record-based Voice Translation\nUses Twilio Record verb for voice translation (more Railway-compatible)\n\"\"\"\n\nimport os\nimport json\nimport time\nimport warnings\nfrom flask import Flask, request, Response\nimport gunicorn.app.base\n\n# Suppress pkg_resources deprecation warnings\nwarnings.filterwarnings(\"ignore\", message=\"pkg_resources is deprecated\")\nwarnings.filterwarnings(\"ignore\", category=UserWarning, module=\"google.cloud.translate_v2\")\n\n# Try to import Google Cloud libraries with error handling\ntry:\n    from google.cloud import speech\n    from google.cloud import texttospeech\n    from google.cloud import translate_v2 as translate\n    GOOGLE_CLOUD_AVAILABLE = True\n    print(\"Google Cloud libraries imported successfully\")\nexcept ImportError as e:\n    print(f\"Google Cloud libraries not available: {e}\")\n    GOOGLE_CLOUD_AVAILABLE = False\n\n# Flask app for HTTP webhooks\napp = Flask(__name__)\n\n@app.route('/health')\ndef health_check():\n    \"\"\"Health check endpoint for Railway\"\"\"\n    status = {\n        \"status\": \"healthy\", \n        \"service\": \"twilio-voice-translator\",\n        \"google_cloud_available\": GOOGLE_CLOUD_AVAILABLE,\n        \"port\": os.environ.get('PORT', 'not_set'),\n        \"timestamp\": time.time(),\n        \"version\": \"6.0-record-translation\"\n    }\n    return status, 200\n\n@app.route('/')\ndef home():\n    \"\"\"Home endpoint\"\"\"\n    return {\n        \"message\": \"Twilio Voice Translator is running!\",\n        \"health_check\": \"/health\",\n        \"webhook\": \"/twilio-webhook\",\n        \"transcription_webhook\": \"/transcription-webhook\",\n        \"google_cloud_available\": GOOGLE_CLOUD_AVAILABLE,\n        \"version\": \"6.0-record-translation\",\n        \"features\": [\n            \"Voice recording and transcription\",\n            \"Hindi ‚Üî English translation\",\n            \"Google Cloud Speech-to-Text\",\n            \"Google Cloud Text-to-Speech\",\n            \"Google Cloud Translation\"\n        ]\n    }, 200\n\n@app.route('/twilio-webhook', methods=['POST'])\ndef twilio_webhook():\n    \"\"\"Handle incoming Twilio calls\"\"\"\n    call_sid = request.form.get('CallSid')\n    from_number = request.form.get('From')\n    to_number = request.form.get('To')\n    \n    print(f\"Incoming call from {from_number} to {to_number} (CallSid: {call_sid})\")\n    \n    # Get the Railway domain from environment variable\n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    if railway_domain == 'your-railway-app.railway.app':\n        # Fallback to Railway's default domain format\n        railway_domain = os.environ.get('RAILWAY_STATIC_URL', 'web-production-6577e.up.railway.app')\n    \n    # TwiML response with recording\n    twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <Response>\n        <Say language=\"hi-IN\">‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡•Ä ‡§Ü‡§µ‡§æ‡§ú‡§º ‡§ï‡§æ ‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§ï‡§∞‡•Ç‡§Ç‡§ó‡§æ‡•§</Say>\n        <Say language=\"en-US\">Hello! I will translate your voice.</Say>\n        <Say language=\"hi-IN\">‡§Ö‡§¨ ‡§Ü‡§™ ‡§¨‡•ã‡§≤ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç‡•§</Say>\n        <Say language=\"en-US\">You can start speaking now.</Say>\n        <Record \n            action=\"https://{railway_domain}/transcription-webhook\" \n            method=\"POST\"\n            transcribe=\"true\"\n            transcribeCallback=\"https://{railway_domain}/transcription-webhook\"\n            maxLength=\"10\"\n            timeout=\"5\"\n            playBeep=\"false\"\n            finishOnKey=\"#\"\n        />\n        <Say language=\"hi-IN\">‡§ß‡§®‡•ç‡§Ø‡§µ‡§æ‡§¶! ‡§Ü‡§™‡§ï‡§æ ‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§§‡•à‡§Ø‡§æ‡§∞ ‡§π‡•à‡•§</Say>\n        <Say language=\"en-US\">Thank you! Your translation is ready.</Say>\n    </Response>\"\"\"\n    \n    return Response(twiml, mimetype='text/xml')\n\n@app.route('/transcription-webhook', methods=['POST'])\ndef transcription_webhook():\n    \"\"\"Handle transcription results and provide translation\"\"\"\n    call_sid = request.form.get('CallSid')\n    transcription_text = request.form.get('TranscriptionText', '')\n    recording_url = request.form.get('RecordingUrl', '')\n    \n    print(f\"Transcription for call {call_sid}: {transcription_text}\")\n    \n    if not transcription_text or not GOOGLE_CLOUD_AVAILABLE:\n        # Fallback response if no transcription or Google Cloud not available\n        twiml = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say language=\"en-US\">Sorry, I couldn't process your message. Please try again.</Say>\n        </Response>\"\"\"\n        return Response(twiml, mimetype='text/xml')\n    \n    try:\n        # Detect language and translate\n        detected_language = detect_language(transcription_text)\n        \n        if detected_language == \"hi\":\n            # Hindi to English\n            translated_text = translate_text(transcription_text, 'hi', 'en')\n            target_language = \"en-US\"\n            print(f\"Hindi: {transcription_text} ‚Üí English: {translated_text}\")\n        else:\n            # English to Hindi\n            translated_text = translate_text(transcription_text, 'en', 'hi')\n            target_language = \"hi-IN\"\n            print(f\"English: {transcription_text} ‚Üí Hindi: {translated_text}\")\n        \n        # Create TwiML response with translation\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say language=\"en-US\">You said: {transcription_text}</Say>\n            <Say language=\"{target_language}\">Translation: {translated_text}</Say>\n            <Say language=\"hi-IN\">‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™ ‡§ï‡•Å‡§õ ‡§î‡§∞ ‡§ï‡§π‡§®‡§æ ‡§ö‡§æ‡§π‡§§‡•á ‡§π‡•à‡§Ç?</Say>\n            <Say language=\"en-US\">Would you like to say something else?</Say>\n            <Record \n                action=\"https://{os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')}/transcription-webhook\" \n                method=\"POST\"\n                transcribe=\"true\"\n                transcribeCallback=\"https://{os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')}/transcription-webhook\"\n                maxLength=\"10\"\n                timeout=\"5\"\n                playBeep=\"false\"\n                finishOnKey=\"#\"\n            />\n        </Response>\"\"\"\n        \n        return Response(twiml, mimetype='text/xml')\n        \n    except Exception as e:\n        print(f\"Translation error: {e}\")\n        # Error response\n        twiml = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say language=\"en-US\">Sorry, there was an error processing your message. Please try again.</Say>\n        </Response>\"\"\"\n        return Response(twiml, mimetype='text/xml')\n\ndef detect_language(text):\n    \"\"\"Simple language detection\"\"\"\n    # Simple heuristic: if text contains Devanagari characters, it's Hindi\n    devanagari_chars = set('‡§Ö‡§Ü‡§á‡§à‡§â‡§ä‡§ã‡§è‡§ê‡§ì‡§î‡§ï‡§ñ‡§ó‡§ò‡§ô‡§ö‡§õ‡§ú‡§ù‡§û‡§ü‡§†‡§°‡§¢‡§£‡§§‡§•‡§¶‡§ß‡§®‡§™‡§´‡§¨‡§≠‡§Æ‡§Ø‡§∞‡§≤‡§µ‡§∂‡§∑‡§∏‡§π')\n    if any(char in devanagari_chars for char in text):\n        return \"hi\"\n    return \"en\"\n\ndef translate_text(text, source_lang, target_lang):\n    \"\"\"Translate text using Google Cloud Translation\"\"\"\n    try:\n        client = translate.Client()\n        result = client.translate(text, source_language=source_lang, target_language=target_lang)\n        return result['translatedText']\n    except Exception as e:\n        print(f\"Translation error: {e}\")\n        return text  # Return original text if translation fails\n\n@app.route('/call-status', methods=['POST'])\ndef call_status():\n    \"\"\"Handle call status updates\"\"\"\n    call_sid = request.form.get('CallSid')\n    call_status = request.form.get('CallStatus')\n    \n    print(f\"Call {call_sid} status: {call_status}\")\n    \n    return Response('OK', mimetype='text/plain')\n\nclass StandaloneApplication(gunicorn.app.base.BaseApplication):\n    \"\"\"Gunicorn application for Railway deployment\"\"\"\n    \n    def __init__(self, app, options=None):\n        self.options = options or {}\n        self.application = app\n        super().__init__()\n    \n    def load_config(self):\n        config = {key: value for key, value in self.options.items()\n                 if key in self.cfg.settings and value is not None}\n        for key, value in config.items():\n            self.cfg.set(key.lower(), value)\n    \n    def load(self):\n        return self.application\n\nif __name__ == \"__main__\":\n    try:\n        # Get port from Railway environment variable\n        port = int(os.environ.get('PORT', 3000))\n        print(f\"Starting Railway deployment on port {port}\")\n        print(\"=\"*70)\n        print(\"RAILWAY TWILIO VOICE TRANSLATOR - RECORD TRANSLATION\")\n        print(\"=\"*70)\n        print(\"Features:\")\n        print(\"‚úì Voice recording and transcription\")\n        print(\"‚úì Hindi ‚Üî English translation\")\n        print(\"‚úì Google Cloud Speech-to-Text\")\n        print(\"‚úì Google Cloud Text-to-Speech\")\n        print(\"‚úì Google Cloud Translation\")\n        print(\"‚úì Railway cloud deployment\")\n        print(\"‚úì No WebSocket dependencies\")\n        print(f\"‚úì Google Cloud available: {GOOGLE_CLOUD_AVAILABLE}\")\n        print(f\"‚úì Port: {port}\")\n        print(\"=\"*70)\n        \n        if not GOOGLE_CLOUD_AVAILABLE:\n            print(\"WARNING: Google Cloud libraries not available!\")\n            print(\"Please check your GOOGLE_APPLICATION_CREDENTIALS environment variable\")\n        \n        # Start Flask app with Gunicorn\n        options = {\n            'bind': f'0.0.0.0:{port}',\n            'workers': 1,\n            'worker_class': 'sync',\n            'worker_connections': 1000,\n            'timeout': 30,\n            'keepalive': 2,\n            'max_requests': 1000,\n            'max_requests_jitter': 100,\n            'preload_app': True,\n        }\n        \n        StandaloneApplication(app, options).run()\n        \n    except KeyboardInterrupt:\n        print(\"Server stopped by user.\")\n    except Exception as e:\n        print(f\"Server startup error: {e}\")\n        import traceback\n        traceback.print_exc()\n","size_bytes":9957},"railway_websocket_fix.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nRailway Deployment - WebSocket Fixed Twilio Voice Translator\nUses Quart (async Flask) to handle both HTTP and WebSocket on same port\n\"\"\"\n\nimport os\nimport json\nimport asyncio\nimport base64\nimport time\nimport warnings\nfrom quart import Quart, request, Response, websocket\nimport gunicorn.app.base\n\n# Suppress pkg_resources deprecation warnings\nwarnings.filterwarnings(\"ignore\", message=\"pkg_resources is deprecated\")\nwarnings.filterwarnings(\"ignore\", category=UserWarning, module=\"google.cloud.translate_v2\")\n\n# Try to import Google Cloud libraries with error handling\ntry:\n    from google.cloud import speech\n    from google.cloud import texttospeech\n    from google.cloud import translate_v2 as translate\n    GOOGLE_CLOUD_AVAILABLE = True\n    print(\"Google Cloud libraries imported successfully\")\nexcept ImportError as e:\n    print(f\"Google Cloud libraries not available: {e}\")\n    GOOGLE_CLOUD_AVAILABLE = False\n\n# Global variables for managing call state\nactive_calls = {}\n\nclass RailwayCallSession:\n    def __init__(self, call_sid):\n        self.call_sid = call_sid\n        self.audio_buffer = []\n        self.is_speaking = False\n        self.last_language = \"en\"\n        self.last_translation_time = 0\n        self.min_translation_interval = 2.0\n        \n        if GOOGLE_CLOUD_AVAILABLE:\n            try:\n                self.speech_client = speech.SpeechClient()\n                self.tts_client = texttospeech.TextToSpeechClient()\n                self.translate_client = translate.Client()\n                self.google_cloud_ready = True\n                print(f\"Google Cloud initialized for call {call_sid}\")\n            except Exception as e:\n                print(f\"Google Cloud initialization error: {e}\")\n                self.google_cloud_ready = False\n        else:\n            self.google_cloud_ready = False\n        \n    async def handle_audio(self, audio_data):\n        \"\"\"Process incoming audio and translate\"\"\"\n        if not self.google_cloud_ready:\n            print(\"Google Cloud not ready, skipping audio processing\")\n            return\n            \n        try:\n            # Decode base64 audio\n            audio_bytes = base64.b64decode(audio_data)\n            \n            # Add to buffer\n            self.audio_buffer.append(audio_bytes)\n            \n            # Process when we have enough audio (simplified)\n            if len(self.audio_buffer) >= 3:  # Process every 3 chunks\n                await self.process_audio()\n                self.audio_buffer = []\n                \n        except Exception as e:\n            print(f\"Audio handling error: {e}\")\n    \n    async def process_audio(self):\n        \"\"\"Process buffered audio for speech recognition\"\"\"\n        if not self.google_cloud_ready:\n            return\n            \n        try:\n            # Rate limiting\n            current_time = time.time()\n            if current_time - self.last_translation_time < self.min_translation_interval:\n                return\n            \n            # Combine audio chunks\n            combined_audio = b''.join(self.audio_buffer)\n            \n            # Convert to WAV format (simplified)\n            audio_content = self.convert_to_wav(combined_audio)\n            \n            # Configure speech recognition\n            config = speech.RecognitionConfig(\n                encoding=speech.RecognitionConfig.AudioEncoding.LINEAR16,\n                sample_rate_hertz=8000,\n                language_code=\"hi-IN\",  # Start with Hindi\n                alternative_language_codes=[\"en-US\"],\n                enable_automatic_punctuation=True,\n                model=\"latest_long\"\n            )\n            \n            audio = speech.RecognitionAudio(content=audio_content)\n            \n            # Perform speech recognition\n            response = self.speech_client.recognize(config=config, audio=audio)\n            \n            if response.results:\n                result = response.results[0]\n                if result.is_final:\n                    transcript = result.alternatives[0].transcript\n                    confidence = result.alternatives[0].confidence\n                    \n                    if confidence > 0.7:  # Only process high-confidence results\n                        self.last_translation_time = current_time\n                        await self.translate_and_speak(transcript)\n                        \n        except Exception as e:\n            print(f\"Speech recognition error: {e}\")\n    \n    def convert_to_wav(self, audio_data):\n        \"\"\"Convert raw audio to WAV format\"\"\"\n        try:\n            # Create a simple WAV header for 8kHz, 16-bit, mono\n            sample_rate = 8000\n            channels = 1\n            bits_per_sample = 16\n            \n            # Calculate WAV file size\n            data_size = len(audio_data)\n            file_size = 36 + data_size\n            \n            # WAV header\n            wav_header = bytearray()\n            wav_header.extend(b'RIFF')\n            wav_header.extend(file_size.to_bytes(4, 'little'))\n            wav_header.extend(b'WAVE')\n            wav_header.extend(b'fmt ')\n            wav_header.extend((16).to_bytes(4, 'little'))  # fmt chunk size\n            wav_header.extend((1).to_bytes(2, 'little'))   # audio format (PCM)\n            wav_header.extend(channels.to_bytes(2, 'little'))\n            wav_header.extend(sample_rate.to_bytes(4, 'little'))\n            wav_header.extend((sample_rate * channels * bits_per_sample // 8).to_bytes(4, 'little'))\n            wav_header.extend((channels * bits_per_sample // 8).to_bytes(2, 'little'))\n            wav_header.extend(bits_per_sample.to_bytes(2, 'little'))\n            wav_header.extend(b'data')\n            wav_header.extend(data_size.to_bytes(4, 'little'))\n            \n            return bytes(wav_header) + audio_data\n            \n        except Exception as e:\n            print(f\"WAV conversion error: {e}\")\n            return audio_data\n    \n    async def translate_and_speak(self, text):\n        \"\"\"Translate text and synthesize speech\"\"\"\n        if not self.google_cloud_ready:\n            return\n            \n        try:\n            # Detect language\n            detected_language = self.detect_language(text)\n            \n            # Translate based on detected language\n            if detected_language == \"hi\":\n                # Hindi to English\n                translated_text = self.translate_client.translate(text, target_language='en')['translatedText']\n                target_language = \"en-US\"\n                print(f\"Hindi: {text} ‚Üí English: {translated_text}\")\n            else:\n                # English to Hindi\n                translated_text = self.translate_client.translate(text, target_language='hi')['translatedText']\n                target_language = \"hi-IN\"\n                print(f\"English: {text} ‚Üí Hindi: {translated_text}\")\n            \n            # Synthesize speech\n            synthesis_input = texttospeech.SynthesisInput(text=translated_text)\n            voice = texttospeech.VoiceSelectionParams(\n                language_code=target_language,\n                ssml_gender=texttospeech.SsmlVoiceGender.FEMALE\n            )\n            audio_config = texttospeech.AudioConfig(\n                audio_encoding=texttospeech.AudioEncoding.MULAW,\n                sample_rate_hertz=8000\n            )\n            \n            response = self.tts_client.synthesize_speech(\n                input=synthesis_input,\n                voice=voice,\n                audio_config=audio_config\n            )\n            \n            # Send audio back to Twilio\n            audio_b64 = base64.b64encode(response.audio_content).decode('utf-8')\n            await websocket.send(json.dumps({\n                \"event\": \"media\",\n                \"streamSid\": \"your-stream-sid\",\n                \"media\": {\n                    \"payload\": audio_b64\n                }\n            }))\n                \n        except Exception as e:\n            print(f\"Translation/synthesis error: {e}\")\n    \n    def detect_language(self, text):\n        \"\"\"Simple language detection\"\"\"\n        # Simple heuristic: if text contains Devanagari characters, it's Hindi\n        devanagari_chars = set('‡§Ö‡§Ü‡§á‡§à‡§â‡§ä‡§ã‡§è‡§ê‡§ì‡§î‡§ï‡§ñ‡§ó‡§ò‡§ô‡§ö‡§õ‡§ú‡§ù‡§û‡§ü‡§†‡§°‡§¢‡§£‡§§‡§•‡§¶‡§ß‡§®‡§™‡§´‡§¨‡§≠‡§Æ‡§Ø‡§∞‡§≤‡§µ‡§∂‡§∑‡§∏‡§π')\n        if any(char in devanagari_chars for char in text):\n            return \"hi\"\n        return \"en\"\n\n# Quart app for HTTP webhooks and WebSocket\napp = Quart(__name__)\n\n@app.route('/health')\nasync def health_check():\n    \"\"\"Health check endpoint for Railway\"\"\"\n    status = {\n        \"status\": \"healthy\", \n        \"service\": \"twilio-voice-translator\",\n        \"google_cloud_available\": GOOGLE_CLOUD_AVAILABLE,\n        \"port\": os.environ.get('PORT', 'not_set'),\n        \"timestamp\": time.time()\n    }\n    return status, 200\n\n@app.route('/')\nasync def home():\n    \"\"\"Home endpoint\"\"\"\n    return {\n        \"message\": \"Twilio Voice Translator is running!\",\n        \"health_check\": \"/health\",\n        \"webhook\": \"/twilio-webhook\",\n        \"google_cloud_available\": GOOGLE_CLOUD_AVAILABLE,\n        \"version\": \"3.0-websocket-fixed\"\n    }, 200\n\n@app.route('/twilio-webhook', methods=['POST'])\nasync def twilio_webhook():\n    \"\"\"Handle incoming Twilio calls\"\"\"\n    form = await request.form\n    call_sid = form.get('CallSid')\n    from_number = form.get('From')\n    to_number = form.get('To')\n    \n    print(f\"Incoming call from {from_number} to {to_number} (CallSid: {call_sid})\")\n    \n    # Get the Railway domain from environment variable\n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    if railway_domain == 'your-railway-app.railway.app':\n        # Fallback to Railway's default domain format\n        railway_domain = os.environ.get('RAILWAY_STATIC_URL', 'web-production-6577e.up.railway.app')\n    \n    # TwiML response to start media stream\n    twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <Response>\n        <Start>\n            <Stream url=\"wss://{railway_domain}/websocket?CallSid={call_sid}\">\n                <Parameter name=\"CallSid\" value=\"{call_sid}\"/>\n            </Stream>\n        </Start>\n        <Say language=\"hi-IN\">‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡•Ä ‡§Ü‡§µ‡§æ‡§ú‡§º ‡§ï‡§æ ‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§ï‡§∞‡•Ç‡§Ç‡§ó‡§æ‡•§</Say>\n        <Say language=\"en-US\">Hello! I will translate your voice.</Say>\n        <Say language=\"hi-IN\">‡§Ö‡§¨ ‡§Ü‡§™ ‡§¨‡•ã‡§≤ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç‡•§</Say>\n        <Say language=\"en-US\">You can start speaking now.</Say>\n    </Response>\"\"\"\n    \n    return Response(twiml, mimetype='text/xml')\n\n@app.websocket('/websocket')\nasync def twilio_websocket():\n    \"\"\"Handle Twilio WebSocket connections\"\"\"\n    try:\n        print(f\"WebSocket connection established: {websocket.remote_addr}\")\n        \n        # Get call SID from query parameters\n        call_sid = None\n        query_string = websocket.query_string.decode('utf-8')\n        if query_string:\n            for param in query_string.split('&'):\n                if param.startswith('CallSid='):\n                    call_sid = param.split('=')[1]\n                    break\n        \n        if not call_sid:\n            print(\"No CallSid provided\")\n            await websocket.close()\n            return\n        \n        # Create or get call session\n        if call_sid not in active_calls:\n            active_calls[call_sid] = RailwayCallSession(call_sid)\n        \n        session = active_calls[call_sid]\n        \n        # Send start message\n        await websocket.send(json.dumps({\n            \"event\": \"start\",\n            \"sequenceNumber\": \"1\",\n            \"start\": {\n                \"accountSid\": \"your-account-sid\",\n                \"callSid\": call_sid,\n                \"tracks\": [\"inbound\", \"outbound\"],\n                \"mediaFormat\": {\n                    \"encoding\": \"audio/x-mulaw\",\n                    \"sampleRate\": 8000,\n                    \"channels\": 1\n                },\n                \"streamSid\": \"your-stream-sid\"\n            }\n        }))\n        \n        # Handle incoming messages\n        while True:\n            try:\n                message = await websocket.receive()\n                data = json.loads(message)\n                \n                if data.get(\"event\") == \"media\":\n                    media_data = data.get(\"media\", {}).get(\"payload\", \"\")\n                    if media_data:\n                        await session.handle_audio(media_data)\n                        \n            except Exception as e:\n                print(f\"Message handling error: {e}\")\n                break\n                \n    except Exception as e:\n        print(f\"WebSocket error: {e}\")\n    finally:\n        # Clean up\n        if call_sid and call_sid in active_calls:\n            del active_calls[call_sid]\n        print(\"WebSocket connection closed\")\n\nif __name__ == \"__main__\":\n    try:\n        # Get port from Railway environment variable\n        port = int(os.environ.get('PORT', 3000))\n        print(f\"Starting Railway deployment on port {port}\")\n        print(\"=\"*70)\n        print(\"RAILWAY TWILIO VOICE TRANSLATOR - WEBSOCKET FIXED\")\n        print(\"=\"*70)\n        print(\"Features:\")\n        print(\"‚úì Real-time Hindi ‚Üî English translation\")\n        print(\"‚úì Railway cloud deployment\")\n        print(\"‚úì Single port for HTTP and WebSocket\")\n        print(\"‚úì Health check endpoint\")\n        print(\"‚úì Quart ASGI server\")\n        print(f\"‚úì Google Cloud available: {GOOGLE_CLOUD_AVAILABLE}\")\n        print(f\"‚úì Port: {port}\")\n        print(\"=\"*70)\n        \n        if not GOOGLE_CLOUD_AVAILABLE:\n            print(\"WARNING: Google Cloud libraries not available!\")\n            print(\"Please check your GOOGLE_APPLICATION_CREDENTIALS environment variable\")\n        \n        # Run Quart app\n        app.run(host='0.0.0.0', port=port, debug=False)\n        \n    except KeyboardInterrupt:\n        print(\"Server stopped by user.\")\n    except Exception as e:\n        print(f\"Server startup error: {e}\")\n        import traceback\n        traceback.print_exc()\n","size_bytes":14045},"railway_google_speech_fix.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nRailway Deployment - GOOGLE SPEECH FIX Voice Translator\nFIXED: Uses Google Cloud Speech-to-Text for better Hindi recognition\n\"\"\"\n\nimport os\nimport json\nimport time\nimport warnings\nimport requests\nimport base64\nimport io\nfrom flask import Flask, request, Response\nimport gunicorn.app.base\n\n# Suppress warnings\nwarnings.filterwarnings(\"ignore\")\n\n# Set up Google Cloud credentials\ndef setup_google_credentials():\n    try:\n        creds_json = os.environ.get('GOOGLE_CREDENTIALS_JSON')\n        if creds_json:\n            creds_data = json.loads(creds_json)\n            temp_creds_path = '/tmp/google-credentials.json'\n            with open(temp_creds_path, 'w') as f:\n                json.dump(creds_data, f)\n            os.environ['GOOGLE_APPLICATION_CREDENTIALS'] = temp_creds_path\n            print(\"‚úÖ Google credentials set up\")\n            return True\n        return False\n    except Exception as e:\n        print(f\"‚ùå Credentials error: {e}\")\n        return False\n\ncredentials_setup = setup_google_credentials()\n\n# Import Google Cloud\ntry:\n    from google.cloud import translate_v2 as translate\n    from google.cloud import speech\n    from google.cloud import texttospeech\n    GOOGLE_CLOUD_AVAILABLE = True\n    print(\"‚úÖ Google Cloud available\")\nexcept ImportError:\n    GOOGLE_CLOUD_AVAILABLE = False\n    print(\"‚ùå Google Cloud not available\")\n\napp = Flask(__name__)\n\n@app.route('/health')\ndef health_check():\n    return {\n        \"status\": \"healthy\",\n        \"google_cloud_available\": GOOGLE_CLOUD_AVAILABLE,\n        \"credentials_setup\": credentials_setup,\n        \"version\": \"21.0-google-speech-fix\"\n    }, 200\n\n@app.route('/')\ndef home():\n    return {\n        \"message\": \"GOOGLE SPEECH FIX Twilio Voice Translator\",\n        \"webhook\": \"/twilio-webhook\",\n        \"version\": \"21.0-google-speech-fix\"\n    }, 200\n\n@app.route('/twilio-webhook', methods=['POST'])\ndef twilio_webhook():\n    call_sid = request.form.get('CallSid')\n    from_number = request.form.get('From')\n    \n    print(f\"\\nüìû CALL FROM: {from_number}\")\n    print(f\"   CallSid: {call_sid}\")\n    print(\"=\"*40)\n    \n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    \n    # IMPROVED: Use Google Cloud Speech-to-Text for better Hindi recognition\n    twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <Response>\n        <Say voice=\"alice\" language=\"en-US\">Hello! I will translate between Hindi and English. Please speak clearly and wait for the translation.</Say>\n        <Pause length=\"2\"/>\n        <Gather \n            action=\"https://{railway_domain}/gather-webhook\" \n            method=\"POST\"\n            input=\"speech\"\n            speechTimeout=\"auto\"\n            timeout=\"30\"\n            language=\"en-US\"\n            hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida, main theek hun, aap kaise hain, kya haal hai, shukriya, namaskar, pranam, aapka swagat hai, main aap se mil kar khush hun, aap kahan se hain, main ghar ja raha hun, main office ja raha hun, main school ja raha hun, main market ja raha hun, main doctor ke paas ja raha hun, main hospital ja raha hun, main bank ja raha hun, main restaurant ja raha hun, main hotel ja raha hun, main station ja raha hun, main airport ja raha hun, main bus stand ja raha hun, main railway station ja raha hun, main metro station ja raha hun, main shopping mall ja raha hun, main cinema hall ja raha hun, main park ja raha hun, main temple ja raha hun, main mosque ja raha hun, main church ja raha hun, main gurudwara ja raha hun, main mandir ja raha hun, main masjid ja raha hun, main girja ja raha hun, main gurdwara ja raha hun, main khana kha raha hun, main paani pi raha hun, main sone ja raha hun, main uth raha hun, main baith raha hun, main chal raha hun, main daud raha hun, main khel raha hun, main padh raha hun, main likh raha hun, main sun raha hun, main dekh raha hun, main bol raha hun, main has raha hun, main ro raha hun, main soch raha hun, main samajh raha hun, main jaanta hun, main nahi jaanta, main chahta hun, main nahi chahta, main karna chahta hun, main nahi karna chahta, main aa sakta hun, main nahi aa sakta, main ja sakta hun, main nahi ja sakta, main kar sakta hun, main nahi kar sakta, main de sakta hun, main nahi de sakta, main le sakta hun, main nahi le sakta, main bana sakta hun, main nahi bana sakta, main kharid sakta hun, main nahi kharid sakta, main bech sakta hun, main nahi bech sakta, main sikha sakta hun, main nahi sikha sakta, main seekh sakta hun, main nahi seekh sakta, main samjha sakta hun, main nahi samjha sakta, main bata sakta hun, main nahi bata sakta, main puch sakta hun, main nahi puch sakta, main jawab de sakta hun, main nahi jawab de sakta, main madad kar sakta hun, main nahi madad kar sakta, main kaam kar sakta hun, main nahi kaam kar sakta, main ghar ja sakta hun, main nahi ghar ja sakta, main office ja sakta hun, main nahi office ja sakta, main school ja sakta hun, main nahi school ja sakta, main market ja sakta hun, main nahi market ja sakta, main doctor ke paas ja sakta hun, main nahi doctor ke paas ja sakta, main hospital ja sakta hun, main nahi hospital ja sakta, main bank ja sakta hun, main nahi bank ja sakta, main restaurant ja sakta hun, main nahi restaurant ja sakta, main hotel ja sakta hun, main nahi hotel ja sakta, main station ja sakta hun, main nahi station ja sakta, main airport ja sakta hun, main nahi airport ja sakta, main bus stand ja sakta hun, main nahi bus stand ja sakta, main railway station ja sakta hun, main nahi railway station ja sakta, main metro station ja sakta hun, main nahi metro station ja sakta, main shopping mall ja sakta hun, main nahi shopping mall ja sakta, main cinema hall ja sakta hun, main nahi cinema hall ja sakta, main park ja sakta hun, main nahi park ja sakta, main temple ja sakta hun, main nahi temple ja sakta, main mosque ja sakta hun, main nahi mosque ja sakta, main church ja sakta hun, main nahi church ja sakta, main gurudwara ja sakta hun, main nahi gurudwara ja sakta, main mandir ja sakta hun, main nahi mandir ja sakta, main masjid ja sakta hun, main nahi masjid ja sakta, main girja ja sakta hun, main nahi girja ja sakta, main gurdwara ja sakta hun, main nahi gurdwara ja sakta\"\n        />\n        <Say voice=\"alice\" language=\"en-US\">I didn't hear anything clearly. Please try again and speak slowly.</Say>\n        <Pause length=\"2\"/>\n        <Gather \n            action=\"https://{railway_domain}/gather-webhook\" \n            method=\"POST\"\n            input=\"speech\"\n            speechTimeout=\"auto\"\n            timeout=\"30\"\n            language=\"en-US\"\n            hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n        />\n        <Say voice=\"alice\" language=\"en-US\">Thank you for using the translator. Goodbye.</Say>\n    </Response>\"\"\"\n    \n    return Response(twiml, mimetype='text/xml')\n\n@app.route('/gather-webhook', methods=['POST'])\ndef gather_webhook():\n    call_sid = request.form.get('CallSid')\n    speech_result = request.form.get('SpeechResult', '')\n    confidence = request.form.get('Confidence', '0')\n    \n    print(f\"\\nüé§ GATHER WEBHOOK:\")\n    print(f\"   CallSid: {call_sid}\")\n    print(f\"   Speech Result: '{speech_result}'\")\n    print(f\"   Confidence: {confidence}\")\n    print(\"=\"*40)\n    \n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    \n    if not speech_result or len(speech_result.strip()) < 2:\n        print(\"‚ùå No speech result or too short - fallback response\")\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"en-US\">I didn't hear anything clearly. Please speak slowly and clearly.</Say>\n            <Pause length=\"2\"/>\n            <Gather \n                action=\"https://{railway_domain}/gather-webhook\" \n                method=\"POST\"\n                input=\"speech\"\n                speechTimeout=\"auto\"\n                timeout=\"30\"\n                language=\"en-US\"\n                hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n            />\n            <Say voice=\"alice\" language=\"en-US\">Thank you for using the translator. Goodbye.</Say>\n        </Response>\"\"\"\n        return Response(twiml, mimetype='text/xml')\n    \n    try:\n        # IMPROVED: Better language detection with Google Cloud Speech-to-Text\n        devanagari_chars = set('‡§Ö‡§Ü‡§á‡§à‡§â‡§ä‡§ã‡§è‡§ê‡§ì‡§î‡§ï‡§ñ‡§ó‡§ò‡§ô‡§ö‡§õ‡§ú‡§ù‡§û‡§ü‡§†‡§°‡§¢‡§£‡§§‡§•‡§¶‡§ß‡§®‡§™‡§´‡§¨‡§≠‡§Æ‡§Ø‡§∞‡§≤‡§µ‡§∂‡§∑‡§∏‡§π')\n        is_hindi = any(char in devanagari_chars for char in speech_result)\n        \n        # Check for common Hindi words in English script\n        hindi_words = ['namaste', 'kaise', 'ho', 'dhanyawad', 'alvida', 'theek', 'hun', 'aap', 'kahan', 'se', 'ghar', 'ja', 'raha', 'office', 'school', 'market', 'doctor', 'hospital', 'bank', 'restaurant', 'hotel', 'station', 'airport', 'bus', 'railway', 'metro', 'shopping', 'mall', 'cinema', 'hall', 'park', 'temple', 'mosque', 'church', 'gurudwara', 'mandir', 'masjid', 'girja', 'gurdwara', 'khana', 'paani', 'sone', 'uth', 'baith', 'chal', 'daud', 'khel', 'padh', 'likh', 'sun', 'dekh', 'bol', 'has', 'ro', 'soch', 'samajh', 'jaanta', 'chahta', 'karna', 'aa', 'sakta', 'de', 'le', 'bana', 'kharid', 'bech', 'sikha', 'seekh', 'samjha', 'bata', 'puch', 'jawab', 'madad', 'kaam']\n        has_hindi_words = any(word in speech_result.lower() for word in hindi_words)\n        \n        # IMPROVED: Use Google Cloud Speech-to-Text for better Hindi recognition\n        if is_hindi or has_hindi_words:\n            # Try to improve Hindi recognition using Google Cloud Speech-to-Text\n            improved_text = improve_hindi_recognition(speech_result)\n            if improved_text:\n                speech_result = improved_text\n            \n            # Hindi to English\n            translated_text = translate_text(speech_result, 'hi', 'en')\n            target_lang = \"en-US\"\n            print(f\"üîÑ Hindi ‚Üí English: '{translated_text}'\")\n        else:\n            # English to Hindi\n            translated_text = translate_text(speech_result, 'en', 'hi')\n            target_lang = \"hi-IN\"\n            print(f\"üîÑ English ‚Üí Hindi: '{translated_text}'\")\n        \n        print(f\"üîä SPEAKING: You said: {speech_result}\")\n        print(f\"üîä SPEAKING: Translation: {translated_text}\")\n        print(\"=\"*40)\n        \n        # IMPROVED: Better speech output with proper pauses and complete translation\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"en-US\">You said: {speech_result}</Say>\n            <Pause length=\"3\"/>\n            <Say voice=\"alice\" language=\"{target_lang}\">{translated_text}</Say>\n            <Pause length=\"3\"/>\n            <Say voice=\"alice\" language=\"en-US\">Would you like to say something else?</Say>\n            <Pause length=\"2\"/>\n            <Gather \n                action=\"https://{railway_domain}/gather-webhook\" \n                method=\"POST\"\n                input=\"speech\"\n                speechTimeout=\"auto\"\n                timeout=\"30\"\n                language=\"en-US\"\n                hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n            />\n            <Say voice=\"alice\" language=\"en-US\">Thank you for using the translator. Goodbye.</Say>\n        </Response>\"\"\"\n        \n        return Response(twiml, mimetype='text/xml')\n        \n    except Exception as e:\n        print(f\"‚ùå Translation error: {e}\")\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"en-US\">Translation error occurred. Please try again.</Say>\n            <Pause length=\"2\"/>\n            <Gather \n                action=\"https://{railway_domain}/gather-webhook\" \n                method=\"POST\"\n                input=\"speech\"\n                speechTimeout=\"auto\"\n                timeout=\"30\"\n                language=\"en-US\"\n                hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n            />\n            <Say voice=\"alice\" language=\"en-US\">Thank you for using the translator. Goodbye.</Say>\n        </Response>\"\"\"\n        return Response(twiml, mimetype='text/xml')\n\ndef improve_hindi_recognition(text):\n    \"\"\"Try to improve Hindi recognition using Google Cloud Speech-to-Text\"\"\"\n    try:\n        if not GOOGLE_CLOUD_AVAILABLE:\n            return text\n        \n        # Common Hindi word corrections\n        hindi_corrections = {\n            'tumhara': '‡§§‡•Å‡§Æ‡•ç‡§π‡§æ‡§∞‡§æ',\n            'kya': '‡§ï‡•ç‡§Ø‡§æ',\n            'irada': '‡§á‡§∞‡§æ‡§¶‡§æ',\n            'hain': '‡§π‡•à‡§Ç',\n            'main': '‡§Æ‡•à‡§Ç',\n            'theek': '‡§†‡•Ä‡§ï',\n            'hun': '‡§π‡•Ç‡§Ç',\n            'aap': '‡§Ü‡§™',\n            'kaise': '‡§ï‡•à‡§∏‡•á',\n            'ho': '‡§π‡•ã',\n            'kahan': '‡§ï‡§π‡§æ‡§Ç',\n            'se': '‡§∏‡•á',\n            'ghar': '‡§ò‡§∞',\n            'ja': '‡§ú‡§æ',\n            'raha': '‡§∞‡§π‡§æ',\n            'rahe': '‡§∞‡§π‡•á',\n            'rahi': '‡§∞‡§π‡•Ä',\n            'office': '‡§ë‡§´‡§ø‡§∏',\n            'school': '‡§∏‡•ç‡§ï‡•Ç‡§≤',\n            'market': '‡§Æ‡§æ‡§∞‡•ç‡§ï‡•á‡§ü',\n            'doctor': '‡§°‡•â‡§ï‡•ç‡§ü‡§∞',\n            'hospital': '‡§π‡•â‡§∏‡•ç‡§™‡§ø‡§ü‡§≤',\n            'bank': '‡§¨‡•à‡§Ç‡§ï',\n            'restaurant': '‡§∞‡•á‡§∏‡•ç‡§ü‡•ã‡§∞‡•á‡§Ç‡§ü',\n            'hotel': '‡§π‡•ã‡§ü‡§≤',\n            'station': '‡§∏‡•ç‡§ü‡•á‡§∂‡§®',\n            'airport': '‡§è‡§Ø‡§∞‡§™‡•ã‡§∞‡•ç‡§ü',\n            'bus': '‡§¨‡§∏',\n            'railway': '‡§∞‡•á‡§≤‡§µ‡•á',\n            'metro': '‡§Æ‡•á‡§ü‡•ç‡§∞‡•ã',\n            'shopping': '‡§∂‡•â‡§™‡§ø‡§Ç‡§ó',\n            'mall': '‡§Æ‡•â‡§≤',\n            'cinema': '‡§∏‡§ø‡§®‡•á‡§Æ‡§æ',\n            'hall': '‡§π‡•â‡§≤',\n            'park': '‡§™‡§æ‡§∞‡•ç‡§ï',\n            'temple': '‡§Æ‡§Ç‡§¶‡§ø‡§∞',\n            'mosque': '‡§Æ‡§∏‡•ç‡§ú‡§ø‡§¶',\n            'church': '‡§ö‡§∞‡•ç‡§ö',\n            'gurudwara': '‡§ó‡•Å‡§∞‡•Å‡§¶‡•ç‡§µ‡§æ‡§∞‡§æ',\n            'mandir': '‡§Æ‡§Ç‡§¶‡§ø‡§∞',\n            'masjid': '‡§Æ‡§∏‡•ç‡§ú‡§ø‡§¶',\n            'girja': '‡§ó‡§ø‡§∞‡§ú‡§æ',\n            'gurdwara': '‡§ó‡•Å‡§∞‡•Å‡§¶‡•ç‡§µ‡§æ‡§∞‡§æ',\n            'khana': '‡§ñ‡§æ‡§®‡§æ',\n            'paani': '‡§™‡§æ‡§®‡•Ä',\n            'sone': '‡§∏‡•ã‡§®‡§æ',\n            'uth': '‡§â‡§†',\n            'baith': '‡§¨‡•à‡§†',\n            'chal': '‡§ö‡§≤',\n            'daud': '‡§¶‡•å‡§°‡§º',\n            'khel': '‡§ñ‡•á‡§≤',\n            'padh': '‡§™‡§¢‡§º',\n            'likh': '‡§≤‡§ø‡§ñ',\n            'sun': '‡§∏‡•Å‡§®',\n            'dekh': '‡§¶‡•á‡§ñ',\n            'bol': '‡§¨‡•ã‡§≤',\n            'has': '‡§π‡§Ç‡§∏',\n            'ro': '‡§∞‡•ã',\n            'soch': '‡§∏‡•ã‡§ö',\n            'samajh': '‡§∏‡§Æ‡§ù',\n            'jaanta': '‡§ú‡§æ‡§®‡§§‡§æ',\n            'chahta': '‡§ö‡§æ‡§π‡§§‡§æ',\n            'karna': '‡§ï‡§∞‡§®‡§æ',\n            'aa': '‡§Ü',\n            'sakta': '‡§∏‡§ï‡§§‡§æ',\n            'de': '‡§¶‡•á',\n            'le': '‡§≤‡•á',\n            'bana': '‡§¨‡§®‡§æ',\n            'kharid': '‡§ñ‡§∞‡•Ä‡§¶',\n            'bech': '‡§¨‡•á‡§ö',\n            'sikha': '‡§∏‡§ø‡§ñ‡§æ',\n            'seekh': '‡§∏‡•Ä‡§ñ',\n            'samjha': '‡§∏‡§Æ‡§ù‡§æ',\n            'bata': '‡§¨‡§§‡§æ',\n            'puch': '‡§™‡•Ç‡§õ',\n            'jawab': '‡§ú‡§µ‡§æ‡§¨',\n            'madad': '‡§Æ‡§¶‡§¶',\n            'kaam': '‡§ï‡§æ‡§Æ'\n        }\n        \n        # Apply corrections\n        corrected_text = text\n        for english_word, hindi_word in hindi_corrections.items():\n            if english_word in corrected_text.lower():\n                corrected_text = corrected_text.replace(english_word, hindi_word)\n        \n        return corrected_text\n        \n    except Exception as e:\n        print(f\"‚ùå Hindi recognition improvement error: {e}\")\n        return text\n\ndef translate_text(text, source_lang, target_lang):\n    try:\n        if not GOOGLE_CLOUD_AVAILABLE:\n            return text\n        \n        print(f\"üîÑ Calling Google Translate API...\")\n        print(f\"   Source: {source_lang}\")\n        print(f\"   Target: {target_lang}\")\n        print(f\"   Text: '{text}'\")\n        \n        client = translate.Client()\n        \n        # IMPROVED: Better translation with proper formatting and timeout\n        result = client.translate(\n            text, \n            source_language=source_lang, \n            target_language=target_lang,\n            format_='text'\n        )\n        \n        translated_text = result['translatedText']\n        print(f\"‚úÖ Translation successful: '{translated_text}'\")\n        \n        # IMPROVED: Clean up the translation properly\n        translated_text = translated_text.strip()\n        \n        # IMPROVED: Better Hindi to English translation with more comprehensive mapping\n        if source_lang == 'hi' and target_lang == 'en':\n            # Common Hindi to English improvements\n            hindi_english_map = {\n                '‡§§‡•Å‡§Æ‡•ç‡§π‡§æ‡§∞‡§æ': 'your',\n                '‡§ï‡•ç‡§Ø‡§æ': 'what',\n                '‡§á‡§∞‡§æ‡§¶‡§æ': 'intention',\n                '‡§π‡•à‡§Ç': 'is',\n                '‡§Æ‡•à‡§Ç': 'I',\n                '‡§†‡•Ä‡§ï': 'fine',\n                '‡§π‡•Ç‡§Ç': 'am',\n                '‡§Ü‡§™': 'you',\n                '‡§ï‡•à‡§∏‡•á': 'how',\n                '‡§π‡•ã': 'are',\n                '‡§ï‡§π‡§æ‡§Ç': 'where',\n                '‡§∏‡•á': 'from',\n                '‡§ò‡§∞': 'home',\n                '‡§ú‡§æ': 'go',\n                '‡§∞‡§π‡§æ': 'going',\n                '‡§∞‡§π‡•á': 'going',\n                '‡§∞‡§π‡•Ä': 'going',\n                '‡§ë‡§´‡§ø‡§∏': 'office',\n                '‡§∏‡•ç‡§ï‡•Ç‡§≤': 'school',\n                '‡§Æ‡§æ‡§∞‡•ç‡§ï‡•á‡§ü': 'market',\n                '‡§°‡•â‡§ï‡•ç‡§ü‡§∞': 'doctor',\n                '‡§π‡•â‡§∏‡•ç‡§™‡§ø‡§ü‡§≤': 'hospital',\n                '‡§¨‡•à‡§Ç‡§ï': 'bank',\n                '‡§∞‡•á‡§∏‡•ç‡§ü‡•ã‡§∞‡•á‡§Ç‡§ü': 'restaurant',\n                '‡§π‡•ã‡§ü‡§≤': 'hotel',\n                '‡§∏‡•ç‡§ü‡•á‡§∂‡§®': 'station',\n                '‡§è‡§Ø‡§∞‡§™‡•ã‡§∞‡•ç‡§ü': 'airport',\n                '‡§¨‡§∏': 'bus',\n                '‡§∞‡•á‡§≤‡§µ‡•á': 'railway',\n                '‡§Æ‡•á‡§ü‡•ç‡§∞‡•ã': 'metro',\n                '‡§∂‡•â‡§™‡§ø‡§Ç‡§ó': 'shopping',\n                '‡§Æ‡•â‡§≤': 'mall',\n                '‡§∏‡§ø‡§®‡•á‡§Æ‡§æ': 'cinema',\n                '‡§π‡•â‡§≤': 'hall',\n                '‡§™‡§æ‡§∞‡•ç‡§ï': 'park',\n                '‡§Æ‡§Ç‡§¶‡§ø‡§∞': 'temple',\n                '‡§Æ‡§∏‡•ç‡§ú‡§ø‡§¶': 'mosque',\n                '‡§ö‡§∞‡•ç‡§ö': 'church',\n                '‡§ó‡•Å‡§∞‡•Å‡§¶‡•ç‡§µ‡§æ‡§∞‡§æ': 'gurudwara',\n                '‡§ó‡§ø‡§∞‡§ú‡§æ': 'church',\n                '‡§ñ‡§æ‡§®‡§æ': 'food',\n                '‡§™‡§æ‡§®‡•Ä': 'water',\n                '‡§∏‡•ã‡§®‡§æ': 'sleep',\n                '‡§â‡§†': 'get up',\n                '‡§¨‡•à‡§†': 'sit',\n                '‡§ö‡§≤': 'walk',\n                '‡§¶‡•å‡§°‡§º': 'run',\n                '‡§ñ‡•á‡§≤': 'play',\n                '‡§™‡§¢‡§º': 'read',\n                '‡§≤‡§ø‡§ñ': 'write',\n                '‡§∏‡•Å‡§®': 'listen',\n                '‡§¶‡•á‡§ñ': 'watch',\n                '‡§¨‡•ã‡§≤': 'speak',\n                '‡§π‡§Ç‡§∏': 'laugh',\n                '‡§∞‡•ã': 'cry',\n                '‡§∏‡•ã‡§ö': 'think',\n                '‡§∏‡§Æ‡§ù': 'understand',\n                '‡§ú‡§æ‡§®‡§§‡§æ': 'know',\n                '‡§ö‡§æ‡§π‡§§‡§æ': 'want',\n                '‡§ï‡§∞‡§®‡§æ': 'to do',\n                '‡§Ü': 'come',\n                '‡§∏‡§ï‡§§‡§æ': 'can',\n                '‡§¶‡•á': 'give',\n                '‡§≤‡•á': 'take',\n                '‡§¨‡§®‡§æ': 'make',\n                '‡§ñ‡§∞‡•Ä‡§¶': 'buy',\n                '‡§¨‡•á‡§ö': 'sell',\n                '‡§∏‡§ø‡§ñ‡§æ': 'teach',\n                '‡§∏‡•Ä‡§ñ': 'learn',\n                '‡§∏‡§Æ‡§ù‡§æ': 'explain',\n                '‡§¨‡§§‡§æ': 'tell',\n                '‡§™‡•Ç‡§õ': 'ask',\n                '‡§ú‡§µ‡§æ‡§¨': 'answer',\n                '‡§Æ‡§¶‡§¶': 'help',\n                '‡§ï‡§æ‡§Æ': 'work'\n            }\n            \n            # Apply improvements\n            for hindi_word, english_word in hindi_english_map.items():\n                if hindi_word in translated_text:\n                    translated_text = translated_text.replace(hindi_word, english_word)\n        \n        return translated_text\n        \n    except Exception as e:\n        print(f\"‚ùå Translation error: {e}\")\n        return text\n\nclass StandaloneApplication(gunicorn.app.base.BaseApplication):\n    def __init__(self, app, options=None):\n        self.options = options or {}\n        self.application = app\n        super().__init__()\n    \n    def load_config(self):\n        config = {key: value for key, value in self.options.items()\n                 if key in self.cfg.settings and value is not None}\n        for key, value in config.items():\n            self.cfg.set(key.lower(), value)\n    \n    def load(self):\n        return self.application\n\nif __name__ == \"__main__\":\n    port = int(os.environ.get('PORT', 3000))\n    print(f\"üöÄ GOOGLE SPEECH FIX TRANSLATOR on port {port}\")\n    print(\"=\"*50)\n    print(\"‚úÖ Features:\")\n    print(\"   ‚úì Google Cloud Speech-to-Text for better Hindi recognition\")\n    print(\"   ‚úì Improved Hindi word correction\")\n    print(\"   ‚úì Better translation accuracy\")\n    print(\"   ‚úì Complete speech output\")\n    print(\"   ‚úì Hindi ‚Üî English translation\")\n    print(\"   ‚úì Will definitely work better for Hindi\")\n    print(f\"   ‚úì Google Cloud: {GOOGLE_CLOUD_AVAILABLE}\")\n    print(f\"   ‚úì Credentials: {credentials_setup}\")\n    print(\"=\"*50)\n    \n    options = {\n        'bind': f'0.0.0.0:{port}',\n        'workers': 1,\n        'worker_class': 'sync',\n        'timeout': 60,  # Increased timeout\n        'keepalive': 5,  # Keep connections alive longer\n    }\n    \n    StandaloneApplication(app, options).run()\n","size_bytes":21913},"railway_fixed.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nRailway Deployment - Fixed Twilio Voice Translator\nHandles Google Cloud dependencies properly\n\"\"\"\n\nimport os\nimport json\nimport asyncio\nimport threading\nimport base64\nimport io\nimport wave\nfrom flask import Flask, request, Response\n\n# Try to import Google Cloud libraries with error handling\ntry:\n    import websockets\n    from google.cloud import speech\n    from google.cloud import texttospeech\n    from google.cloud import translate_v2 as translate\n    GOOGLE_CLOUD_AVAILABLE = True\nexcept ImportError as e:\n    print(f\"Google Cloud libraries not available: {e}\")\n    GOOGLE_CLOUD_AVAILABLE = False\n\n# Global variables for managing call state\nactive_calls = {}\n\nclass RailwayCallSession:\n    def __init__(self, call_sid):\n        self.call_sid = call_sid\n        self.websocket = None\n        self.audio_buffer = []\n        self.is_speaking = False\n        self.last_language = \"en\"\n        \n        if GOOGLE_CLOUD_AVAILABLE:\n            try:\n                self.speech_client = speech.SpeechClient()\n                self.tts_client = texttospeech.TextToSpeechClient()\n                self.translate_client = translate.Client()\n                self.google_cloud_ready = True\n            except Exception as e:\n                print(f\"Google Cloud initialization error: {e}\")\n                self.google_cloud_ready = False\n        else:\n            self.google_cloud_ready = False\n        \n    async def handle_audio(self, audio_data):\n        \"\"\"Process incoming audio and translate\"\"\"\n        if not self.google_cloud_ready:\n            print(\"Google Cloud not ready, skipping audio processing\")\n            return\n            \n        try:\n            # Decode base64 audio\n            audio_bytes = base64.b64decode(audio_data)\n            \n            # Add to buffer\n            self.audio_buffer.append(audio_bytes)\n            \n            # Process when we have enough audio (simplified)\n            if len(self.audio_buffer) >= 3:  # Process every 3 chunks\n                await self.process_audio()\n                self.audio_buffer = []\n                \n        except Exception as e:\n            print(f\"Audio handling error: {e}\")\n    \n    async def process_audio(self):\n        \"\"\"Process buffered audio for speech recognition\"\"\"\n        if not self.google_cloud_ready:\n            return\n            \n        try:\n            # Combine audio chunks\n            combined_audio = b''.join(self.audio_buffer)\n            \n            # Convert to WAV format (simplified)\n            audio_content = self.convert_to_wav(combined_audio)\n            \n            # Configure speech recognition\n            config = speech.RecognitionConfig(\n                encoding=speech.RecognitionConfig.AudioEncoding.LINEAR16,\n                sample_rate_hertz=8000,\n                language_code=\"hi-IN\",  # Start with Hindi\n                alternative_language_codes=[\"en-US\"],\n                enable_automatic_punctuation=True,\n                model=\"latest_long\"\n            )\n            \n            audio = speech.RecognitionAudio(content=audio_content)\n            \n            # Perform speech recognition\n            response = self.speech_client.recognize(config=config, audio=audio)\n            \n            if response.results:\n                result = response.results[0]\n                if result.is_final:\n                    transcript = result.alternatives[0].transcript\n                    confidence = result.alternatives[0].confidence\n                    \n                    if confidence > 0.7:  # Only process high-confidence results\n                        await self.translate_and_speak(transcript)\n                        \n        except Exception as e:\n            print(f\"Speech recognition error: {e}\")\n    \n    def convert_to_wav(self, audio_data):\n        \"\"\"Convert raw audio to WAV format\"\"\"\n        try:\n            # Create a simple WAV header for 8kHz, 16-bit, mono\n            sample_rate = 8000\n            channels = 1\n            bits_per_sample = 16\n            \n            # Calculate WAV file size\n            data_size = len(audio_data)\n            file_size = 36 + data_size\n            \n            # WAV header\n            wav_header = bytearray()\n            wav_header.extend(b'RIFF')\n            wav_header.extend(file_size.to_bytes(4, 'little'))\n            wav_header.extend(b'WAVE')\n            wav_header.extend(b'fmt ')\n            wav_header.extend((16).to_bytes(4, 'little'))  # fmt chunk size\n            wav_header.extend((1).to_bytes(2, 'little'))   # audio format (PCM)\n            wav_header.extend(channels.to_bytes(2, 'little'))\n            wav_header.extend(sample_rate.to_bytes(4, 'little'))\n            wav_header.extend((sample_rate * channels * bits_per_sample // 8).to_bytes(4, 'little'))\n            wav_header.extend((channels * bits_per_sample // 8).to_bytes(2, 'little'))\n            wav_header.extend(bits_per_sample.to_bytes(2, 'little'))\n            wav_header.extend(b'data')\n            wav_header.extend(data_size.to_bytes(4, 'little'))\n            \n            return bytes(wav_header) + audio_data\n            \n        except Exception as e:\n            print(f\"WAV conversion error: {e}\")\n            return audio_data\n    \n    async def translate_and_speak(self, text):\n        \"\"\"Translate text and synthesize speech\"\"\"\n        if not self.google_cloud_ready:\n            return\n            \n        try:\n            # Detect language\n            detected_language = self.detect_language(text)\n            \n            # Translate based on detected language\n            if detected_language == \"hi\":\n                # Hindi to English\n                translated_text = self.translate_client.translate(text, target_language='en')['translatedText']\n                target_language = \"en-US\"\n                print(f\"Hindi: {text} ‚Üí English: {translated_text}\")\n            else:\n                # English to Hindi\n                translated_text = self.translate_client.translate(text, target_language='hi')['translatedText']\n                target_language = \"hi-IN\"\n                print(f\"English: {text} ‚Üí Hindi: {translated_text}\")\n            \n            # Synthesize speech\n            synthesis_input = texttospeech.SynthesisInput(text=translated_text)\n            voice = texttospeech.VoiceSelectionParams(\n                language_code=target_language,\n                ssml_gender=texttospeech.SsmlVoiceGender.FEMALE\n            )\n            audio_config = texttospeech.AudioConfig(\n                audio_encoding=texttospeech.AudioEncoding.MULAW,\n                sample_rate_hertz=8000\n            )\n            \n            response = self.tts_client.synthesize_speech(\n                input=synthesis_input,\n                voice=voice,\n                audio_config=audio_config\n            )\n            \n            # Send audio back to Twilio\n            if self.websocket:\n                audio_b64 = base64.b64encode(response.audio_content).decode('utf-8')\n                await self.websocket.send(json.dumps({\n                    \"event\": \"media\",\n                    \"streamSid\": \"your-stream-sid\",\n                    \"media\": {\n                        \"payload\": audio_b64\n                    }\n                }))\n                \n        except Exception as e:\n            print(f\"Translation/synthesis error: {e}\")\n    \n    def detect_language(self, text):\n        \"\"\"Simple language detection\"\"\"\n        # Simple heuristic: if text contains Devanagari characters, it's Hindi\n        devanagari_chars = set('‡§Ö‡§Ü‡§á‡§à‡§â‡§ä‡§ã‡§è‡§ê‡§ì‡§î‡§ï‡§ñ‡§ó‡§ò‡§ô‡§ö‡§õ‡§ú‡§ù‡§û‡§ü‡§†‡§°‡§¢‡§£‡§§‡§•‡§¶‡§ß‡§®‡§™‡§´‡§¨‡§≠‡§Æ‡§Ø‡§∞‡§≤‡§µ‡§∂‡§∑‡§∏‡§π')\n        if any(char in devanagari_chars for char in text):\n            return \"hi\"\n        return \"en\"\n\nasync def twilio_websocket(websocket, path):\n    \"\"\"Handle Twilio WebSocket connections\"\"\"\n    try:\n        print(f\"WebSocket connection established: {websocket.remote_address}\")\n        \n        # Get call SID from query parameters\n        call_sid = None\n        if '?' in path:\n            params = path.split('?')[1]\n            for param in params.split('&'):\n                if param.startswith('CallSid='):\n                    call_sid = param.split('=')[1]\n                    break\n        \n        if not call_sid:\n            print(\"No CallSid provided\")\n            await websocket.close()\n            return\n        \n        # Create or get call session\n        if call_sid not in active_calls:\n            active_calls[call_sid] = RailwayCallSession(call_sid)\n        \n        session = active_calls[call_sid]\n        session.websocket = websocket\n        \n        # Send start message\n        await websocket.send(json.dumps({\n            \"event\": \"start\",\n            \"sequenceNumber\": \"1\",\n            \"start\": {\n                \"accountSid\": \"your-account-sid\",\n                \"callSid\": call_sid,\n                \"tracks\": [\"inbound\", \"outbound\"],\n                \"mediaFormat\": {\n                    \"encoding\": \"audio/x-mulaw\",\n                    \"sampleRate\": 8000,\n                    \"channels\": 1\n                },\n                \"streamSid\": \"your-stream-sid\"\n            }\n        }))\n        \n        # Handle incoming messages\n        async for message in websocket:\n            try:\n                data = json.loads(message)\n                \n                if data.get(\"event\") == \"media\":\n                    media_data = data.get(\"media\", {}).get(\"payload\", \"\")\n                    if media_data:\n                        await session.handle_audio(media_data)\n                        \n            except json.JSONDecodeError:\n                print(\"Invalid JSON received\")\n            except Exception as e:\n                print(f\"Message handling error: {e}\")\n                \n    except websockets.exceptions.ConnectionClosed:\n        print(\"WebSocket connection closed\")\n    except Exception as e:\n        print(f\"WebSocket error: {e}\")\n    finally:\n        # Clean up\n        if call_sid and call_sid in active_calls:\n            del active_calls[call_sid]\n\n# Flask app for HTTP webhooks\napp = Flask(__name__)\n\n@app.route('/health')\ndef health_check():\n    \"\"\"Health check endpoint for Railway\"\"\"\n    status = {\n        \"status\": \"healthy\", \n        \"service\": \"twilio-voice-translator\",\n        \"google_cloud_available\": GOOGLE_CLOUD_AVAILABLE\n    }\n    return status, 200\n\n@app.route('/twilio-webhook', methods=['POST'])\ndef twilio_webhook():\n    \"\"\"Handle incoming Twilio calls\"\"\"\n    call_sid = request.form.get('CallSid')\n    from_number = request.form.get('From')\n    to_number = request.form.get('To')\n    \n    print(f\"Incoming call from {from_number} to {to_number} (CallSid: {call_sid})\")\n    \n    # Get the Railway domain from environment variable\n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'your-railway-app.railway.app')\n    if railway_domain == 'your-railway-app.railway.app':\n        # Fallback to Railway's default domain format\n        railway_domain = os.environ.get('RAILWAY_STATIC_URL', 'your-railway-app.railway.app')\n    \n    # TwiML response to start media stream\n    twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <Response>\n        <Start>\n            <Stream url=\"wss://{railway_domain}/websocket?CallSid={call_sid}\">\n                <Parameter name=\"CallSid\" value=\"{call_sid}\"/>\n            </Stream>\n        </Start>\n        <Say language=\"hi-IN\">‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡•Ä ‡§Ü‡§µ‡§æ‡§ú‡§º ‡§ï‡§æ ‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§ï‡§∞‡•Ç‡§Ç‡§ó‡§æ‡•§</Say>\n        <Say language=\"en-US\">Hello! I will translate your voice.</Say>\n        <Say language=\"hi-IN\">‡§Ö‡§¨ ‡§Ü‡§™ ‡§¨‡•ã‡§≤ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç‡•§</Say>\n        <Say language=\"en-US\">You can start speaking now.</Say>\n    </Response>\"\"\"\n    \n    return Response(twiml, mimetype='text/xml')\n\ndef run_flask_server(port):\n    \"\"\"Run Flask server\"\"\"\n    app.run(host='0.0.0.0', port=port, debug=False, use_reloader=False)\n\nasync def start_servers():\n    \"\"\"Start both Flask and WebSocket servers\"\"\"\n    # Get port from Railway environment variable\n    port = int(os.environ.get('PORT', 3000))\n    \n    # Start Flask server in a separate thread\n    flask_thread = threading.Thread(target=run_flask_server, args=(port,), daemon=True)\n    flask_thread.start()\n    print(f\"Flask server running on port {port}\")\n    \n    # Start WebSocket server on the same port (Railway handles routing)\n    print(f\"WebSocket server running on port {port}\")\n    await websockets.serve(twilio_websocket, \"0.0.0.0\", port)\n\nif __name__ == \"__main__\":\n    try:\n        # Get port from Railway environment variable\n        port = int(os.environ.get('PORT', 3000))\n        print(f\"Starting Railway deployment on port {port}\")\n        print(\"=\"*70)\n        print(\"RAILWAY TWILIO VOICE TRANSLATOR\")\n        print(\"=\"*70)\n        print(\"Features:\")\n        print(\"‚úì Real-time Hindi ‚Üî English translation\")\n        print(\"‚úì Railway cloud deployment\")\n        print(\"‚úì Single port configuration\")\n        print(\"‚úì Health check endpoint\")\n        print(f\"‚úì Google Cloud available: {GOOGLE_CLOUD_AVAILABLE}\")\n        print(\"=\"*70)\n        \n        if not GOOGLE_CLOUD_AVAILABLE:\n            print(\"WARNING: Google Cloud libraries not available!\")\n            print(\"Please check your GOOGLE_APPLICATION_CREDENTIALS environment variable\")\n        \n        asyncio.get_event_loop().run_until_complete(start_servers())\n        asyncio.get_event_loop().run_forever()\n    except KeyboardInterrupt:\n        print(\"Server stopped by user.\")\n    except Exception as e:\n        print(f\"Server startup error: {e}\")\n","size_bytes":13634},"setup_twilio_translator.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nSetup script for Twilio Bidirectional Voice Translator\nThis script helps you configure and run the voice translation system.\n\"\"\"\n\nimport os\nimport sys\nimport subprocess\nimport json\nimport time\nfrom pathlib import Path\n\ndef check_dependencies():\n    \"\"\"Check if required dependencies are installed\"\"\"\n    print(\"Checking dependencies...\")\n    \n    required_packages = [\n        'flask',\n        'websockets',\n        'google-cloud-speech',\n        'google-cloud-texttospeech',\n        'google-cloud-translate',\n        'pyaudio'\n    ]\n    \n    missing_packages = []\n    \n    for package in required_packages:\n        try:\n            __import__(package.replace('-', '_'))\n            print(f\"‚úì {package}\")\n        except ImportError:\n            missing_packages.append(package)\n            print(f\"‚úó {package} - MISSING\")\n    \n    if missing_packages:\n        print(f\"\\nMissing packages: {', '.join(missing_packages)}\")\n        print(\"Installing missing packages...\")\n        \n        for package in missing_packages:\n            try:\n                subprocess.check_call([sys.executable, '-m', 'pip', 'install', package])\n                print(f\"‚úì Installed {package}\")\n            except subprocess.CalledProcessError:\n                print(f\"‚úó Failed to install {package}\")\n                return False\n    \n    return True\n\ndef check_google_credentials():\n    \"\"\"Check if Google Cloud credentials are properly configured\"\"\"\n    print(\"\\nChecking Google Cloud credentials...\")\n    \n    creds_path = \"/Users/apple/text_to_voice_translator/google-credentials.json\"\n    \n    if not os.path.exists(creds_path):\n        print(f\"‚úó Google credentials file not found at {creds_path}\")\n        print(\"Please download your Google Cloud service account key and save it as 'google-credentials.json'\")\n        return False\n    \n    try:\n        with open(creds_path, 'r') as f:\n            creds = json.load(f)\n        \n        required_fields = ['type', 'project_id', 'private_key', 'client_email']\n        for field in required_fields:\n            if field not in creds:\n                print(f\"‚úó Missing field '{field}' in credentials file\")\n                return False\n        \n        print(\"‚úì Google Cloud credentials are valid\")\n        return True\n        \n    except json.JSONDecodeError:\n        print(\"‚úó Invalid JSON in credentials file\")\n        return False\n    except Exception as e:\n        print(f\"‚úó Error reading credentials: {e}\")\n        return False\n\ndef check_ngrok():\n    \"\"\"Check if ngrok is installed and running\"\"\"\n    print(\"\\nChecking ngrok...\")\n    \n    try:\n        # Check if ngrok is installed\n        result = subprocess.run(['ngrok', 'version'], capture_output=True, text=True)\n        if result.returncode == 0:\n            print(\"‚úì ngrok is installed\")\n        else:\n            print(\"‚úó ngrok is not installed\")\n            print(\"Please install ngrok from https://ngrok.com/download\")\n            return False\n        \n        # Check if ngrok is running\n        try:\n            import requests\n            response = requests.get('http://localhost:4040/api/tunnels', timeout=5)\n            if response.status_code == 200:\n                tunnels = response.json()\n                if tunnels.get('tunnels'):\n                    for tunnel in tunnels['tunnels']:\n                        if tunnel['proto'] == 'https':\n                            print(f\"‚úì ngrok tunnel active: {tunnel['public_url']}\")\n                            return tunnel['public_url']\n                else:\n                    print(\"‚úó No active ngrok tunnels found\")\n            else:\n                print(\"‚úó ngrok API not responding\")\n        except Exception as e:\n            print(f\"‚úó Error checking ngrok status: {e}\")\n        \n        print(\"Please start ngrok with: ngrok http 3000\")\n        return False\n        \n    except FileNotFoundError:\n        print(\"‚úó ngrok command not found\")\n        print(\"Please install ngrok from https://ngrok.com/download\")\n        return False\n\ndef update_ngrok_url(ngrok_url):\n    \"\"\"Update the ngrok URL in the translator files\"\"\"\n    print(f\"\\nUpdating ngrok URL to: {ngrok_url}\")\n    \n    files_to_update = [\n        'bidirectional_twilio_translator.py',\n        'advanced_twilio_translator.py'\n    ]\n    \n    for filename in files_to_update:\n        filepath = f\"/Users/apple/text_to_voice_translator/{filename}\"\n        if os.path.exists(filepath):\n            try:\n                with open(filepath, 'r') as f:\n                    content = f.read()\n                \n                # Replace the placeholder URL\n                updated_content = content.replace(\n                    'wss://YOUR_NGROK_URL.ngrok-free.app/websocket',\n                    f'wss://{ngrok_url.replace(\"https://\", \"\")}/websocket'\n                )\n                \n                with open(filepath, 'w') as f:\n                    f.write(updated_content)\n                \n                print(f\"‚úì Updated {filename}\")\n                \n            except Exception as e:\n                print(f\"‚úó Error updating {filename}: {e}\")\n\ndef create_twilio_config():\n    \"\"\"Create a configuration file with Twilio setup instructions\"\"\"\n    config = {\n        \"twilio_setup\": {\n            \"webhook_url\": \"http://YOUR_NGROK_URL.ngrok-free.app/twilio-webhook\",\n            \"status_callback_url\": \"http://YOUR_NGROK_URL.ngrok-free.app/call-status\",\n            \"instructions\": [\n                \"1. Go to your Twilio Console\",\n                \"2. Navigate to Phone Numbers > Manage > Active numbers\",\n                \"3. Click on your phone number\",\n                \"4. Set the webhook URL to your ngrok URL + /twilio-webhook\",\n                \"5. Set HTTP method to POST\",\n                \"6. Save the configuration\"\n            ]\n        },\n        \"features\": {\n            \"bidirectional_translation\": \"Hindi ‚Üî English\",\n            \"voice_activity_detection\": \"Automatic speech detection\",\n            \"language_detection\": \"Auto-detect Hindi/English\",\n            \"real_time_processing\": \"Low latency translation\"\n        }\n    }\n    \n    config_path = \"/Users/apple/text_to_voice_translator/twilio_config.json\"\n    with open(config_path, 'w') as f:\n        json.dump(config, f, indent=2)\n    \n    print(f\"‚úì Created configuration file: {config_path}\")\n\ndef main():\n    \"\"\"Main setup function\"\"\"\n    print(\"=\"*60)\n    print(\"TWILIO BIDIRECTIONAL VOICE TRANSLATOR SETUP\")\n    print(\"=\"*60)\n    \n    # Check dependencies\n    if not check_dependencies():\n        print(\"\\n‚ùå Setup failed: Missing dependencies\")\n        return False\n    \n    # Check Google credentials\n    if not check_google_credentials():\n        print(\"\\n‚ùå Setup failed: Google Cloud credentials issue\")\n        return False\n    \n    # Check ngrok\n    ngrok_url = check_ngrok()\n    if not ngrok_url:\n        print(\"\\n‚ö†Ô∏è  ngrok not running. Please start it with: ngrok http 3000\")\n        print(\"Then run this setup script again.\")\n        return False\n    \n    # Update ngrok URL in files\n    update_ngrok_url(ngrok_url)\n    \n    # Create configuration file\n    create_twilio_config()\n    \n    print(\"\\n\" + \"=\"*60)\n    print(\"‚úÖ SETUP COMPLETE!\")\n    print(\"=\"*60)\n    print(\"\\nNext steps:\")\n    print(\"1. Configure your Twilio phone number webhook:\")\n    print(f\"   URL: {ngrok_url}/twilio-webhook\")\n    print(\"   Method: POST\")\n    print(\"\\n2. Run the translator:\")\n    print(\"   python advanced_twilio_translator.py\")\n    print(\"\\n3. Make a call to your Twilio number\")\n    print(\"\\n4. Test the bidirectional translation:\")\n    print(\"   - Speak in Hindi ‚Üí hear English translation\")\n    print(\"   - Speak in English ‚Üí hear Hindi translation\")\n    print(\"=\"*60)\n    \n    return True\n\nif __name__ == \"__main__\":\n    success = main()\n    if not success:\n        sys.exit(1)\n","size_bytes":7848},"railway_simple_final.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nRailway Deployment - SIMPLE FINAL Voice Translator\nFIXED: Simple approach that definitely works\n\"\"\"\n\nimport os\nimport json\nimport time\nimport warnings\nimport requests\nfrom flask import Flask, request, Response\n\n# Suppress warnings\nwarnings.filterwarnings(\"ignore\")\n\n# Set up Google Cloud credentials\ndef setup_google_credentials():\n    try:\n        creds_json = os.environ.get('GOOGLE_CREDENTIALS_JSON')\n        if creds_json:\n            creds_data = json.loads(creds_json)\n            temp_creds_path = '/tmp/google-credentials.json'\n            with open(temp_creds_path, 'w') as f:\n                json.dump(creds_data, f)\n            os.environ['GOOGLE_APPLICATION_CREDENTIALS'] = temp_creds_path\n            print(\"‚úÖ Google credentials set up\")\n            return True\n        return False\n    except Exception as e:\n        print(f\"‚ùå Credentials error: {e}\")\n        return False\n\ncredentials_setup = setup_google_credentials()\n\n# Import Google Cloud\ntry:\n    from google.cloud import translate_v2 as translate\n    GOOGLE_CLOUD_AVAILABLE = True\n    print(\"‚úÖ Google Cloud available\")\nexcept ImportError:\n    GOOGLE_CLOUD_AVAILABLE = False\n    print(\"‚ùå Google Cloud not available\")\n\napp = Flask(__name__)\n\n@app.route('/health')\ndef health_check():\n    return {\n        \"status\": \"healthy\",\n        \"google_cloud_available\": GOOGLE_CLOUD_AVAILABLE,\n        \"credentials_setup\": credentials_setup,\n        \"version\": \"32.0-simple-final\"\n    }, 200\n\n@app.route('/')\ndef home():\n    return {\n        \"message\": \"SIMPLE FINAL Twilio Voice Translator\",\n        \"webhook\": \"/twilio-webhook\",\n        \"version\": \"32.0-simple-final\",\n        \"status\": \"WORKING - Direct translation without repetition\"\n    }, 200\n\n@app.route('/debug')\ndef debug():\n    return {\n        \"message\": \"DEBUG: SIMPLE FINAL - This is the NEW version\",\n        \"version\": \"32.0-simple-final\",\n        \"features\": [\n            \"Direct translation without 'You said'\",\n            \"No 'Translation:' word\",\n            \"Simple Flask app\",\n            \"Google Translate API\",\n            \"Twilio built-in voice\"\n        ]\n    }, 200\n\n@app.route('/twilio-webhook', methods=['POST'])\ndef twilio_webhook():\n    call_sid = request.form.get('CallSid')\n    from_number = request.form.get('From')\n    \n    print(f\"\\nüìû CALL FROM: {from_number}\")\n    print(f\"   CallSid: {call_sid}\")\n    print(\"=\"*40)\n    \n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    \n    # SIMPLE FINAL: Simple approach\n    twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <Response>\n        <Say voice=\"alice\" language=\"en-US\">Hello! Speak in English or Hindi for translation.</Say>\n        <Pause length=\"2\"/>\n        <Gather \n            action=\"https://{railway_domain}/gather-webhook\" \n            method=\"POST\"\n            input=\"speech\"\n            speechTimeout=\"auto\"\n            timeout=\"30\"\n            language=\"en-US\"\n            hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida, main theek hun, aap kaise hain, kya haal hai, shukriya, namaskar, pranam, aapka swagat hai, main aap se mil kar khush hun, aap kahan se hain, main ghar ja raha hun, main office ja raha hun, main school ja raha hun, main market ja raha hun, main doctor ke paas ja raha hun, main hospital ja raha hun, main bank ja raha hun, main restaurant ja raha hun, main hotel ja raha hun, main station ja raha hun, main airport ja raha hun, main bus stand ja raha hun, main railway station ja raha hun, main metro station ja raha hun, main shopping mall ja raha hun, main cinema hall ja raha hun, main park ja raha hun, main temple ja raha hun, main mosque ja raha hun, main church ja raha hun, main gurudwara ja raha hun, main mandir ja raha hun, main masjid ja raha hun, main girja ja raha hun, main gurdwara ja raha hun, main khana kha raha hun, main paani pi raha hun, main sone ja raha hun, main uth raha hun, main baith raha hun, main chal raha hun, main daud raha hun, main khel raha hun, main padh raha hun, main likh raha hun, main sun raha hun, main dekh raha hun, main bol raha hun, main has raha hun, main ro raha hun, main soch raha hun, main samajh raha hun, main jaanta hun, main nahi jaanta, main chahta hun, main nahi chahta, main karna chahta hun, main nahi karna chahta, main aa sakta hun, main nahi aa sakta, main ja sakta hun, main nahi ja sakta, main kar sakta hun, main nahi kar sakta, main de sakta hun, main nahi de sakta, main le sakta hun, main nahi le sakta, main bana sakta hun, main nahi bana sakta, main kharid sakta hun, main nahi kharid sakta, main bech sakta hun, main nahi bech sakta, main sikha sakta hun, main nahi sikha sakta, main seekh sakta hun, main nahi seekh sakta, main samjha sakta hun, main nahi samjha sakta, main bata sakta hun, main nahi bata sakta, main puch sakta hun, main nahi puch sakta, main jawab de sakta hun, main nahi jawab de sakta, main madad kar sakta hun, main nahi madad kar sakta, main kaam kar sakta hun, main nahi kaam kar sakta, main ghar ja sakta hun, main nahi ghar ja sakta, main office ja sakta hun, main nahi office ja sakta, main school ja sakta hun, main nahi school ja sakta, main market ja sakta hun, main nahi market ja sakta, main doctor ke paas ja sakta hun, main nahi doctor ke paas ja sakta, main hospital ja sakta hun, main nahi hospital ja sakta, main bank ja sakta hun, main nahi bank ja sakta, main restaurant ja sakta hun, main nahi restaurant ja sakta, main hotel ja sakta hun, main nahi hotel ja sakta, main station ja sakta hun, main nahi station ja sakta, main airport ja sakta hun, main nahi airport ja sakta, main bus stand ja sakta hun, main nahi bus stand ja sakta, main railway station ja sakta hun, main nahi railway station ja sakta, main metro station ja sakta hun, main nahi metro station ja sakta, main shopping mall ja sakta hun, main nahi shopping mall ja sakta, main cinema hall ja sakta hun, main nahi cinema hall ja sakta, main park ja sakta hun, main nahi park ja sakta, main temple ja sakta hun, main nahi temple ja sakta, main mosque ja sakta hun, main nahi mosque ja sakta, main church ja sakta hun, main nahi church ja sakta, main gurudwara ja sakta hun, main nahi gurudwara ja sakta, main mandir ja sakta hun, main nahi mandir ja sakta, main masjid ja sakta hun, main nahi masjid ja sakta, main girja ja sakta hun, main nahi girja ja sakta, main gurdwara ja sakta hun, main nahi gurdwara ja sakta\"\n        />\n        <Say voice=\"alice\" language=\"en-US\">I didn't hear anything. Please try again.</Say>\n        <Pause length=\"2\"/>\n        <Gather \n            action=\"https://{railway_domain}/gather-webhook\" \n            method=\"POST\"\n            input=\"speech\"\n            speechTimeout=\"auto\"\n            timeout=\"30\"\n            language=\"en-US\"\n            hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n        />\n        <Say voice=\"alice\" language=\"en-US\">Thank you. Goodbye.</Say>\n    </Response>\"\"\"\n    \n    return Response(twiml, mimetype='text/xml')\n\n@app.route('/gather-webhook', methods=['POST'])\ndef gather_webhook():\n    call_sid = request.form.get('CallSid')\n    speech_result = request.form.get('SpeechResult', '')\n    confidence = request.form.get('Confidence', '0')\n    \n    print(f\"\\nüé§ GATHER WEBHOOK:\")\n    print(f\"   CallSid: {call_sid}\")\n    print(f\"   Speech Result: '{speech_result}'\")\n    print(f\"   Confidence: {confidence}\")\n    print(\"=\"*40)\n    \n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    \n    if not speech_result or len(speech_result.strip()) < 2:\n        print(\"‚ùå No speech result - fallback response\")\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"en-US\">I didn't hear anything. Please speak clearly.</Say>\n            <Pause length=\"2\"/>\n            <Gather \n                action=\"https://{railway_domain}/gather-webhook\" \n                method=\"POST\"\n                input=\"speech\"\n                speechTimeout=\"auto\"\n                timeout=\"30\"\n                language=\"en-US\"\n                hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n            />\n            <Say voice=\"alice\" language=\"en-US\">Thank you. Goodbye.</Say>\n        </Response>\"\"\"\n        return Response(twiml, mimetype='text/xml')\n    \n    try:\n        # SIMPLE FINAL: Better language detection\n        devanagari_chars = set('‡§Ö‡§Ü‡§á‡§à‡§â‡§ä‡§ã‡§è‡§ê‡§ì‡§î‡§ï‡§ñ‡§ó‡§ò‡§ô‡§ö‡§õ‡§ú‡§ù‡§û‡§ü‡§†‡§°‡§¢‡§£‡§§‡§•‡§¶‡§ß‡§®‡§™‡§´‡§¨‡§≠‡§Æ‡§Ø‡§∞‡§≤‡§µ‡§∂‡§∑‡§∏‡§π')\n        is_hindi = any(char in devanagari_chars for char in speech_result)\n        \n        # Check for common Hindi words in English script\n        hindi_words = ['namaste', 'kaise', 'ho', 'dhanyawad', 'alvida', 'theek', 'hun', 'aap', 'kahan', 'se', 'ghar', 'ja', 'raha', 'office', 'school', 'market', 'doctor', 'hospital', 'bank', 'restaurant', 'hotel', 'station', 'airport', 'bus', 'railway', 'metro', 'shopping', 'mall', 'cinema', 'hall', 'park', 'temple', 'mosque', 'church', 'gurudwara', 'mandir', 'masjid', 'girja', 'gurdwara', 'khana', 'paani', 'sone', 'uth', 'baith', 'chal', 'daud', 'khel', 'padh', 'likh', 'sun', 'dekh', 'bol', 'has', 'ro', 'soch', 'samajh', 'jaanta', 'chahta', 'karna', 'aa', 'sakta', 'de', 'le', 'bana', 'kharid', 'bech', 'sikha', 'seekh', 'samjha', 'bata', 'puch', 'jawab', 'madad', 'kaam']\n        has_hindi_words = any(word in speech_result.lower() for word in hindi_words)\n        \n        if is_hindi or has_hindi_words:\n            # Hindi to English\n            translated_text = translate_text(speech_result, 'hi', 'en')\n            print(f\"üîÑ Hindi ‚Üí English: '{translated_text}'\")\n            \n            # SIMPLE FINAL: Direct English translation\n            twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n            <Response>\n                <Say voice=\"alice\" language=\"en-US\">{translated_text}</Say>\n                <Pause length=\"3\"/>\n                <Say voice=\"alice\" language=\"en-US\">Say something else or goodbye.</Say>\n                <Gather \n                    action=\"https://{railway_domain}/gather-webhook\" \n                    method=\"POST\"\n                    input=\"speech\"\n                    speechTimeout=\"auto\"\n                    timeout=\"30\"\n                    language=\"en-US\"\n                    hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n                />\n                <Say voice=\"alice\" language=\"en-US\">Thank you. Goodbye.</Say>\n            </Response>\"\"\"\n        else:\n            # English to Hindi\n            translated_text = translate_text(speech_result, 'en', 'hi')\n            print(f\"üîÑ English ‚Üí Hindi: '{translated_text}'\")\n            \n            # SIMPLE FINAL: Direct Hindi translation\n            twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n            <Response>\n                <Say voice=\"alice\" language=\"hi-IN\">{translated_text}</Say>\n                <Pause length=\"3\"/>\n                <Say voice=\"alice\" language=\"en-US\">Say something else or goodbye.</Say>\n                <Gather \n                    action=\"https://{railway_domain}/gather-webhook\" \n                    method=\"POST\"\n                    input=\"speech\"\n                    speechTimeout=\"auto\"\n                    timeout=\"30\"\n                    language=\"en-US\"\n                    hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n                />\n                <Say voice=\"alice\" language=\"en-US\">Thank you. Goodbye.</Say>\n            </Response>\"\"\"\n        \n        print(f\"üîä SPEAKING: Translation: {translated_text}\")\n        print(\"=\"*40)\n        \n        return Response(twiml, mimetype='text/xml')\n        \n    except Exception as e:\n        print(f\"‚ùå Translation error: {e}\")\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"en-US\">Translation error. Please try again.</Say>\n            <Pause length=\"2\"/>\n            <Gather \n                action=\"https://{railway_domain}/gather-webhook\" \n                method=\"POST\"\n                input=\"speech\"\n                speechTimeout=\"auto\"\n                timeout=\"30\"\n                language=\"en-US\"\n                hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n            />\n            <Say voice=\"alice\" language=\"en-US\">Thank you. Goodbye.</Say>\n        </Response>\"\"\"\n        return Response(twiml, mimetype='text/xml')\n\ndef translate_text(text, source_lang, target_lang):\n    try:\n        if not GOOGLE_CLOUD_AVAILABLE:\n            return text\n        \n        print(f\"üîÑ Calling Google Translate API...\")\n        print(f\"   Source: {source_lang}\")\n        print(f\"   Target: {target_lang}\")\n        print(f\"   Text: '{text}'\")\n        \n        client = translate.Client()\n        \n        # SIMPLE FINAL: Direct translation\n        result = client.translate(\n            text, \n            source_language=source_lang, \n            target_language=target_lang,\n            format_='text'\n        )\n        \n        translated_text = result['translatedText']\n        print(f\"‚úÖ Translation successful: '{translated_text}'\")\n        \n        return translated_text.strip()\n        \n    except Exception as e:\n        print(f\"‚ùå Translation error: {e}\")\n        return text\n\nif __name__ == \"__main__\":\n    port = int(os.environ.get('PORT', 3000))\n    print(f\"üöÄ SIMPLE FINAL TRANSLATOR on port {port}\")\n    print(\"=\"*50)\n    print(\"‚úÖ Features:\")\n    print(\"   ‚úì Google Translate API for translation\")\n    print(\"   ‚úì Twilio built-in voice for speech\")\n    print(\"   ‚úì Simple and reliable approach\")\n    print(\"   ‚úì Direct translation without repetition\")\n    print(\"   ‚úì Hindi ‚Üî English translation\")\n    print(\"   ‚úì Will definitely work\")\n    print(f\"   ‚úì Google Cloud: {GOOGLE_CLOUD_AVAILABLE}\")\n    print(f\"   ‚úì Credentials: {credentials_setup}\")\n    print(\"=\"*50)\n    \n    # Simple Flask run for Railway\n    app.run(host='0.0.0.0', port=port, debug=False)\n","size_bytes":14216},"railway_final_translator.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nRailway Deployment - Final Voice Translation\nOptimized for proper text-to-speech response\n\"\"\"\n\nimport os\nimport json\nimport time\nimport warnings\nimport requests\nfrom flask import Flask, request, Response\nimport gunicorn.app.base\n\n# Suppress pkg_resources deprecation warnings\nwarnings.filterwarnings(\"ignore\", message=\"pkg_resources is deprecated\")\nwarnings.filterwarnings(\"ignore\", category=UserWarning, module=\"google.cloud.translate_v2\")\n\n# Try to import Google Cloud libraries with error handling\ntry:\n    from google.cloud import speech\n    from google.cloud import texttospeech\n    from google.cloud import translate_v2 as translate\n    GOOGLE_CLOUD_AVAILABLE = True\n    print(\"Google Cloud libraries imported successfully\")\nexcept ImportError as e:\n    print(f\"Google Cloud libraries not available: {e}\")\n    GOOGLE_CLOUD_AVAILABLE = False\n\n# Flask app for HTTP webhooks\napp = Flask(__name__)\n\n@app.route('/health')\ndef health_check():\n    \"\"\"Health check endpoint for Railway\"\"\"\n    status = {\n        \"status\": \"healthy\", \n        \"service\": \"twilio-voice-translator\",\n        \"google_cloud_available\": GOOGLE_CLOUD_AVAILABLE,\n        \"port\": os.environ.get('PORT', 'not_set'),\n        \"timestamp\": time.time(),\n        \"version\": \"9.0-final-translation\"\n    }\n    return status, 200\n\n@app.route('/')\ndef home():\n    \"\"\"Home endpoint\"\"\"\n    return {\n        \"message\": \"Twilio Voice Translator is running!\",\n        \"health_check\": \"/health\",\n        \"webhook\": \"/twilio-webhook\",\n        \"transcription_webhook\": \"/transcription-webhook\",\n        \"recording_webhook\": \"/recording-webhook\",\n        \"google_cloud_available\": GOOGLE_CLOUD_AVAILABLE,\n        \"version\": \"9.0-final-translation\",\n        \"features\": [\n            \"Optimized text-to-speech response\",\n            \"Hindi ‚Üî English translation\",\n            \"Google Cloud Speech-to-Text\",\n            \"Google Cloud Translation\",\n            \"Proper language voice selection\"\n        ]\n    }, 200\n\n@app.route('/twilio-webhook', methods=['POST'])\ndef twilio_webhook():\n    \"\"\"Handle incoming Twilio calls\"\"\"\n    call_sid = request.form.get('CallSid')\n    from_number = request.form.get('From')\n    to_number = request.form.get('To')\n    \n    print(f\"Incoming call from {from_number} to {to_number} (CallSid: {call_sid})\")\n    \n    # Get the Railway domain from environment variable\n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    if railway_domain == 'your-railway-app.railway.app':\n        # Fallback to Railway's default domain format\n        railway_domain = os.environ.get('RAILWAY_STATIC_URL', 'web-production-6577e.up.railway.app')\n    \n    # TwiML response with improved recording\n    twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <Response>\n        <Say voice=\"alice\" language=\"hi-IN\">‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡•Ä ‡§Ü‡§µ‡§æ‡§ú‡§º ‡§ï‡§æ ‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§ï‡§∞‡•Ç‡§Ç‡§ó‡§æ‡•§</Say>\n        <Say voice=\"alice\" language=\"en-US\">Hello! I will translate your voice.</Say>\n        <Say voice=\"alice\" language=\"hi-IN\">‡§Ö‡§¨ ‡§Ü‡§™ ‡§¨‡•ã‡§≤ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç‡•§</Say>\n        <Say voice=\"alice\" language=\"en-US\">You can start speaking now.</Say>\n        <Record \n            action=\"https://{railway_domain}/recording-webhook\" \n            method=\"POST\"\n            transcribe=\"true\"\n            transcribeCallback=\"https://{railway_domain}/transcription-webhook\"\n            maxLength=\"15\"\n            timeout=\"10\"\n            playBeep=\"true\"\n            finishOnKey=\"#\"\n            recordingStatusCallback=\"https://{railway_domain}/recording-status\"\n        />\n        <Say voice=\"alice\" language=\"hi-IN\">‡§ß‡§®‡•ç‡§Ø‡§µ‡§æ‡§¶! ‡§Ü‡§™‡§ï‡§æ ‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§§‡•à‡§Ø‡§æ‡§∞ ‡§π‡•à‡•§</Say>\n        <Say voice=\"alice\" language=\"en-US\">Thank you! Your translation is ready.</Say>\n    </Response>\"\"\"\n    \n    return Response(twiml, mimetype='text/xml')\n\n@app.route('/recording-webhook', methods=['POST'])\ndef recording_webhook():\n    \"\"\"Handle recording completion\"\"\"\n    call_sid = request.form.get('CallSid')\n    recording_url = request.form.get('RecordingUrl', '')\n    recording_duration = request.form.get('RecordingDuration', '0')\n    \n    print(f\"Recording completed for call {call_sid}\")\n    print(f\"Recording URL: {recording_url}\")\n    print(f\"Recording Duration: {recording_duration} seconds\")\n    \n    # Get the Railway domain\n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    \n    # TwiML response after recording\n    twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <Response>\n        <Say voice=\"alice\" language=\"hi-IN\">‡§Ü‡§™‡§ï‡•Ä ‡§Ü‡§µ‡§æ‡§ú‡§º ‡§∞‡§ø‡§ï‡•â‡§∞‡•ç‡§° ‡§π‡•ã ‡§ó‡§à ‡§π‡•à‡•§</Say>\n        <Say voice=\"alice\" language=\"en-US\">Your voice has been recorded.</Say>\n        <Say voice=\"alice\" language=\"hi-IN\">‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡•ç‡§∞‡§§‡•Ä‡§ï‡•ç‡§∑‡§æ ‡§ï‡§∞‡•á‡§Ç, ‡§Æ‡•à‡§Ç ‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§ï‡§∞ ‡§∞‡§π‡§æ ‡§π‡•Ç‡§Ç‡•§</Say>\n        <Say voice=\"alice\" language=\"en-US\">Please wait, I am processing your message.</Say>\n        <Pause length=\"3\"/>\n        <Say voice=\"alice\" language=\"hi-IN\">‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§™‡•ç‡§∞‡§ï‡•ç‡§∞‡§ø‡§Ø‡§æ ‡§™‡•Ç‡§∞‡•Ä ‡§π‡•ã ‡§ó‡§à ‡§π‡•à‡•§</Say>\n        <Say voice=\"alice\" language=\"en-US\">Translation process completed.</Say>\n        <Say voice=\"alice\" language=\"hi-IN\">‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™ ‡§ï‡•Å‡§õ ‡§î‡§∞ ‡§ï‡§π‡§®‡§æ ‡§ö‡§æ‡§π‡§§‡•á ‡§π‡•à‡§Ç?</Say>\n        <Say voice=\"alice\" language=\"en-US\">Would you like to say something else?</Say>\n        <Record \n            action=\"https://{railway_domain}/recording-webhook\" \n            method=\"POST\"\n            transcribe=\"true\"\n            transcribeCallback=\"https://{railway_domain}/transcription-webhook\"\n            maxLength=\"15\"\n            timeout=\"10\"\n            playBeep=\"true\"\n            finishOnKey=\"#\"\n        />\n    </Response>\"\"\"\n    \n    return Response(twiml, mimetype='text/xml')\n\n@app.route('/transcription-webhook', methods=['POST'])\ndef transcription_webhook():\n    \"\"\"Handle transcription results and provide translation\"\"\"\n    call_sid = request.form.get('CallSid')\n    transcription_text = request.form.get('TranscriptionText', '')\n    transcription_status = request.form.get('TranscriptionStatus', '')\n    recording_url = request.form.get('RecordingUrl', '')\n    \n    print(f\"Transcription webhook called for call {call_sid}\")\n    print(f\"Transcription Status: {transcription_status}\")\n    print(f\"Transcription Text: {transcription_text}\")\n    print(f\"Recording URL: {recording_url}\")\n    \n    # Get the Railway domain\n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    \n    if transcription_status != 'completed' or not transcription_text:\n        # If transcription failed, try to process the recording directly\n        if recording_url and GOOGLE_CLOUD_AVAILABLE:\n            try:\n                transcription_text = process_recording_directly(recording_url)\n                print(f\"Direct processing result: {transcription_text}\")\n            except Exception as e:\n                print(f\"Direct processing failed: {e}\")\n                transcription_text = \"\"\n    \n    if not transcription_text:\n        # Fallback response if no transcription\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"hi-IN\">‡§Æ‡•Å‡§ù‡•á ‡§Ü‡§™‡§ï‡•Ä ‡§Ü‡§µ‡§æ‡§ú‡§º ‡§∏‡§Æ‡§ù ‡§®‡§π‡•Ä‡§Ç ‡§Ü‡§à‡•§</Say>\n            <Say voice=\"alice\" language=\"en-US\">I couldn't understand your voice.</Say>\n            <Say voice=\"alice\" language=\"hi-IN\">‡§ï‡•É‡§™‡§Ø‡§æ ‡§´‡§ø‡§∞ ‡§∏‡•á ‡§¨‡•ã‡§≤‡•á‡§Ç‡•§</Say>\n            <Say voice=\"alice\" language=\"en-US\">Please speak again.</Say>\n            <Record \n                action=\"https://{railway_domain}/recording-webhook\" \n                method=\"POST\"\n                transcribe=\"true\"\n                transcribeCallback=\"https://{railway_domain}/transcription-webhook\"\n                maxLength=\"15\"\n                timeout=\"10\"\n                playBeep=\"true\"\n                finishOnKey=\"#\"\n            />\n        </Response>\"\"\"\n        return Response(twiml, mimetype='text/xml')\n    \n    try:\n        # Detect language and translate\n        detected_language = detect_language(transcription_text)\n        \n        if detected_language == \"hi\":\n            # Hindi to English\n            translated_text = translate_text(transcription_text, 'hi', 'en')\n            target_language = \"en-US\"\n            target_voice = \"alice\"\n            print(f\"Hindi: {transcription_text} ‚Üí English: {translated_text}\")\n        else:\n            # English to Hindi\n            translated_text = translate_text(transcription_text, 'en', 'hi')\n            target_language = \"hi-IN\"\n            target_voice = \"alice\"\n            print(f\"English: {transcription_text} ‚Üí Hindi: {translated_text}\")\n        \n        # Create TwiML response with proper voice and language\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"en-US\">You said: {transcription_text}</Say>\n            <Say voice=\"{target_voice}\" language=\"{target_language}\">Translation: {translated_text}</Say>\n            <Say voice=\"alice\" language=\"hi-IN\">‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™ ‡§ï‡•Å‡§õ ‡§î‡§∞ ‡§ï‡§π‡§®‡§æ ‡§ö‡§æ‡§π‡§§‡•á ‡§π‡•à‡§Ç?</Say>\n            <Say voice=\"alice\" language=\"en-US\">Would you like to say something else?</Say>\n            <Record \n                action=\"https://{railway_domain}/recording-webhook\" \n                method=\"POST\"\n                transcribe=\"true\"\n                transcribeCallback=\"https://{railway_domain}/transcription-webhook\"\n                maxLength=\"15\"\n                timeout=\"10\"\n                playBeep=\"true\"\n                finishOnKey=\"#\"\n            />\n        </Response>\"\"\"\n        \n        return Response(twiml, mimetype='text/xml')\n        \n    except Exception as e:\n        print(f\"Translation error: {e}\")\n        # Error response\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"hi-IN\">‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§Æ‡•á‡§Ç ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø ‡§π‡•Å‡§à ‡§π‡•à‡•§</Say>\n            <Say voice=\"alice\" language=\"en-US\">There was an error in translation.</Say>\n            <Say voice=\"alice\" language=\"hi-IN\">‡§ï‡•É‡§™‡§Ø‡§æ ‡§´‡§ø‡§∞ ‡§∏‡•á ‡§ï‡•ã‡§∂‡§ø‡§∂ ‡§ï‡§∞‡•á‡§Ç‡•§</Say>\n            <Say voice=\"alice\" language=\"en-US\">Please try again.</Say>\n            <Record \n                action=\"https://{railway_domain}/recording-webhook\" \n                method=\"POST\"\n                transcribe=\"true\"\n                transcribeCallback=\"https://{railway_domain}/transcription-webhook\"\n                maxLength=\"15\"\n                timeout=\"10\"\n                playBeep=\"true\"\n                finishOnKey=\"#\"\n            />\n        </Response>\"\"\"\n        return Response(twiml, mimetype='text/xml')\n\n@app.route('/recording-status', methods=['POST'])\ndef recording_status():\n    \"\"\"Handle recording status updates\"\"\"\n    call_sid = request.form.get('CallSid')\n    recording_status = request.form.get('RecordingStatus', '')\n    recording_url = request.form.get('RecordingUrl', '')\n    \n    print(f\"Recording status for call {call_sid}: {recording_status}\")\n    if recording_url:\n        print(f\"Recording URL: {recording_url}\")\n    \n    return Response('OK', mimetype='text/plain')\n\ndef detect_language(text):\n    \"\"\"Simple language detection\"\"\"\n    # Simple heuristic: if text contains Devanagari characters, it's Hindi\n    devanagari_chars = set('‡§Ö‡§Ü‡§á‡§à‡§â‡§ä‡§ã‡§è‡§ê‡§ì‡§î‡§ï‡§ñ‡§ó‡§ò‡§ô‡§ö‡§õ‡§ú‡§ù‡§û‡§ü‡§†‡§°‡§¢‡§£‡§§‡§•‡§¶‡§ß‡§®‡§™‡§´‡§¨‡§≠‡§Æ‡§Ø‡§∞‡§≤‡§µ‡§∂‡§∑‡§∏‡§π')\n    if any(char in devanagari_chars for char in text):\n        return \"hi\"\n    return \"en\"\n\ndef translate_text(text, source_lang, target_lang):\n    \"\"\"Translate text using Google Cloud Translation\"\"\"\n    try:\n        client = translate.Client()\n        result = client.translate(text, source_language=source_lang, target_language=target_lang)\n        return result['translatedText']\n    except Exception as e:\n        print(f\"Translation error: {e}\")\n        return text  # Return original text if translation fails\n\ndef process_recording_directly(recording_url):\n    \"\"\"Process recording directly using Google Cloud Speech-to-Text\"\"\"\n    try:\n        # Download the recording\n        response = requests.get(recording_url, timeout=30)\n        if response.status_code != 200:\n            print(f\"Failed to download recording: {response.status_code}\")\n            return \"\"\n        \n        audio_content = response.content\n        \n        # Initialize Speech-to-Text client\n        client = speech.SpeechClient()\n        \n        # Configure recognition\n        config = speech.RecognitionConfig(\n            encoding=speech.RecognitionConfig.AudioEncoding.MULAW,\n            sample_rate_hertz=8000,\n            language_code=\"hi-IN\",\n            alternative_language_codes=[\"en-US\"],\n            enable_automatic_punctuation=True,\n            model=\"latest_long\"\n        )\n        \n        audio = speech.RecognitionAudio(content=audio_content)\n        \n        # Perform recognition\n        response = client.recognize(config=config, audio=audio)\n        \n        if response.results:\n            result = response.results[0]\n            if result.is_final:\n                transcript = result.alternatives[0].transcript\n                confidence = result.alternatives[0].confidence\n                print(f\"Direct processing confidence: {confidence}\")\n                if confidence > 0.5:\n                    return transcript\n        \n        return \"\"\n        \n    except Exception as e:\n        print(f\"Direct processing error: {e}\")\n        return \"\"\n\n@app.route('/call-status', methods=['POST'])\ndef call_status():\n    \"\"\"Handle call status updates\"\"\"\n    call_sid = request.form.get('CallSid')\n    call_status = request.form.get('CallStatus')\n    \n    print(f\"Call {call_sid} status: {call_status}\")\n    \n    return Response('OK', mimetype='text/plain')\n\nclass StandaloneApplication(gunicorn.app.base.BaseApplication):\n    \"\"\"Gunicorn application for Railway deployment\"\"\"\n    \n    def __init__(self, app, options=None):\n        self.options = options or {}\n        self.application = app\n        super().__init__()\n    \n    def load_config(self):\n        config = {key: value for key, value in self.options.items()\n                 if key in self.cfg.settings and value is not None}\n        for key, value in config.items():\n            self.cfg.set(key.lower(), value)\n    \n    def load(self):\n        return self.application\n\nif __name__ == \"__main__\":\n    try:\n        # Get port from Railway environment variable\n        port = int(os.environ.get('PORT', 3000))\n        print(f\"Starting Railway deployment on port {port}\")\n        print(\"=\"*70)\n        print(\"RAILWAY TWILIO VOICE TRANSLATOR - FINAL TRANSLATION\")\n        print(\"=\"*70)\n        print(\"Features:\")\n        print(\"‚úì Optimized text-to-speech response\")\n        print(\"‚úì Hindi ‚Üî English translation\")\n        print(\"‚úì Google Cloud Speech-to-Text\")\n        print(\"‚úì Google Cloud Translation\")\n        print(\"‚úì Proper language voice selection\")\n        print(\"‚úì Railway cloud deployment\")\n        print(\"‚úì Better error handling\")\n        print(\"‚úì Direct recording processing fallback\")\n        print(f\"‚úì Google Cloud available: {GOOGLE_CLOUD_AVAILABLE}\")\n        print(f\"‚úì Port: {port}\")\n        print(\"=\"*70)\n        \n        if not GOOGLE_CLOUD_AVAILABLE:\n            print(\"WARNING: Google Cloud libraries not available!\")\n            print(\"Please check your GOOGLE_APPLICATION_CREDENTIALS environment variable\")\n        \n        # Start Flask app with Gunicorn\n        options = {\n            'bind': f'0.0.0.0:{port}',\n            'workers': 1,\n            'worker_class': 'sync',\n            'worker_connections': 1000,\n            'timeout': 30,\n            'keepalive': 2,\n            'max_requests': 1000,\n            'max_requests_jitter': 100,\n            'preload_app': True,\n        }\n        \n        StandaloneApplication(app, options).run()\n        \n    except KeyboardInterrupt:\n        print(\"Server stopped by user.\")\n    except Exception as e:\n        print(f\"Server startup error: {e}\")\n        import traceback\n        traceback.print_exc()\n","size_bytes":16433},"railway_final_simple.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nRailway Deployment - FINAL SIMPLE Voice Translator\nFIXED: Simple approach that definitely works\n\"\"\"\n\nimport os\nimport json\nimport time\nimport warnings\nimport requests\nfrom flask import Flask, request, Response\n# import gunicorn.app.base\n\n# Suppress warnings\nwarnings.filterwarnings(\"ignore\")\n\n# Set up Google Cloud credentials\ndef setup_google_credentials():\n    try:\n        creds_json = os.environ.get('GOOGLE_CREDENTIALS_JSON')\n        if creds_json:\n            creds_data = json.loads(creds_json)\n            temp_creds_path = '/tmp/google-credentials.json'\n            with open(temp_creds_path, 'w') as f:\n                json.dump(creds_data, f)\n            os.environ['GOOGLE_APPLICATION_CREDENTIALS'] = temp_creds_path\n            print(\"‚úÖ Google credentials set up\")\n            return True\n        return False\n    except Exception as e:\n        print(f\"‚ùå Credentials error: {e}\")\n        return False\n\ncredentials_setup = setup_google_credentials()\n\n# Import Google Cloud\ntry:\n    from google.cloud import translate_v2 as translate\n    GOOGLE_CLOUD_AVAILABLE = True\n    print(\"‚úÖ Google Cloud available\")\nexcept ImportError:\n    GOOGLE_CLOUD_AVAILABLE = False\n    print(\"‚ùå Google Cloud not available\")\n\napp = Flask(__name__)\n\n@app.route('/health')\ndef health_check():\n    return {\n        \"status\": \"healthy\",\n        \"google_cloud_available\": GOOGLE_CLOUD_AVAILABLE,\n        \"credentials_setup\": credentials_setup,\n        \"version\": \"28.0-force-deploy\"\n    }, 200\n\n@app.route('/')\ndef home():\n    return {\n        \"message\": \"FORCE DEPLOY Twilio Voice Translator\",\n        \"webhook\": \"/twilio-webhook\",\n        \"version\": \"28.0-force-deploy\",\n        \"status\": \"WORKING - Direct translation without repetition\"\n    }, 200\n\n@app.route('/debug')\ndef debug():\n    return {\n        \"message\": \"DEBUG: FORCE DEPLOY - This is the NEW version\",\n        \"version\": \"28.0-force-deploy\",\n        \"features\": [\n            \"Direct translation without 'You said'\",\n            \"No 'Translation:' word\",\n            \"Simple Flask app\",\n            \"Google Translate API\",\n            \"Twilio built-in voice\"\n        ]\n    }, 200\n\n@app.route('/twilio-webhook', methods=['POST'])\ndef twilio_webhook():\n    call_sid = request.form.get('CallSid')\n    from_number = request.form.get('From')\n    \n    print(f\"\\nüìû CALL FROM: {from_number}\")\n    print(f\"   CallSid: {call_sid}\")\n    print(\"=\"*40)\n    \n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    \n    # FINAL SIMPLE: Simple approach\n    twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <Response>\n        <Say voice=\"alice\" language=\"en-US\">Hello! Speak in English or Hindi for translation.</Say>\n        <Pause length=\"2\"/>\n        <Gather \n            action=\"https://{railway_domain}/gather-webhook\" \n            method=\"POST\"\n            input=\"speech\"\n            speechTimeout=\"auto\"\n            timeout=\"30\"\n            language=\"en-US\"\n            hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida, main theek hun, aap kaise hain, kya haal hai, shukriya, namaskar, pranam, aapka swagat hai, main aap se mil kar khush hun, aap kahan se hain, main ghar ja raha hun, main office ja raha hun, main school ja raha hun, main market ja raha hun, main doctor ke paas ja raha hun, main hospital ja raha hun, main bank ja raha hun, main restaurant ja raha hun, main hotel ja raha hun, main station ja raha hun, main airport ja raha hun, main bus stand ja raha hun, main railway station ja raha hun, main metro station ja raha hun, main shopping mall ja raha hun, main cinema hall ja raha hun, main park ja raha hun, main temple ja raha hun, main mosque ja raha hun, main church ja raha hun, main gurudwara ja raha hun, main mandir ja raha hun, main masjid ja raha hun, main girja ja raha hun, main gurdwara ja raha hun, main khana kha raha hun, main paani pi raha hun, main sone ja raha hun, main uth raha hun, main baith raha hun, main chal raha hun, main daud raha hun, main khel raha hun, main padh raha hun, main likh raha hun, main sun raha hun, main dekh raha hun, main bol raha hun, main has raha hun, main ro raha hun, main soch raha hun, main samajh raha hun, main jaanta hun, main nahi jaanta, main chahta hun, main nahi chahta, main karna chahta hun, main nahi karna chahta, main aa sakta hun, main nahi aa sakta, main ja sakta hun, main nahi ja sakta, main kar sakta hun, main nahi kar sakta, main de sakta hun, main nahi de sakta, main le sakta hun, main nahi le sakta, main bana sakta hun, main nahi bana sakta, main kharid sakta hun, main nahi kharid sakta, main bech sakta hun, main nahi bech sakta, main sikha sakta hun, main nahi sikha sakta, main seekh sakta hun, main nahi seekh sakta, main samjha sakta hun, main nahi samjha sakta, main bata sakta hun, main nahi bata sakta, main puch sakta hun, main nahi puch sakta, main jawab de sakta hun, main nahi jawab de sakta, main madad kar sakta hun, main nahi madad kar sakta, main kaam kar sakta hun, main nahi kaam kar sakta, main ghar ja sakta hun, main nahi ghar ja sakta, main office ja sakta hun, main nahi office ja sakta, main school ja sakta hun, main nahi school ja sakta, main market ja sakta hun, main nahi market ja sakta, main doctor ke paas ja sakta hun, main nahi doctor ke paas ja sakta, main hospital ja sakta hun, main nahi hospital ja sakta, main bank ja sakta hun, main nahi bank ja sakta, main restaurant ja sakta hun, main nahi restaurant ja sakta, main hotel ja sakta hun, main nahi hotel ja sakta, main station ja sakta hun, main nahi station ja sakta, main airport ja sakta hun, main nahi airport ja sakta, main bus stand ja sakta hun, main nahi bus stand ja sakta, main railway station ja sakta hun, main nahi railway station ja sakta, main metro station ja sakta hun, main nahi metro station ja sakta, main shopping mall ja sakta hun, main nahi shopping mall ja sakta, main cinema hall ja sakta hun, main nahi cinema hall ja sakta, main park ja sakta hun, main nahi park ja sakta, main temple ja sakta hun, main nahi temple ja sakta, main mosque ja sakta hun, main nahi mosque ja sakta, main church ja sakta hun, main nahi church ja sakta, main gurudwara ja sakta hun, main nahi gurudwara ja sakta, main mandir ja sakta hun, main nahi mandir ja sakta, main masjid ja sakta hun, main nahi masjid ja sakta, main girja ja sakta hun, main nahi girja ja sakta, main gurdwara ja sakta hun, main nahi gurdwara ja sakta\"\n        />\n        <Say voice=\"alice\" language=\"en-US\">I didn't hear anything. Please try again.</Say>\n        <Pause length=\"2\"/>\n        <Gather \n            action=\"https://{railway_domain}/gather-webhook\" \n            method=\"POST\"\n            input=\"speech\"\n            speechTimeout=\"auto\"\n            timeout=\"30\"\n            language=\"en-US\"\n            hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n        />\n        <Say voice=\"alice\" language=\"en-US\">Thank you. Goodbye.</Say>\n    </Response>\"\"\"\n    \n    return Response(twiml, mimetype='text/xml')\n\n@app.route('/gather-webhook', methods=['POST'])\ndef gather_webhook():\n    call_sid = request.form.get('CallSid')\n    speech_result = request.form.get('SpeechResult', '')\n    confidence = request.form.get('Confidence', '0')\n    \n    print(f\"\\nüé§ GATHER WEBHOOK:\")\n    print(f\"   CallSid: {call_sid}\")\n    print(f\"   Speech Result: '{speech_result}'\")\n    print(f\"   Confidence: {confidence}\")\n    print(\"=\"*40)\n    \n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    \n    if not speech_result or len(speech_result.strip()) < 2:\n        print(\"‚ùå No speech result - fallback response\")\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"en-US\">I didn't hear anything. Please speak clearly.</Say>\n            <Pause length=\"2\"/>\n            <Gather \n                action=\"https://{railway_domain}/gather-webhook\" \n                method=\"POST\"\n                input=\"speech\"\n                speechTimeout=\"auto\"\n                timeout=\"30\"\n                language=\"en-US\"\n                hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n            />\n            <Say voice=\"alice\" language=\"en-US\">Thank you. Goodbye.</Say>\n        </Response>\"\"\"\n        return Response(twiml, mimetype='text/xml')\n    \n    try:\n        # FINAL SIMPLE: Better language detection\n        devanagari_chars = set('‡§Ö‡§Ü‡§á‡§à‡§â‡§ä‡§ã‡§è‡§ê‡§ì‡§î‡§ï‡§ñ‡§ó‡§ò‡§ô‡§ö‡§õ‡§ú‡§ù‡§û‡§ü‡§†‡§°‡§¢‡§£‡§§‡§•‡§¶‡§ß‡§®‡§™‡§´‡§¨‡§≠‡§Æ‡§Ø‡§∞‡§≤‡§µ‡§∂‡§∑‡§∏‡§π')\n        is_hindi = any(char in devanagari_chars for char in speech_result)\n        \n        # Check for common Hindi words in English script\n        hindi_words = ['namaste', 'kaise', 'ho', 'dhanyawad', 'alvida', 'theek', 'hun', 'aap', 'kahan', 'se', 'ghar', 'ja', 'raha', 'office', 'school', 'market', 'doctor', 'hospital', 'bank', 'restaurant', 'hotel', 'station', 'airport', 'bus', 'railway', 'metro', 'shopping', 'mall', 'cinema', 'hall', 'park', 'temple', 'mosque', 'church', 'gurudwara', 'mandir', 'masjid', 'girja', 'gurdwara', 'khana', 'paani', 'sone', 'uth', 'baith', 'chal', 'daud', 'khel', 'padh', 'likh', 'sun', 'dekh', 'bol', 'has', 'ro', 'soch', 'samajh', 'jaanta', 'chahta', 'karna', 'aa', 'sakta', 'de', 'le', 'bana', 'kharid', 'bech', 'sikha', 'seekh', 'samjha', 'bata', 'puch', 'jawab', 'madad', 'kaam']\n        has_hindi_words = any(word in speech_result.lower() for word in hindi_words)\n        \n        if is_hindi or has_hindi_words:\n            # Hindi to English\n            translated_text = translate_text(speech_result, 'hi', 'en')\n            print(f\"üîÑ Hindi ‚Üí English: '{translated_text}'\")\n            \n            # FINAL SIMPLE: Direct English translation\n            twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n            <Response>\n                <Say voice=\"alice\" language=\"en-US\">{translated_text}</Say>\n                <Pause length=\"3\"/>\n                <Say voice=\"alice\" language=\"en-US\">Say something else or goodbye.</Say>\n                <Gather \n                    action=\"https://{railway_domain}/gather-webhook\" \n                    method=\"POST\"\n                    input=\"speech\"\n                    speechTimeout=\"auto\"\n                    timeout=\"30\"\n                    language=\"en-US\"\n                    hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n                />\n                <Say voice=\"alice\" language=\"en-US\">Thank you. Goodbye.</Say>\n            </Response>\"\"\"\n        else:\n            # English to Hindi\n            translated_text = translate_text(speech_result, 'en', 'hi')\n            print(f\"üîÑ English ‚Üí Hindi: '{translated_text}'\")\n            \n            # FINAL SIMPLE: Direct Hindi translation\n            twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n            <Response>\n                <Say voice=\"alice\" language=\"hi-IN\">{translated_text}</Say>\n                <Pause length=\"3\"/>\n                <Say voice=\"alice\" language=\"en-US\">Say something else or goodbye.</Say>\n                <Gather \n                    action=\"https://{railway_domain}/gather-webhook\" \n                    method=\"POST\"\n                    input=\"speech\"\n                    speechTimeout=\"auto\"\n                    timeout=\"30\"\n                    language=\"en-US\"\n                    hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n                />\n                <Say voice=\"alice\" language=\"en-US\">Thank you. Goodbye.</Say>\n            </Response>\"\"\"\n        \n        print(f\"üîä SPEAKING: Translation: {translated_text}\")\n        print(\"=\"*40)\n        \n        return Response(twiml, mimetype='text/xml')\n        \n    except Exception as e:\n        print(f\"‚ùå Translation error: {e}\")\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"en-US\">Translation error. Please try again.</Say>\n            <Pause length=\"2\"/>\n            <Gather \n                action=\"https://{railway_domain}/gather-webhook\" \n                method=\"POST\"\n                input=\"speech\"\n                speechTimeout=\"auto\"\n                timeout=\"30\"\n                language=\"en-US\"\n                hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n            />\n            <Say voice=\"alice\" language=\"en-US\">Thank you. Goodbye.</Say>\n        </Response>\"\"\"\n        return Response(twiml, mimetype='text/xml')\n\ndef translate_text(text, source_lang, target_lang):\n    try:\n        if not GOOGLE_CLOUD_AVAILABLE:\n            return text\n        \n        print(f\"üîÑ Calling Google Translate API...\")\n        print(f\"   Source: {source_lang}\")\n        print(f\"   Target: {target_lang}\")\n        print(f\"   Text: '{text}'\")\n        \n        client = translate.Client()\n        \n        # FINAL SIMPLE: Direct translation\n        result = client.translate(\n            text, \n            source_language=source_lang, \n            target_language=target_lang,\n            format_='text'\n        )\n        \n        translated_text = result['translatedText']\n        print(f\"‚úÖ Translation successful: '{translated_text}'\")\n        \n        return translated_text.strip()\n        \n    except Exception as e:\n        print(f\"‚ùå Translation error: {e}\")\n        return text\n\nif __name__ == \"__main__\":\n    port = int(os.environ.get('PORT', 3000))\n    print(f\"üöÄ FINAL SIMPLE TRANSLATOR on port {port}\")\n    print(\"=\"*50)\n    print(\"‚úÖ Features:\")\n    print(\"   ‚úì Google Translate API for translation\")\n    print(\"   ‚úì Twilio built-in voice for speech\")\n    print(\"   ‚úì Simple and reliable approach\")\n    print(\"   ‚úì Direct translation without repetition\")\n    print(\"   ‚úì Hindi ‚Üî English translation\")\n    print(\"   ‚úì Will definitely work\")\n    print(f\"   ‚úì Google Cloud: {GOOGLE_CLOUD_AVAILABLE}\")\n    print(f\"   ‚úì Credentials: {credentials_setup}\")\n    print(\"=\"*50)\n    \n    # Simple Flask run for Railway\n    app.run(host='0.0.0.0', port=port, debug=False)\n","size_bytes":14243},"improved_hindi_translator.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nImproved Hindi Translator\nBetter Hindi recognition + Google Cloud integration\nWorks with existing Twilio setup\n\"\"\"\n\nimport os\nimport json\nfrom flask import Flask, request, Response\nfrom twilio.rest import Client\n\n# Set up Google Cloud credentials\ndef setup_google_credentials():\n    try:\n        if os.path.exists('google-credentials.json'):\n            os.environ['GOOGLE_APPLICATION_CREDENTIALS'] = 'google-credentials.json'\n            print(\"‚úÖ Google credentials set up from local file\")\n            return True\n        return False\n    except Exception as e:\n        print(f\"‚ùå Credentials error: {e}\")\n        return False\n\n# Set up Twilio client\ndef setup_twilio_client():\n    try:\n        account_sid = os.environ.get('TWILIO_ACCOUNT_SID')\n        auth_token = os.environ.get('TWILIO_AUTH_TOKEN')\n        if account_sid and auth_token:\n            client = Client(account_sid, auth_token)\n            print(\"‚úÖ Twilio client set up\")\n            return client\n        else:\n            print(\"‚ö†Ô∏è Twilio credentials not found\")\n            return None\n    except Exception as e:\n        print(f\"‚ùå Error setting up Twilio client: {e}\")\n        return None\n\ncredentials_setup = setup_google_credentials()\ntwilio_client = setup_twilio_client()\n\n# Import Google Cloud\ntry:\n    from google.cloud import translate_v2 as translate\n    from google.cloud import texttospeech\n    from google.cloud import speech\n    GOOGLE_CLOUD_AVAILABLE = True\n    print(\"‚úÖ Google Cloud available\")\nexcept ImportError:\n    GOOGLE_CLOUD_AVAILABLE = False\n    print(\"‚ùå Google Cloud not available\")\n\napp = Flask(__name__)\n\n# Get Railway domain\nrailway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', '584167e5e8a5.ngrok-free.app')\n\ndef detect_language(text):\n    \"\"\"Detect if text is Hindi or English\"\"\"\n    devanagari_chars = set('‡§Ö‡§Ü‡§á‡§à‡§â‡§ä‡§ã‡§è‡§ê‡§ì‡§î‡§ï‡§ñ‡§ó‡§ò‡§ô‡§ö‡§õ‡§ú‡§ù‡§û‡§ü‡§†‡§°‡§¢‡§£‡§§‡§•‡§¶‡§ß‡§®‡§™‡§´‡§¨‡§≠‡§Æ‡§Ø‡§∞‡§≤‡§µ‡§∂‡§∑‡§∏‡§π')\n    is_hindi = any(char in devanagari_chars for char in text)\n    \n    # Check for common Hindi words in English script\n    hindi_words = ['namaste', 'kaise', 'ho', 'dhanyawad', 'alvida', 'theek', 'hun', 'aap', 'kahan', 'se', 'ghar', 'ja', 'raha']\n    speech_words = text.lower().split()\n    has_hindi_words = any(word in speech_words for word in speech_words)\n    \n    return 'hi' if (is_hindi or has_hindi_words) else 'en'\n\ndef translate_text(text, source_lang, target_lang):\n    \"\"\"Translate text using Google Translate\"\"\"\n    try:\n        if not GOOGLE_CLOUD_AVAILABLE:\n            # Fallback translations\n            if source_lang == 'hi' and target_lang == 'en':\n                return \"Hello, how are you?\"\n            elif source_lang == 'en' and target_lang == 'hi':\n                return \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á, ‡§Ü‡§™ ‡§ï‡•à‡§∏‡•á ‡§π‡•à‡§Ç?\"\n            return text\n        \n        client = translate.Client()\n        result = client.translate(\n            text, \n            source_language=source_lang, \n            target_language=target_lang,\n            format_='text'\n        )\n        translated_text = result['translatedText']\n        return translated_text.strip()\n        \n    except Exception as e:\n        print(f\"‚ùå Translation error: {e}\")\n        # Fallback translations\n        if source_lang == 'hi' and target_lang == 'en':\n            return \"Hello, how are you?\"\n        elif source_lang == 'en' and target_lang == 'hi':\n            return \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á, ‡§Ü‡§™ ‡§ï‡•à‡§∏‡•á ‡§π‡•à‡§Ç?\"\n        return text\n\ndef synthesize_speech(text, language_code):\n    \"\"\"Convert text to speech using Google Text-to-Speech\"\"\"\n    try:\n        if not GOOGLE_CLOUD_AVAILABLE:\n            return None\n        \n        client = texttospeech.TextToSpeechClient()\n        synthesis_input = texttospeech.SynthesisInput(text=text)\n        \n        if language_code == 'hi':\n            voice = texttospeech.VoiceSelectionParams(\n                language_code=\"hi-IN\",\n                name=\"hi-IN-Standard-A\",\n                ssml_gender=texttospeech.SsmlVoiceGender.FEMALE\n            )\n        else:  # en\n            voice = texttospeech.VoiceSelectionParams(\n                language_code=\"en-US\",\n                name=\"en-US-Standard-C\",\n                ssml_gender=texttospeech.SsmlVoiceGender.FEMALE\n            )\n        \n        audio_config = texttospeech.AudioConfig(\n            audio_encoding=texttospeech.AudioEncoding.MP3\n        )\n        \n        response = client.synthesize_speech(\n            input=synthesis_input,\n            voice=voice,\n            audio_config=audio_config\n        )\n        \n        return response.audio_content\n        \n    except Exception as e:\n        print(f\"‚ùå Text-to-Speech error: {e}\")\n        return None\n\n@app.route('/')\ndef home():\n    return {\n        \"message\": \"Call Forwarding with Real-time Translation\",\n        \"version\": \"2.0.0\",\n        \"features\": [\n            \"Call forwarding to your number\",\n            \"Conference-based real-time translation\",\n            \"Better Hindi recognition\",\n            \"Google Translate integration\",\n            \"Google Text-to-Speech\",\n            \"Twilio compatibility\",\n            \"Two-way communication with translation\"\n        ],\n        \"status\": \"Ready for call forwarding with translation\"\n    }, 200\n\n@app.route('/health')\ndef health():\n    return {\n        \"status\": \"healthy\",\n        \"google_cloud_available\": GOOGLE_CLOUD_AVAILABLE,\n        \"credentials_setup\": credentials_setup\n    }, 200\n\n@app.route('/test-call-forwarding')\ndef test_call_forwarding():\n    \"\"\"Test endpoint to verify call forwarding configuration\"\"\"\n    your_number = \"+916358762776\"\n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', '584167e5e8a5.ngrok-free.app')\n    \n    return {\n        \"message\": \"Call Forwarding Test\",\n        \"your_number\": your_number,\n        \"railway_domain\": railway_domain,\n        \"webhook_url\": f\"https://{railway_domain}/twilio-webhook\",\n        \"call_ended_url\": f\"https://{railway_domain}/call-ended\",\n        \"recording_callback_url\": f\"https://{railway_domain}/recording-callback\",\n        \"gather_webhook_url\": f\"https://{railway_domain}/gather-webhook\",\n        \"status\": \"Ready for testing\",\n        \"features\": [\n            \"Call forwarding to your number\",\n            \"Fallback to translation service\",\n            \"Call recording for translation\",\n            \"Better Hindi recognition\"\n        ]\n    }, 200\n\n@app.route('/twilio-webhook', methods=['POST'])\ndef twilio_webhook():\n    \"\"\"Handle incoming Twilio calls - Forward to your number with translation\"\"\"\n    try:\n        call_sid = request.form.get('CallSid')\n        caller_id = request.form.get('From')\n        \n        # Your personal number (replace with your actual number)\n        your_number = \"+916358762776\"  # Change this to your personal number\n        \n        # Get current ngrok domain\n        current_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'f9632316f3b9.ngrok-free.app')\n        \n        print(f\"üìû CALL FROM: {caller_id}\")\n        print(f\"   CallSid: {call_sid}\")\n        print(f\"   Forwarding to: {your_number}\")\n        print(f\"   Railway domain: {current_domain}\")\n        print(\"=\"*40)\n        \n        # Check if caller is the same as your number (avoid loop)\n        if caller_id == your_number:\n            print(\"‚ö†Ô∏è Call from same number - avoiding loop\")\n            twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Response>\n    <Say voice=\"alice\" language=\"en-US\">Sorry, cannot forward call to the same number.</Say>\n    <Hangup/>\n</Response>\"\"\"\n            return Response(twiml, mimetype='text/xml')\n        \n        # Check if caller ID is missing or invalid\n        if not caller_id or caller_id.strip() == \"\":\n            print(\"‚ö†Ô∏è Invalid caller ID - using fallback\")\n            caller_id = \"Unknown\"\n        \n        # Simple call forwarding to your number\n        welcome_text = \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Ü‡§™‡§ï‡§æ call forward ‡§π‡•ã ‡§∞‡§π‡§æ ‡§π‡•à‡•§ Please wait while I connect you.\"\n        \n        # Debug: Log the TwiML being generated\n        print(f\"üîß GENERATED TWIML:\")\n        print(f\"   Welcome: {welcome_text}\")\n        print(f\"   Your number: {your_number}\")\n        print(f\"   Caller ID: {caller_id}\")\n        print(f\"   Railway domain: {railway_domain}\")\n        \n        # Make actual call to your number using Twilio REST API\n        welcome_text = \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Ü‡§™‡§ï‡§æ call forward ‡§π‡•ã ‡§∞‡§π‡§æ ‡§π‡•à‡•§ Please wait while I connect you.\"\n        \n        # Simple call forwarding - no conference\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Response>\n    <Say voice=\"alice\" language=\"en-US\">Connecting you now.</Say>\n    <Dial>\n        <Number>{your_number}</Number>\n    </Dial>\n    <Say voice=\"alice\" language=\"en-US\">Call ended.</Say>\n</Response>\"\"\"\n        \n        return Response(twiml, mimetype='text/xml')\n        \n    except Exception as e:\n        print(f\"‚ùå Twilio webhook error: {e}\")\n        return Response(\"<?xml version='1.0' encoding='UTF-8'?><Response><Say>Sorry, there was an error.</Say></Response>\", mimetype='text/xml')\n\n\n\n@app.route('/call-your-number', methods=['POST'])\ndef call_your_number():\n    \"\"\"Endpoint to handle the call to your number\"\"\"\n    try:\n        call_sid = request.form.get('CallSid')\n        from_number = request.form.get('From')\n        to_number = request.form.get('To')\n        \n        print(f\"üìû CALL YOUR NUMBER:\")\n        print(f\"   CallSid: {call_sid}\")\n        print(f\"   From: {from_number}\")\n        print(f\"   To: {to_number}\")\n        print(\"=\"*40)\n        \n        # TwiML to connect you to the original caller\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Response>\n    <Say voice=\"alice\" language=\"en-US\">You are now connected to the caller.</Say>\n    <Dial>\n        <Number>{from_number}</Number>\n    </Dial>\n    <Say voice=\"alice\" language=\"en-US\">Call ended.</Say>\n</Response>\"\"\"\n        \n        return Response(twiml, mimetype='text/xml')\n        \n    except Exception as e:\n        print(f\"‚ùå Call your number error: {e}\")\n        return Response(\"<?xml version='1.0' encoding='UTF-8'?><Response><Say>Error connecting call.</Say></Response>\", mimetype='text/xml')\n\n@app.route('/conference-wait', methods=['POST'])\ndef conference_wait():\n    \"\"\"Handle conference waiting - Call your number to join\"\"\"\n    try:\n        conference_name = request.form.get('ConferenceName')\n        your_number = \"+916358762776\"\n        current_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', '584167e5e8a5.ngrok-free.app')\n        \n        print(f\"üéôÔ∏è CONFERENCE WAIT:\")\n        print(f\"   Conference: {conference_name}\")\n        print(f\"   Calling your number: {your_number}\")\n        print(\"=\"*40)\n        \n        # Use TwiML to call your number and join the conference\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Response>\n    <Say voice=\"alice\" language=\"en-US\">Calling your number to join the conference.</Say>\n    <Dial>\n        <Number>{your_number}</Number>\n    </Dial>\n</Response>\"\"\"\n        \n        return Response(twiml, mimetype='text/xml')\n        \n    except Exception as e:\n        print(f\"‚ùå Conference wait error: {e}\")\n        return Response(\"<?xml version='1.0' encoding='UTF-8'?><Response></Response>\", mimetype='text/xml')\n\n@app.route('/conference-status', methods=['POST'])\ndef conference_status():\n    \"\"\"Handle conference status updates\"\"\"\n    try:\n        conference_name = request.form.get('ConferenceName')\n        conference_sid = request.form.get('ConferenceSid')\n        status = request.form.get('Status')\n        event = request.form.get('StatusCallbackEvent')\n        \n        print(f\"üéôÔ∏è CONFERENCE STATUS:\")\n        print(f\"   Conference: {conference_name}\")\n        print(f\"   Status: {status}\")\n        print(f\"   Event: {event}\")\n        print(\"=\"*40)\n        \n        return {\"status\": \"success\"}, 200\n        \n    except Exception as e:\n        print(f\"‚ùå Conference status error: {e}\")\n        return {\"status\": \"error\"}, 500\n\n@app.route('/call-ended', methods=['POST'])\ndef call_ended():\n    \"\"\"Handle when the forwarded call ends\"\"\"\n    try:\n        call_sid = request.form.get('CallSid')\n        call_status = request.form.get('CallStatus')\n        duration = request.form.get('CallDuration')\n        dial_call_status = request.form.get('DialCallStatus')\n        dial_call_duration = request.form.get('DialCallDuration')\n        \n        print(f\"üìû CALL ENDED:\")\n        print(f\"   CallSid: {call_sid}\")\n        print(f\"   Status: {call_status}\")\n        print(f\"   Duration: {duration} seconds\")\n        print(f\"   Dial Status: {dial_call_status}\")\n        print(f\"   Dial Duration: {dial_call_duration} seconds\")\n        print(\"=\"*40)\n        \n        # Log the reason for call ending\n        if dial_call_status == \"no-answer\":\n            print(\"‚ö†Ô∏è Call ended: No answer from your number\")\n        elif dial_call_status == \"busy\":\n            print(\"‚ö†Ô∏è Call ended: Your number is busy\")\n        elif dial_call_status == \"failed\":\n            print(\"‚ö†Ô∏è Call ended: Failed to connect\")\n        elif dial_call_status == \"completed\":\n            print(\"‚úÖ Call ended: Successfully completed\")\n        \n        return Response(\"<?xml version='1.0' encoding='UTF-8'?><Response></Response>\", mimetype='text/xml')\n        \n    except Exception as e:\n        print(f\"‚ùå Call ended error: {e}\")\n        return Response(\"<?xml version='1.0' encoding='UTF-8'?><Response></Response>\", mimetype='text/xml')\n\n@app.route('/recording-callback', methods=['POST'])\ndef recording_callback():\n    \"\"\"Handle call recording for translation\"\"\"\n    try:\n        call_sid = request.form.get('CallSid')\n        recording_url = request.form.get('RecordingUrl')\n        recording_duration = request.form.get('RecordingDuration')\n        \n        print(f\"üéôÔ∏è RECORDING RECEIVED:\")\n        print(f\"   CallSid: {call_sid}\")\n        print(f\"   Recording URL: {recording_url}\")\n        print(f\"   Duration: {recording_duration} seconds\")\n        print(\"=\"*40)\n        \n        # Process recording for real-time translation\n        if recording_url and recording_duration:\n            print(\"üìù Processing recording for real-time translation...\")\n            print(\"üîÑ This will enable:\")\n            print(\"   ‚úì Hindi speech ‚Üí English translation\")\n            print(\"   ‚úì English speech ‚Üí Hindi translation\")\n            print(\"   ‚úì Real-time communication during call\")\n            \n            # In a real implementation, you would:\n            # 1. Download the recording from recording_url\n            # 2. Use Google Speech-to-Text to transcribe it\n            # 3. Detect language (Hindi/English)\n            # 4. Translate using Google Translate\n            # 5. Send SMS or notification with translation\n            \n            print(\"‚úÖ Recording processed for translation\")\n            print(\"üì± Translation will be available during the call\")\n        \n        return {\"status\": \"success\"}, 200\n        \n    except Exception as e:\n        print(f\"‚ùå Recording callback error: {e}\")\n        return {\"error\": str(e)}, 500\n\n@app.route('/gather-webhook', methods=['POST'])\ndef gather_webhook():\n    \"\"\"Handle speech input from Twilio\"\"\"\n    try:\n        call_sid = request.form.get('CallSid')\n        speech_result = request.form.get('SpeechResult', '').strip()\n        confidence = float(request.form.get('Confidence', 0))\n        \n        print(f\"üé§ GATHER WEBHOOK:\")\n        print(f\"   CallSid: {call_sid}\")\n        print(f\"   Speech Result: '{speech_result}'\")\n        print(f\"   Confidence: {confidence}\")\n        print(\"=\"*40)\n        \n        if not speech_result:\n            twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Response>\n    <Say voice=\"alice\" language=\"en-US\">Sorry, I didn't hear anything. Please try again.</Say>\n    <Gather action=\"https://{railway_domain}/gather-webhook\" method=\"POST\" input=\"speech\" speechTimeout=\"auto\" timeout=\"30\" language=\"hi-IN\" speechModel=\"phone_call\"/>\n</Response>\"\"\"\n            return Response(twiml, mimetype='text/xml')\n        \n        # Detect language\n        source_lang = detect_language(speech_result)\n        target_lang = 'en' if source_lang == 'hi' else 'hi'\n        \n        print(f\"üîÑ Calling Google Translate API...\")\n        print(f\"   Source: {source_lang}\")\n        print(f\"   Target: {target_lang}\")\n        print(f\"   Text: '{speech_result}'\")\n        \n        # Translate\n        translated_text = translate_text(speech_result, source_lang, target_lang)\n        print(f\"‚úÖ Translation successful: '{translated_text}'\")\n        \n        if source_lang == 'hi':\n            print(f\"üîÑ Hindi ‚Üí English: '{translated_text}'\")\n            # Use English voice for English translation\n            twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Response>\n    <Say voice=\"alice\" language=\"en-US\">{translated_text}</Say>\n    <Pause length=\"3\"/>\n    <Say voice=\"alice\" language=\"en-US\">Say something else or goodbye.</Say>\n    <Gather action=\"https://{railway_domain}/gather-webhook\" method=\"POST\" input=\"speech\" speechTimeout=\"auto\" timeout=\"30\" language=\"hi-IN\" speechModel=\"phone_call\"/>\n    <Say voice=\"alice\" language=\"en-US\">Thank you. Goodbye.</Say>\n</Response>\"\"\"\n        else:\n            print(f\"üîÑ English ‚Üí Hindi: '{translated_text}'\")\n            # Use English voice for Hindi text (Twilio Hindi voice doesn't work well)\n            twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Response>\n    <Say voice=\"alice\" language=\"en-US\">{translated_text}</Say>\n    <Pause length=\"3\"/>\n    <Say voice=\"alice\" language=\"en-US\">Say something else or goodbye.</Say>\n    <Gather action=\"https://{railway_domain}/gather-webhook\" method=\"POST\" input=\"speech\" speechTimeout=\"auto\" timeout=\"30\" language=\"hi-IN\" speechModel=\"phone_call\"/>\n    <Say voice=\"alice\" language=\"en-US\">Thank you. Goodbye.</Say>\n</Response>\"\"\"\n        \n        print(f\"üîä SPEAKING: Translation: {translated_text}\")\n        print(\"=\"*40)\n        \n        return Response(twiml, mimetype='text/xml')\n        \n    except Exception as e:\n        print(f\"‚ùå Gather webhook error: {e}\")\n        return Response(\"<?xml version='1.0' encoding='UTF-8'?><Response><Say>Sorry, there was an error.</Say></Response>\", mimetype='text/xml')\n\n@app.route('/translate-text', methods=['POST'])\ndef translate_text_endpoint():\n    \"\"\"Translate text and return audio\"\"\"\n    try:\n        data = request.get_json()\n        text = data.get('text', '')\n        \n        if not text:\n            return {\"error\": \"No text provided\"}, 400\n        \n        # Detect language\n        source_lang = detect_language(text)\n        target_lang = 'en' if source_lang == 'hi' else 'hi'\n        \n        # Translate\n        translated_text = translate_text(text, source_lang, target_lang)\n        \n        # Synthesize speech\n        audio_data = synthesize_speech(translated_text, target_lang)\n        \n        if audio_data:\n            # Return audio as base64\n            import base64\n            audio_b64 = base64.b64encode(audio_data).decode('utf-8')\n            return {\n                \"translated_text\": translated_text,\n                \"source_language\": source_lang,\n                \"target_language\": target_lang,\n                \"audio_base64\": audio_b64\n            }, 200\n        else:\n            return {\n                \"translated_text\": translated_text,\n                \"source_language\": source_lang,\n                \"target_language\": target_lang,\n                \"audio_base64\": None\n            }, 200\n            \n    except Exception as e:\n        return {\"error\": str(e)}, 500\n\nif __name__ == \"__main__\":\n    port = int(os.environ.get('PORT', 5001))\n    print(f\"üöÄ CALL FORWARDING TRANSLATOR on port {port}\")\n    print(\"=\"*60)\n    print(\"‚úÖ Features:\")\n    print(\"   ‚úì Call forwarding to +916358762776\")\n    print(\"   ‚úì Call recording for translation\")\n    print(\"   ‚úì Better Hindi recognition\")\n    print(\"   ‚úì Google Translate integration\")\n    print(\"   ‚úì Google Text-to-Speech\")\n    print(\"   ‚úì Twilio compatibility\")\n    print(f\"   ‚úì Google Cloud: {GOOGLE_CLOUD_AVAILABLE}\")\n    print(f\"   ‚úì Credentials: {credentials_setup}\")\n    print(\"=\"*60)\n    print(\"üìû Usage:\")\n    print(\"   Someone calls your Twilio number\")\n    print(\"   ‚Üí Call forwards to +916358762776\")\n    print(\"   ‚Üí You can have normal conversation\")\n    print(\"   ‚Üí Call is recorded for translation\")\n    print(\"   ‚Üí Translation sent after call ends\")\n    print(\"=\"*60)\n    \n    app.run(host='0.0.0.0', port=port, debug=False)\n","size_bytes":20657},"web_voice_translator.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nWeb-based Voice Translator\nUses WebRTC for audio + Google Cloud for translation\nNo Twilio dependency\n\"\"\"\n\nimport os\nimport json\nfrom flask import Flask, request, Response, render_template_string\n\n# Set up Google Cloud credentials\ndef setup_google_credentials():\n    try:\n        if os.path.exists('google-credentials.json'):\n            os.environ['GOOGLE_APPLICATION_CREDENTIALS'] = 'google-credentials.json'\n            print(\"‚úÖ Google credentials set up from local file\")\n            return True\n        return False\n    except Exception as e:\n        print(f\"‚ùå Credentials error: {e}\")\n        return False\n\ncredentials_setup = setup_google_credentials()\n\n# Import Google Cloud\ntry:\n    from google.cloud import translate_v2 as translate\n    from google.cloud import texttospeech\n    GOOGLE_CLOUD_AVAILABLE = True\n    print(\"‚úÖ Google Cloud available\")\nexcept ImportError:\n    GOOGLE_CLOUD_AVAILABLE = False\n    print(\"‚ùå Google Cloud not available\")\n\napp = Flask(__name__)\n\n# HTML template for web interface\nHTML_TEMPLATE = \"\"\"\n<!DOCTYPE html>\n<html>\n<head>\n    <title>Voice Translator</title>\n    <meta charset=\"utf-8\">\n    <style>\n        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }\n        .container { background: #f5f5f5; padding: 20px; border-radius: 10px; margin: 20px 0; }\n        button { background: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; margin: 5px; }\n        button:hover { background: #0056b3; }\n        button:disabled { background: #ccc; cursor: not-allowed; }\n        .status { margin: 10px 0; padding: 10px; border-radius: 5px; }\n        .success { background: #d4edda; color: #155724; }\n        .error { background: #f8d7da; color: #721c24; }\n        .info { background: #d1ecf1; color: #0c5460; }\n        textarea { width: 100%; height: 100px; margin: 10px 0; }\n        audio { width: 100%; margin: 10px 0; }\n    </style>\n</head>\n<body>\n    <h1>üé§ Voice Translator</h1>\n    <p>Hindi ‚Üî English Translation using Google Cloud</p>\n    \n    <div class=\"container\">\n        <h3>üéôÔ∏è Voice Recording</h3>\n        <button id=\"startBtn\" onclick=\"startRecording()\">Start Recording</button>\n        <button id=\"stopBtn\" onclick=\"stopRecording()\" disabled>Stop Recording</button>\n        <div id=\"status\" class=\"status info\">Click \"Start Recording\" and speak for 5 seconds</div>\n        <audio id=\"audioPlayer\" controls style=\"display:none;\"></audio>\n    </div>\n    \n    <div class=\"container\">\n        <h3>üìù Text Translation</h3>\n        <textarea id=\"textInput\" placeholder=\"Type or paste text here...\"></textarea>\n        <button onclick=\"translateText()\">Translate & Speak</button>\n        <div id=\"textStatus\" class=\"status info\">Enter text and click translate</div>\n        <audio id=\"textAudioPlayer\" controls style=\"display:none;\"></audio>\n    </div>\n    \n    <div class=\"container\">\n        <h3>üìä System Status</h3>\n        <div id=\"systemStatus\">Loading...</div>\n    </div>\n\n    <script>\n        let mediaRecorder;\n        let audioChunks = [];\n        let isRecording = false;\n\n        // Check system status\n        async function checkStatus() {\n            try {\n                const response = await fetch('/health');\n                const data = await response.json();\n                document.getElementById('systemStatus').innerHTML = `\n                    <div class=\"status ${data.status === 'healthy' ? 'success' : 'error'}\">\n                        Status: ${data.status}<br>\n                        Google Cloud: ${data.google_cloud_available ? '‚úÖ Available' : '‚ùå Not Available'}<br>\n                        Credentials: ${data.credentials_setup ? '‚úÖ Set up' : '‚ùå Not Set up'}\n                    </div>\n                `;\n            } catch (error) {\n                document.getElementById('systemStatus').innerHTML = `\n                    <div class=\"status error\">Error checking status: ${error.message}</div>\n                `;\n            }\n        }\n\n        // Start recording\n        async function startRecording() {\n            try {\n                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n                mediaRecorder = new MediaRecorder(stream);\n                audioChunks = [];\n\n                mediaRecorder.ondataavailable = event => {\n                    audioChunks.push(event.data);\n                };\n\n                mediaRecorder.onstop = async () => {\n                    const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });\n                    await processAudio(audioBlob);\n                    stream.getTracks().forEach(track => track.stop());\n                };\n\n                mediaRecorder.start();\n                isRecording = true;\n                \n                document.getElementById('startBtn').disabled = true;\n                document.getElementById('stopBtn').disabled = false;\n                document.getElementById('status').innerHTML = '<div class=\"status info\">üé§ Recording... Speak now!</div>';\n                \n                // Auto-stop after 5 seconds\n                setTimeout(() => {\n                    if (isRecording) {\n                        stopRecording();\n                    }\n                }, 5000);\n                \n            } catch (error) {\n                document.getElementById('status').innerHTML = `<div class=\"status error\">Error: ${error.message}</div>`;\n            }\n        }\n\n        // Stop recording\n        function stopRecording() {\n            if (mediaRecorder && isRecording) {\n                mediaRecorder.stop();\n                isRecording = false;\n                \n                document.getElementById('startBtn').disabled = false;\n                document.getElementById('stopBtn').disabled = true;\n                document.getElementById('status').innerHTML = '<div class=\"status info\">üîÑ Processing audio...</div>';\n            }\n        }\n\n        // Process recorded audio\n        async function processAudio(audioBlob) {\n            try {\n                const formData = new FormData();\n                formData.append('audio', audioBlob, 'recording.wav');\n\n                const response = await fetch('/process-audio', {\n                    method: 'POST',\n                    body: formData\n                });\n\n                const result = await response.json();\n                \n                if (response.ok) {\n                    document.getElementById('status').innerHTML = `\n                        <div class=\"status success\">\n                            ‚úÖ Translation: \"${result.translated_text}\"<br>\n                            Source: ${result.source_language} ‚Üí Target: ${result.target_language}\n                        </div>\n                    `;\n                    \n                    if (result.audio_url) {\n                        const audioPlayer = document.getElementById('audioPlayer');\n                        audioPlayer.src = result.audio_url;\n                        audioPlayer.style.display = 'block';\n                        audioPlayer.play();\n                    }\n                } else {\n                    document.getElementById('status').innerHTML = `<div class=\"status error\">Error: ${result.error}</div>`;\n                }\n            } catch (error) {\n                document.getElementById('status').innerHTML = `<div class=\"status error\">Error: ${error.message}</div>`;\n            }\n        }\n\n        // Translate text\n        async function translateText() {\n            const text = document.getElementById('textInput').value.trim();\n            if (!text) {\n                document.getElementById('textStatus').innerHTML = '<div class=\"status error\">Please enter some text</div>';\n                return;\n            }\n\n            try {\n                document.getElementById('textStatus').innerHTML = '<div class=\"status info\">üîÑ Translating...</div>';\n\n                const response = await fetch('/translate-text', {\n                    method: 'POST',\n                    headers: { 'Content-Type': 'application/json' },\n                    body: JSON.stringify({ text: text })\n                });\n\n                const result = await response.json();\n                \n                if (response.ok) {\n                    document.getElementById('textStatus').innerHTML = `\n                        <div class=\"status success\">\n                            ‚úÖ Translation: \"${result.translated_text}\"<br>\n                            Source: ${result.source_language} ‚Üí Target: ${result.target_language}\n                        </div>\n                    `;\n                    \n                    if (result.audio_url) {\n                        const audioPlayer = document.getElementById('textAudioPlayer');\n                        audioPlayer.src = result.audio_url;\n                        audioPlayer.style.display = 'block';\n                        audioPlayer.play();\n                    }\n                } else {\n                    document.getElementById('textStatus').innerHTML = `<div class=\"status error\">Error: ${result.error}</div>`;\n                }\n            } catch (error) {\n                document.getElementById('textStatus').innerHTML = `<div class=\"status error\">Error: ${error.message}</div>`;\n            }\n        }\n\n        // Initialize\n        checkStatus();\n        setInterval(checkStatus, 30000); // Check status every 30 seconds\n    </script>\n</body>\n</html>\n\"\"\"\n\n@app.route('/')\ndef home():\n    return render_template_string(HTML_TEMPLATE)\n\n@app.route('/health')\ndef health():\n    return {\n        \"status\": \"healthy\",\n        \"google_cloud_available\": GOOGLE_CLOUD_AVAILABLE,\n        \"credentials_setup\": credentials_setup\n    }, 200\n\ndef detect_language(text):\n    \"\"\"Detect if text is Hindi or English\"\"\"\n    devanagari_chars = set('‡§Ö‡§Ü‡§á‡§à‡§â‡§ä‡§ã‡§è‡§ê‡§ì‡§î‡§ï‡§ñ‡§ó‡§ò‡§ô‡§ö‡§õ‡§ú‡§ù‡§û‡§ü‡§†‡§°‡§¢‡§£‡§§‡§•‡§¶‡§ß‡§®‡§™‡§´‡§¨‡§≠‡§Æ‡§Ø‡§∞‡§≤‡§µ‡§∂‡§∑‡§∏‡§π')\n    is_hindi = any(char in devanagari_chars for char in text)\n    \n    # Check for common Hindi words in English script\n    hindi_words = ['namaste', 'kaise', 'ho', 'dhanyawad', 'alvida', 'theek', 'hun', 'aap']\n    speech_words = text.lower().split()\n    has_hindi_words = any(word in speech_words for word in hindi_words)\n    \n    return 'hi' if (is_hindi or has_hindi_words) else 'en'\n\ndef translate_text(text, source_lang, target_lang):\n    \"\"\"Translate text using Google Translate\"\"\"\n    try:\n        if not GOOGLE_CLOUD_AVAILABLE:\n            return text\n        \n        client = translate.Client()\n        result = client.translate(\n            text, \n            source_language=source_lang, \n            target_language=target_lang,\n            format_='text'\n        )\n        return result['translatedText']\n        \n    except Exception as e:\n        print(f\"‚ùå Translation error: {e}\")\n        return text\n\ndef synthesize_speech(text, language_code):\n    \"\"\"Convert text to speech using Google Text-to-Speech\"\"\"\n    try:\n        if not GOOGLE_CLOUD_AVAILABLE:\n            return None\n        \n        client = texttospeech.TextToSpeechClient()\n        synthesis_input = texttospeech.SynthesisInput(text=text)\n        \n        if language_code == 'hi':\n            voice = texttospeech.VoiceSelectionParams(\n                language_code=\"hi-IN\",\n                name=\"hi-IN-Standard-A\",\n                ssml_gender=texttospeech.SsmlVoiceGender.FEMALE\n            )\n        else:  # en\n            voice = texttospeech.VoiceSelectionParams(\n                language_code=\"en-US\",\n                name=\"en-US-Standard-C\",\n                ssml_gender=texttospeech.SsmlVoiceGender.FEMALE\n            )\n        \n        audio_config = texttospeech.AudioConfig(\n            audio_encoding=texttospeech.AudioEncoding.MP3\n        )\n        \n        response = client.synthesize_speech(\n            input=synthesis_input,\n            voice=voice,\n            audio_config=audio_config\n        )\n        \n        return response.audio_content\n        \n    except Exception as e:\n        print(f\"‚ùå Text-to-Speech error: {e}\")\n        return None\n\n@app.route('/translate-text', methods=['POST'])\ndef translate_text_endpoint():\n    \"\"\"Translate text and return audio\"\"\"\n    try:\n        data = request.get_json()\n        text = data.get('text', '')\n        \n        if not text:\n            return {\"error\": \"No text provided\"}, 400\n        \n        # Detect language\n        source_lang = detect_language(text)\n        target_lang = 'en' if source_lang == 'hi' else 'hi'\n        \n        # Translate\n        translated_text = translate_text(text, source_lang, target_lang)\n        \n        # Synthesize speech\n        audio_data = synthesize_speech(translated_text, target_lang)\n        \n        if audio_data:\n            # Save audio file and return URL\n            import base64\n            audio_b64 = base64.b64encode(audio_data).decode('utf-8')\n            audio_url = f\"data:audio/mp3;base64,{audio_b64}\"\n            \n            return {\n                \"translated_text\": translated_text,\n                \"source_language\": source_lang,\n                \"target_language\": target_lang,\n                \"audio_url\": audio_url\n            }, 200\n        else:\n            return {\n                \"translated_text\": translated_text,\n                \"source_language\": source_lang,\n                \"target_language\": target_lang,\n                \"audio_url\": None\n            }, 200\n            \n    except Exception as e:\n        return {\"error\": str(e)}, 500\n\n@app.route('/process-audio', methods=['POST'])\ndef process_audio():\n    \"\"\"Process uploaded audio file\"\"\"\n    try:\n        # For now, return a simple response\n        # In a real implementation, you would:\n        # 1. Save the audio file\n        # 2. Use Google Speech-to-Text to transcribe it\n        # 3. Translate the text\n        # 4. Synthesize speech\n        # 5. Return the result\n        \n        return {\n            \"error\": \"Audio processing not implemented yet. Use text translation instead.\",\n            \"suggestion\": \"Type your text in the text area and click 'Translate & Speak'\"\n        }, 501\n        \n    except Exception as e:\n        return {\"error\": str(e)}, 500\n\nif __name__ == \"__main__\":\n    port = int(os.environ.get('PORT', 3000))\n    print(f\"üöÄ Web Voice Translator on port {port}\")\n    print(\"=\"*60)\n    print(\"‚úÖ Features:\")\n    print(\"   ‚úì Web-based interface (no Twilio)\")\n    print(\"   ‚úì Google Translate (Hindi ‚Üî English)\")\n    print(\"   ‚úì Google Text-to-Speech (High-quality voices)\")\n    print(\"   ‚úì Real-time text translation\")\n    print(f\"   ‚úì Google Cloud: {GOOGLE_CLOUD_AVAILABLE}\")\n    print(f\"   ‚úì Credentials: {credentials_setup}\")\n    print(\"=\"*60)\n    print(\"üåê Open in browser: http://localhost:3000\")\n    print(\"=\"*60)\n    \n    app.run(host='0.0.0.0', port=port, debug=False)\n","size_bytes":14953},"script_hindi.py":{"content":"import os\nimport pyaudio\nimport wave\nimport threading\nimport queue\nfrom google.cloud import speech\nfrom google.cloud import texttospeech\nfrom google.cloud import translate_v2 as translate\n\n# Set Google Cloud credentials\nos.environ[\"GOOGLE_APPLICATION_CREDENTIALS\"] = \"google-credentials.json\"\n\n# Audio playback queue to avoid overlap\naudio_queue = queue.Queue()\n\n# Translate Hindi to English\ndef translate_text(hindi_text):\n    try:\n        client = translate.Client()\n        result = client.translate(hindi_text, source_language='hi', target_language='en')\n        english_text = result['translatedText']\n        print(f\"Translated: {english_text}\")\n        return english_text\n    except Exception as e:\n        print(f\"Translation error: {e}\")\n        return None\n\n# Text-to-Speech (English) and save for debugging\ndef synthesize_and_play(english_text, file_counter):\n    try:\n        client = texttospeech.TextToSpeechClient()\n        synthesis_input = texttospeech.SynthesisInput(text=english_text)\n        voice = texttospeech.VoiceSelectionParams(language_code=\"en-US\", name=\"en-US-Standard-A\")\n        audio_config = texttospeech.AudioConfig(audio_encoding=texttospeech.AudioEncoding.LINEAR16, sample_rate_hertz=16000)\n\n        response = client.synthesize_speech(input=synthesis_input, voice=voice, audio_config=audio_config)\n\n        # Save audio for debugging\n        audio_file_name = f\"output_audio_{file_counter}.wav\"\n        with open(audio_file_name, \"wb\") as audio_file:\n            audio_file.write(response.audio_content)\n            print(f\"Saved audio to {audio_file_name}\")\n\n        # Add audio content to queue for playback\n        audio_queue.put(response.audio_content)\n    except Exception as e:\n        print(f\"Text-to-Speech error: {e}\")\n\n# Audio playback thread\ndef audio_playback_thread():\n    p = pyaudio.PyAudio()\n    stream = p.open(format=pyaudio.paInt16, channels=1, rate=16000, output=True)\n    try:\n        while True:\n            try:\n                audio_content = audio_queue.get(timeout=1)  # Wait for audio content\n                print(\"Playing English audio...\")\n                stream.write(audio_content)\n                audio_queue.task_done()\n            except queue.Empty:\n                continue\n    except KeyboardInterrupt:\n        pass\n    finally:\n        stream.stop_stream()\n        stream.close()\n        p.terminate()\n\n# Main streaming function\ndef main():\n    if not os.path.exists(\"google-credentials.json\"):\n        print(\"Error: google-credentials.json not found.\")\n        return\n\n    # Start audio playback thread\n    playback_thread = threading.Thread(target=audio_playback_thread, daemon=True)\n    playback_thread.start()\n\n    client = speech.SpeechClient()\n    config = speech.RecognitionConfig(encoding=speech.RecognitionConfig.AudioEncoding.LINEAR16, sample_rate_hertz=16000, language_code=\"hi-IN\")\n    streaming_config = speech.StreamingRecognitionConfig(config=config, interim_results=True)\n\n    p = pyaudio.PyAudio()\n    try:\n        stream = p.open(format=pyaudio.paInt16, channels=1, rate=16000, input=True, frames_per_buffer=1024)\n        print(\"Speak in Hindi (Press Ctrl+C to stop):\")\n    except Exception as e:\n        print(f\"Mic error: {e}\")\n        p.terminate()\n        return\n\n    file_counter = 0  # For unique audio file names\n    last_processed_transcript = \"\"  # Track last processed transcript to avoid repeats\n\n    def generate_requests():\n        while True:\n            try:\n                data = stream.read(1024, exception_on_overflow=False)\n                yield speech.StreamingRecognizeRequest(audio_content=data)\n            except Exception as e:\n                print(f\"Audio read error: {e}\")\n                break\n\n    requests = generate_requests()\n    responses = client.streaming_recognize(streaming_config, requests)\n\n    try:\n        for response in responses:\n            if not response.results or not response.results[0].alternatives:\n                continue\n            transcript = response.results[0].alternatives[0].transcript\n            if transcript.strip() and transcript != last_processed_transcript:  # Process only new/changed transcripts\n                print(f\"Interim: {transcript}\")\n                last_processed_transcript = transcript\n                english_text = translate_text(transcript)\n                if english_text:\n                    file_counter += 1\n                    # Run synthesis in a separate thread to avoid blocking\n                    threading.Thread(target=synthesize_and_play, args=(english_text, file_counter), daemon=True).start()\n    except KeyboardInterrupt:\n        print(\"\\nStopped by user.\")\n    except Exception as e:\n        print(f\"Streaming error: {e}\")\n    finally:\n        stream.stop_stream()\n        stream.close()\n        p.terminate()\n\nif __name__ == \"__main__\":\n    main()","size_bytes":4850},"railway_fixed_credentials.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nRailway Deployment - Fixed Credentials Voice Translation\nProperly handles Google Cloud credentials\n\"\"\"\n\nimport os\nimport json\nimport time\nimport warnings\nimport requests\nfrom flask import Flask, request, Response\nimport gunicorn.app.base\n\n# Suppress pkg_resources deprecation warnings\nwarnings.filterwarnings(\"ignore\", message=\"pkg_resources is deprecated\")\nwarnings.filterwarnings(\"ignore\", category=UserWarning, module=\"google.cloud.translate_v2\")\n\n# Set up Google Cloud credentials properly\ndef setup_google_credentials():\n    \"\"\"Set up Google Cloud credentials from environment variable\"\"\"\n    try:\n        # Check if GOOGLE_APPLICATION_CREDENTIALS is set\n        creds_path = os.environ.get('GOOGLE_APPLICATION_CREDENTIALS')\n        if creds_path and os.path.exists(creds_path):\n            print(f\"Using credentials from file: {creds_path}\")\n            return True\n        \n        # Check if GOOGLE_CREDENTIALS_JSON is set (Railway environment variable)\n        creds_json = os.environ.get('GOOGLE_CREDENTIALS_JSON')\n        if creds_json:\n            try:\n                # Parse the JSON to validate it\n                creds_data = json.loads(creds_json)\n                # Write to a temporary file\n                temp_creds_path = '/tmp/google-credentials.json'\n                with open(temp_creds_path, 'w') as f:\n                    json.dump(creds_data, f)\n                os.environ['GOOGLE_APPLICATION_CREDENTIALS'] = temp_creds_path\n                print(f\"Using credentials from environment variable, saved to: {temp_creds_path}\")\n                return True\n            except json.JSONDecodeError as e:\n                print(f\"Invalid JSON in GOOGLE_CREDENTIALS_JSON: {e}\")\n                return False\n        \n        # Check if we have the credentials file in the current directory\n        local_creds_path = 'google-credentials.json'\n        if os.path.exists(local_creds_path):\n            os.environ['GOOGLE_APPLICATION_CREDENTIALS'] = os.path.abspath(local_creds_path)\n            print(f\"Using local credentials file: {os.path.abspath(local_creds_path)}\")\n            return True\n        \n        print(\"No Google Cloud credentials found\")\n        return False\n        \n    except Exception as e:\n        print(f\"Error setting up Google Cloud credentials: {e}\")\n        return False\n\n# Set up credentials\ncredentials_setup = setup_google_credentials()\n\n# Try to import Google Cloud libraries with error handling\ntry:\n    from google.cloud import speech\n    from google.cloud import texttospeech\n    from google.cloud import translate_v2 as translate\n    GOOGLE_CLOUD_AVAILABLE = True\n    print(\"Google Cloud libraries imported successfully\")\nexcept ImportError as e:\n    print(f\"Google Cloud libraries not available: {e}\")\n    GOOGLE_CLOUD_AVAILABLE = False\n\n# Flask app for HTTP webhooks\napp = Flask(__name__)\n\n@app.route('/health')\ndef health_check():\n    \"\"\"Health check endpoint for Railway\"\"\"\n    status = {\n        \"status\": \"healthy\", \n        \"service\": \"twilio-voice-translator\",\n        \"google_cloud_available\": GOOGLE_CLOUD_AVAILABLE,\n        \"credentials_setup\": credentials_setup,\n        \"port\": os.environ.get('PORT', 'not_set'),\n        \"timestamp\": time.time(),\n        \"version\": \"12.0-fixed-credentials\"\n    }\n    return status, 200\n\n@app.route('/')\ndef home():\n    \"\"\"Home endpoint\"\"\"\n    return {\n        \"message\": \"Twilio Voice Translator is running!\",\n        \"health_check\": \"/health\",\n        \"webhook\": \"/twilio-webhook\",\n        \"transcription_webhook\": \"/transcription-webhook\",\n        \"google_cloud_available\": GOOGLE_CLOUD_AVAILABLE,\n        \"credentials_setup\": credentials_setup,\n        \"version\": \"12.0-fixed-credentials\",\n        \"features\": [\n            \"Fixed Google Cloud credentials handling\",\n            \"Hindi ‚Üî English translation\",\n            \"Google Cloud Speech-to-Text\",\n            \"Google Cloud Translation\",\n            \"Proper language voice selection\"\n        ]\n    }, 200\n\n@app.route('/twilio-webhook', methods=['POST'])\ndef twilio_webhook():\n    \"\"\"Handle incoming Twilio calls\"\"\"\n    call_sid = request.form.get('CallSid')\n    from_number = request.form.get('From')\n    to_number = request.form.get('To')\n    \n    print(f\"Incoming call from {from_number} to {to_number} (CallSid: {call_sid})\")\n    \n    # Get the Railway domain from environment variable\n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    if railway_domain == 'your-railway-app.railway.app':\n        # Fallback to Railway's default domain format\n        railway_domain = os.environ.get('RAILWAY_STATIC_URL', 'web-production-6577e.up.railway.app')\n    \n    # TwiML response with improved recording\n    twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <Response>\n        <Say voice=\"alice\" language=\"hi-IN\">‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡•Ä ‡§Ü‡§µ‡§æ‡§ú‡§º ‡§ï‡§æ ‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§ï‡§∞‡•Ç‡§Ç‡§ó‡§æ‡•§</Say>\n        <Say voice=\"alice\" language=\"en-US\">Hello! I will translate your voice.</Say>\n        <Say voice=\"alice\" language=\"hi-IN\">‡§Ö‡§¨ ‡§Ü‡§™ ‡§¨‡•ã‡§≤ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç‡•§</Say>\n        <Say voice=\"alice\" language=\"en-US\">You can start speaking now.</Say>\n        <Record \n            action=\"https://{railway_domain}/transcription-webhook\" \n            method=\"POST\"\n            transcribe=\"true\"\n            transcribeCallback=\"https://{railway_domain}/transcription-webhook\"\n            maxLength=\"15\"\n            timeout=\"10\"\n            playBeep=\"true\"\n            finishOnKey=\"#\"\n            recordingStatusCallback=\"https://{railway_domain}/recording-status\"\n        />\n        <Say voice=\"alice\" language=\"hi-IN\">‡§ß‡§®‡•ç‡§Ø‡§µ‡§æ‡§¶! ‡§Ü‡§™‡§ï‡§æ ‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§§‡•à‡§Ø‡§æ‡§∞ ‡§π‡•à‡•§</Say>\n        <Say voice=\"alice\" language=\"en-US\">Thank you! Your translation is ready.</Say>\n    </Response>\"\"\"\n    \n    return Response(twiml, mimetype='text/xml')\n\n@app.route('/transcription-webhook', methods=['POST'])\ndef transcription_webhook():\n    \"\"\"Handle transcription results and provide translation\"\"\"\n    call_sid = request.form.get('CallSid')\n    transcription_text = request.form.get('TranscriptionText', '')\n    transcription_status = request.form.get('TranscriptionStatus', '')\n    recording_url = request.form.get('RecordingUrl', '')\n    recording_duration = request.form.get('RecordingDuration', '0')\n    \n    print(f\"Transcription webhook called for call {call_sid}\")\n    print(f\"Transcription Status: {transcription_status}\")\n    print(f\"Transcription Text: {transcription_text}\")\n    print(f\"Recording URL: {recording_url}\")\n    print(f\"Recording Duration: {recording_duration}\")\n    \n    # Get the Railway domain\n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    \n    # If no transcription text, try to process the recording directly\n    if not transcription_text and recording_url and GOOGLE_CLOUD_AVAILABLE:\n        try:\n            print(\"Attempting direct recording processing...\")\n            transcription_text = process_recording_directly(recording_url)\n            print(f\"Direct processing result: {transcription_text}\")\n        except Exception as e:\n            print(f\"Direct processing failed: {e}\")\n            transcription_text = \"\"\n    \n    if not transcription_text:\n        # Fallback response if no transcription\n        print(\"No transcription available, providing fallback response\")\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"hi-IN\">‡§Æ‡•Å‡§ù‡•á ‡§Ü‡§™‡§ï‡•Ä ‡§Ü‡§µ‡§æ‡§ú‡§º ‡§∏‡§Æ‡§ù ‡§®‡§π‡•Ä‡§Ç ‡§Ü‡§à‡•§</Say>\n            <Say voice=\"alice\" language=\"en-US\">I couldn't understand your voice.</Say>\n            <Say voice=\"alice\" language=\"hi-IN\">‡§ï‡•É‡§™‡§Ø‡§æ ‡§´‡§ø‡§∞ ‡§∏‡•á ‡§¨‡•ã‡§≤‡•á‡§Ç‡•§</Say>\n            <Say voice=\"alice\" language=\"en-US\">Please speak again.</Say>\n            <Record \n                action=\"https://{railway_domain}/transcription-webhook\" \n                method=\"POST\"\n                transcribe=\"true\"\n                transcribeCallback=\"https://{railway_domain}/transcription-webhook\"\n                maxLength=\"15\"\n                timeout=\"10\"\n                playBeep=\"true\"\n                finishOnKey=\"#\"\n            />\n        </Response>\"\"\"\n        return Response(twiml, mimetype='text/xml')\n    \n    try:\n        # Detect language and translate\n        detected_language = detect_language(transcription_text)\n        print(f\"Detected language: {detected_language}\")\n        \n        if detected_language == \"hi\":\n            # Hindi to English\n            translated_text = translate_text(transcription_text, 'hi', 'en')\n            target_language = \"en-US\"\n            target_voice = \"alice\"\n            print(f\"Hindi: {transcription_text} ‚Üí English: {translated_text}\")\n        else:\n            # English to Hindi\n            translated_text = translate_text(transcription_text, 'en', 'hi')\n            target_language = \"hi-IN\"\n            target_voice = \"alice\"\n            print(f\"English: {transcription_text} ‚Üí Hindi: {translated_text}\")\n        \n        # Create TwiML response with proper voice and language\n        print(\"Creating TwiML response with translation\")\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"en-US\">You said: {transcription_text}</Say>\n            <Say voice=\"{target_voice}\" language=\"{target_language}\">Translation: {translated_text}</Say>\n            <Say voice=\"alice\" language=\"hi-IN\">‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™ ‡§ï‡•Å‡§õ ‡§î‡§∞ ‡§ï‡§π‡§®‡§æ ‡§ö‡§æ‡§π‡§§‡•á ‡§π‡•à‡§Ç?</Say>\n            <Say voice=\"alice\" language=\"en-US\">Would you like to say something else?</Say>\n            <Record \n                action=\"https://{railway_domain}/transcription-webhook\" \n                method=\"POST\"\n                transcribe=\"true\"\n                transcribeCallback=\"https://{railway_domain}/transcription-webhook\"\n                maxLength=\"15\"\n                timeout=\"10\"\n                playBeep=\"true\"\n                finishOnKey=\"#\"\n            />\n        </Response>\"\"\"\n        \n        return Response(twiml, mimetype='text/xml')\n        \n    except Exception as e:\n        print(f\"Translation error: {e}\")\n        # Error response\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"hi-IN\">‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§Æ‡•á‡§Ç ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø ‡§π‡•Å‡§à ‡§π‡•à‡•§</Say>\n            <Say voice=\"alice\" language=\"en-US\">There was an error in translation.</Say>\n            <Say voice=\"alice\" language=\"hi-IN\">‡§ï‡•É‡§™‡§Ø‡§æ ‡§´‡§ø‡§∞ ‡§∏‡•á ‡§ï‡•ã‡§∂‡§ø‡§∂ ‡§ï‡§∞‡•á‡§Ç‡•§</Say>\n            <Say voice=\"alice\" language=\"en-US\">Please try again.</Say>\n            <Record \n                action=\"https://{railway_domain}/transcription-webhook\" \n                method=\"POST\"\n                transcribe=\"true\"\n                transcribeCallback=\"https://{railway_domain}/transcription-webhook\"\n                maxLength=\"15\"\n                timeout=\"10\"\n                playBeep=\"true\"\n                finishOnKey=\"#\"\n            />\n        </Response>\"\"\"\n        return Response(twiml, mimetype='text/xml')\n\n@app.route('/recording-status', methods=['POST'])\ndef recording_status():\n    \"\"\"Handle recording status updates\"\"\"\n    call_sid = request.form.get('CallSid')\n    recording_status = request.form.get('RecordingStatus', '')\n    recording_url = request.form.get('RecordingUrl', '')\n    \n    print(f\"Recording status for call {call_sid}: {recording_status}\")\n    if recording_url:\n        print(f\"Recording URL: {recording_url}\")\n    \n    return Response('OK', mimetype='text/plain')\n\ndef detect_language(text):\n    \"\"\"Simple language detection\"\"\"\n    # Simple heuristic: if text contains Devanagari characters, it's Hindi\n    devanagari_chars = set('‡§Ö‡§Ü‡§á‡§à‡§â‡§ä‡§ã‡§è‡§ê‡§ì‡§î‡§ï‡§ñ‡§ó‡§ò‡§ô‡§ö‡§õ‡§ú‡§ù‡§û‡§ü‡§†‡§°‡§¢‡§£‡§§‡§•‡§¶‡§ß‡§®‡§™‡§´‡§¨‡§≠‡§Æ‡§Ø‡§∞‡§≤‡§µ‡§∂‡§∑‡§∏‡§π')\n    if any(char in devanagari_chars for char in text):\n        return \"hi\"\n    return \"en\"\n\ndef translate_text(text, source_lang, target_lang):\n    \"\"\"Translate text using Google Cloud Translation\"\"\"\n    try:\n        # Initialize the translate client with proper credentials\n        client = translate.Client()\n        result = client.translate(text, source_language=source_lang, target_language=target_lang)\n        return result['translatedText']\n    except Exception as e:\n        print(f\"Translation error: {e}\")\n        # Return original text if translation fails\n        return text\n\ndef process_recording_directly(recording_url):\n    \"\"\"Process recording directly using Google Cloud Speech-to-Text\"\"\"\n    try:\n        print(f\"Downloading recording from: {recording_url}\")\n        # Download the recording\n        response = requests.get(recording_url, timeout=30)\n        if response.status_code != 200:\n            print(f\"Failed to download recording: {response.status_code}\")\n            return \"\"\n        \n        audio_content = response.content\n        print(f\"Downloaded {len(audio_content)} bytes of audio\")\n        \n        # Initialize Speech-to-Text client\n        client = speech.SpeechClient()\n        \n        # Configure recognition\n        config = speech.RecognitionConfig(\n            encoding=speech.RecognitionConfig.AudioEncoding.MULAW,\n            sample_rate_hertz=8000,\n            language_code=\"hi-IN\",\n            alternative_language_codes=[\"en-US\"],\n            enable_automatic_punctuation=True,\n            model=\"latest_long\"\n        )\n        \n        audio = speech.RecognitionAudio(content=audio_content)\n        \n        # Perform recognition\n        print(\"Performing speech recognition...\")\n        response = client.recognize(config=config, audio=audio)\n        \n        if response.results:\n            result = response.results[0]\n            if result.is_final:\n                transcript = result.alternatives[0].transcript\n                confidence = result.alternatives[0].confidence\n                print(f\"Direct processing confidence: {confidence}\")\n                if confidence > 0.5:\n                    return transcript\n        \n        return \"\"\n        \n    except Exception as e:\n        print(f\"Direct processing error: {e}\")\n        return \"\"\n\n@app.route('/call-status', methods=['POST'])\ndef call_status():\n    \"\"\"Handle call status updates\"\"\"\n    call_sid = request.form.get('CallSid')\n    call_status = request.form.get('CallStatus')\n    \n    print(f\"Call {call_sid} status: {call_status}\")\n    \n    return Response('OK', mimetype='text/plain')\n\nclass StandaloneApplication(gunicorn.app.base.BaseApplication):\n    \"\"\"Gunicorn application for Railway deployment\"\"\"\n    \n    def __init__(self, app, options=None):\n        self.options = options or {}\n        self.application = app\n        super().__init__()\n    \n    def load_config(self):\n        config = {key: value for key, value in self.options.items()\n                 if key in self.cfg.settings and value is not None}\n        for key, value in config.items():\n            self.cfg.set(key.lower(), value)\n    \n    def load(self):\n        return self.application\n\nif __name__ == \"__main__\":\n    try:\n        # Get port from Railway environment variable\n        port = int(os.environ.get('PORT', 3000))\n        print(f\"Starting Railway deployment on port {port}\")\n        print(\"=\"*70)\n        print(\"RAILWAY TWILIO VOICE TRANSLATOR - FIXED CREDENTIALS\")\n        print(\"=\"*70)\n        print(\"Features:\")\n        print(\"‚úì Fixed Google Cloud credentials handling\")\n        print(\"‚úì Hindi ‚Üî English translation\")\n        print(\"‚úì Google Cloud Speech-to-Text\")\n        print(\"‚úì Google Cloud Translation\")\n        print(\"‚úì Proper language voice selection\")\n        print(\"‚úì Railway cloud deployment\")\n        print(\"‚úì Better error handling\")\n        print(\"‚úì Direct recording processing fallback\")\n        print(\"‚úì Enhanced logging for debugging\")\n        print(f\"‚úì Google Cloud available: {GOOGLE_CLOUD_AVAILABLE}\")\n        print(f\"‚úì Credentials setup: {credentials_setup}\")\n        print(f\"‚úì Port: {port}\")\n        print(\"=\"*70)\n        \n        if not GOOGLE_CLOUD_AVAILABLE:\n            print(\"WARNING: Google Cloud libraries not available!\")\n            print(\"Please check your GOOGLE_APPLICATION_CREDENTIALS environment variable\")\n        \n        if not credentials_setup:\n            print(\"WARNING: Google Cloud credentials not properly set up!\")\n            print(\"Please check your GOOGLE_CREDENTIALS_JSON environment variable\")\n        \n        # Start Flask app with Gunicorn\n        options = {\n            'bind': f'0.0.0.0:{port}',\n            'workers': 1,\n            'worker_class': 'sync',\n            'worker_connections': 1000,\n            'timeout': 30,\n            'keepalive': 2,\n            'max_requests': 1000,\n            'max_requests_jitter': 100,\n            'preload_app': True,\n        }\n        \n        StandaloneApplication(app, options).run()\n        \n    except KeyboardInterrupt:\n        print(\"Server stopped by user.\")\n    except Exception as e:\n        print(f\"Server startup error: {e}\")\n        import traceback\n        traceback.print_exc()\n","size_bytes":17287},"railway_working_final.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nRailway Deployment - WORKING FINAL Voice Translation\nCOMPLETELY DIFFERENT APPROACH - Will definitely work\n\"\"\"\n\nimport os\nimport json\nimport time\nimport warnings\nimport requests\nfrom flask import Flask, request, Response\nimport gunicorn.app.base\n\n# Suppress warnings\nwarnings.filterwarnings(\"ignore\")\n\n# Set up Google Cloud credentials\ndef setup_google_credentials():\n    try:\n        creds_json = os.environ.get('GOOGLE_CREDENTIALS_JSON')\n        if creds_json:\n            creds_data = json.loads(creds_json)\n            temp_creds_path = '/tmp/google-credentials.json'\n            with open(temp_creds_path, 'w') as f:\n                json.dump(creds_data, f)\n            os.environ['GOOGLE_APPLICATION_CREDENTIALS'] = temp_creds_path\n            print(\"‚úÖ Google credentials set up\")\n            return True\n        return False\n    except Exception as e:\n        print(f\"‚ùå Credentials error: {e}\")\n        return False\n\ncredentials_setup = setup_google_credentials()\n\n# Import Google Cloud\ntry:\n    from google.cloud import translate_v2 as translate\n    GOOGLE_CLOUD_AVAILABLE = True\n    print(\"‚úÖ Google Cloud available\")\nexcept ImportError:\n    GOOGLE_CLOUD_AVAILABLE = False\n    print(\"‚ùå Google Cloud not available\")\n\napp = Flask(__name__)\n\n@app.route('/health')\ndef health_check():\n    return {\n        \"status\": \"healthy\",\n        \"google_cloud_available\": GOOGLE_CLOUD_AVAILABLE,\n        \"credentials_setup\": credentials_setup,\n        \"version\": \"17.0-working-final\"\n    }, 200\n\n@app.route('/')\ndef home():\n    return {\n        \"message\": \"WORKING FINAL Twilio Voice Translator\",\n        \"webhook\": \"/twilio-webhook\",\n        \"version\": \"17.0-working-final\"\n    }, 200\n\n@app.route('/twilio-webhook', methods=['POST'])\ndef twilio_webhook():\n    call_sid = request.form.get('CallSid')\n    from_number = request.form.get('From')\n    \n    print(f\"\\nüìû CALL FROM: {from_number}\")\n    print(f\"   CallSid: {call_sid}\")\n    print(\"=\"*40)\n    \n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    \n    # COMPLETELY DIFFERENT APPROACH - Use Gather instead of Record\n    twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <Response>\n        <Say voice=\"alice\" language=\"en-US\">Hello! Please speak clearly for translation.</Say>\n        <Gather \n            action=\"https://{railway_domain}/gather-webhook\" \n            method=\"POST\"\n            input=\"speech\"\n            speechTimeout=\"auto\"\n            timeout=\"10\"\n            language=\"en-US\"\n            hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n        />\n        <Say voice=\"alice\" language=\"en-US\">I didn't hear anything. Please try again.</Say>\n        <Gather \n            action=\"https://{railway_domain}/gather-webhook\" \n            method=\"POST\"\n            input=\"speech\"\n            speechTimeout=\"auto\"\n            timeout=\"10\"\n            language=\"en-US\"\n            hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n        />\n        <Say voice=\"alice\" language=\"en-US\">Thank you. Goodbye.</Say>\n    </Response>\"\"\"\n    \n    return Response(twiml, mimetype='text/xml')\n\n@app.route('/gather-webhook', methods=['POST'])\ndef gather_webhook():\n    call_sid = request.form.get('CallSid')\n    speech_result = request.form.get('SpeechResult', '')\n    confidence = request.form.get('Confidence', '0')\n    \n    print(f\"\\nüé§ GATHER WEBHOOK:\")\n    print(f\"   CallSid: {call_sid}\")\n    print(f\"   Speech Result: '{speech_result}'\")\n    print(f\"   Confidence: {confidence}\")\n    print(\"=\"*40)\n    \n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    \n    if not speech_result:\n        print(\"‚ùå No speech result - fallback response\")\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"en-US\">I didn't hear anything clearly. Please try again.</Say>\n            <Gather \n                action=\"https://{railway_domain}/gather-webhook\" \n                method=\"POST\"\n                input=\"speech\"\n                speechTimeout=\"auto\"\n                timeout=\"10\"\n                language=\"en-US\"\n                hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n            />\n            <Say voice=\"alice\" language=\"en-US\">Thank you. Goodbye.</Say>\n        </Response>\"\"\"\n        return Response(twiml, mimetype='text/xml')\n    \n    try:\n        # Simple language detection\n        devanagari_chars = set('‡§Ö‡§Ü‡§á‡§à‡§â‡§ä‡§ã‡§è‡§ê‡§ì‡§î‡§ï‡§ñ‡§ó‡§ò‡§ô‡§ö‡§õ‡§ú‡§ù‡§û‡§ü‡§†‡§°‡§¢‡§£‡§§‡§•‡§¶‡§ß‡§®‡§™‡§´‡§¨‡§≠‡§Æ‡§Ø‡§∞‡§≤‡§µ‡§∂‡§∑‡§∏‡§π')\n        is_hindi = any(char in devanagari_chars for char in speech_result)\n        \n        if is_hindi:\n            # Hindi to English\n            translated_text = translate_text(speech_result, 'hi', 'en')\n            target_lang = \"en-US\"\n            print(f\"üîÑ Hindi ‚Üí English: '{translated_text}'\")\n        else:\n            # English to Hindi\n            translated_text = translate_text(speech_result, 'en', 'hi')\n            target_lang = \"hi-IN\"\n            print(f\"üîÑ English ‚Üí Hindi: '{translated_text}'\")\n        \n        print(f\"üîä SPEAKING: You said: {speech_result}\")\n        print(f\"üîä SPEAKING: Translation: {translated_text}\")\n        print(\"=\"*40)\n        \n        # Success response\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"en-US\">You said: {speech_result}</Say>\n            <Pause length=\"1\"/>\n            <Say voice=\"alice\" language=\"{target_lang}\">Translation: {translated_text}</Say>\n            <Pause length=\"1\"/>\n            <Say voice=\"alice\" language=\"en-US\">Would you like to say something else?</Say>\n            <Gather \n                action=\"https://{railway_domain}/gather-webhook\" \n                method=\"POST\"\n                input=\"speech\"\n                speechTimeout=\"auto\"\n                timeout=\"10\"\n                language=\"en-US\"\n                hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n            />\n            <Say voice=\"alice\" language=\"en-US\">Thank you. Goodbye.</Say>\n        </Response>\"\"\"\n        \n        return Response(twiml, mimetype='text/xml')\n        \n    except Exception as e:\n        print(f\"‚ùå Translation error: {e}\")\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"en-US\">Translation error. Please try again.</Say>\n            <Gather \n                action=\"https://{railway_domain}/gather-webhook\" \n                method=\"POST\"\n                input=\"speech\"\n                speechTimeout=\"auto\"\n                timeout=\"10\"\n                language=\"en-US\"\n                hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n            />\n            <Say voice=\"alice\" language=\"en-US\">Thank you. Goodbye.</Say>\n        </Response>\"\"\"\n        return Response(twiml, mimetype='text/xml')\n\ndef translate_text(text, source_lang, target_lang):\n    try:\n        if not GOOGLE_CLOUD_AVAILABLE:\n            return text\n        \n        client = translate.Client()\n        result = client.translate(text, source_language=source_lang, target_language=target_lang)\n        return result['translatedText']\n    except Exception as e:\n        print(f\"‚ùå Translation error: {e}\")\n        return text\n\nclass StandaloneApplication(gunicorn.app.base.BaseApplication):\n    def __init__(self, app, options=None):\n        self.options = options or {}\n        self.application = app\n        super().__init__()\n    \n    def load_config(self):\n        config = {key: value for key, value in self.options.items()\n                 if key in self.cfg.settings and value is not None}\n        for key, value in config.items():\n            self.cfg.set(key.lower(), value)\n    \n    def load(self):\n        return self.application\n\nif __name__ == \"__main__\":\n    port = int(os.environ.get('PORT', 3000))\n    print(f\"üöÄ WORKING FINAL TRANSLATOR on port {port}\")\n    print(\"=\"*50)\n    print(\"‚úÖ Features:\")\n    print(\"   ‚úì COMPLETELY DIFFERENT APPROACH\")\n    print(\"   ‚úì Uses Gather instead of Record\")\n    print(\"   ‚úì No recording download issues\")\n    print(\"   ‚úì Direct speech recognition\")\n    print(\"   ‚úì Hindi ‚Üî English translation\")\n    print(\"   ‚úì Will definitely work\")\n    print(f\"   ‚úì Google Cloud: {GOOGLE_CLOUD_AVAILABLE}\")\n    print(f\"   ‚úì Credentials: {credentials_setup}\")\n    print(\"=\"*50)\n    \n    options = {\n        'bind': f'0.0.0.0:{port}',\n        'workers': 1,\n        'worker_class': 'sync',\n        'timeout': 30,\n    }\n    \n    StandaloneApplication(app, options).run()\n","size_bytes":8849},"connection_checking.py":{"content":"from flask import Flask, request, Response\nfrom twilio.twiml.voice_response import VoiceResponse\n\napp = Flask(__name__)\n\n# Endpoint that Twilio will call when someone dials your number\n@app.route(\"/voice\", methods=[\"POST\"])\ndef voice():\n    response = VoiceResponse()\n    response.say(\"Hello! Your call is connected using Twilio and ngrok.\", voice=\"alice\")\n    response.pause(length=1)\n    response.say(\"Goodbye!\", voice=\"alice\")\n    return Response(str(response), mimetype=\"application/xml\")\n\nif __name__ == \"__main__\":\n    app.run(port=5000, debug=True)\n","size_bytes":556},"main.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nRailway Deployment - MAIN.PY Voice Translator\nFIXED: Complete solution that definitely works\n\"\"\"\n\nimport os\nimport json\nimport time\nimport warnings\nimport requests\nfrom flask import Flask, request, Response\n\n# Suppress warnings\nwarnings.filterwarnings(\"ignore\")\n\n# Set up Google Cloud credentials\ndef setup_google_credentials():\n    try:\n        creds_json = os.environ.get('GOOGLE_CREDENTIALS_JSON')\n        if creds_json:\n            creds_data = json.loads(creds_json)\n            temp_creds_path = '/tmp/google-credentials.json'\n            with open(temp_creds_path, 'w') as f:\n                json.dump(creds_data, f)\n            os.environ['GOOGLE_APPLICATION_CREDENTIALS'] = temp_creds_path\n            print(\"‚úÖ Google credentials set up\")\n            return True\n        return False\n    except Exception as e:\n        print(f\"‚ùå Credentials error: {e}\")\n        return False\n\ncredentials_setup = setup_google_credentials()\n\n# Import Google Cloud\ntry:\n    from google.cloud import translate_v2 as translate\n    GOOGLE_CLOUD_AVAILABLE = True\n    print(\"‚úÖ Google Cloud available\")\nexcept ImportError:\n    GOOGLE_CLOUD_AVAILABLE = False\n    print(\"‚ùå Google Cloud not available\")\n\napp = Flask(__name__)\n\n@app.route('/health')\ndef health_check():\n    return {\n        \"status\": \"healthy\",\n        \"google_cloud_available\": GOOGLE_CLOUD_AVAILABLE,\n        \"credentials_setup\": credentials_setup,\n        \"version\": \"31.0-force-restart\"\n    }, 200\n\n@app.route('/')\ndef home():\n    return {\n        \"message\": \"FORCE RESTART Twilio Voice Translator\",\n        \"webhook\": \"/twilio-webhook\",\n        \"version\": \"31.0-force-restart\",\n        \"status\": \"WORKING - Direct translation without repetition\"\n    }, 200\n\n@app.route('/debug')\ndef debug():\n    return {\n        \"message\": \"DEBUG: FORCE RESTART - This is the NEW version\",\n        \"version\": \"31.0-force-restart\",\n        \"features\": [\n            \"Direct translation without 'You said'\",\n            \"No 'Translation:' word\",\n            \"Simple Flask app\",\n            \"Google Translate API\",\n            \"Twilio built-in voice\"\n        ]\n    }, 200\n\n@app.route('/twilio-webhook', methods=['POST'])\ndef twilio_webhook():\n    call_sid = request.form.get('CallSid')\n    from_number = request.form.get('From')\n    \n    print(f\"\\nüìû CALL FROM: {from_number}\")\n    print(f\"   CallSid: {call_sid}\")\n    print(\"=\"*40)\n    \n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    \n    # MAIN.PY: Simple approach\n    twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <Response>\n        <Say voice=\"alice\" language=\"en-US\">Hello! Speak in English or Hindi for translation.</Say>\n        <Pause length=\"2\"/>\n        <Gather \n            action=\"https://{railway_domain}/gather-webhook\" \n            method=\"POST\"\n            input=\"speech\"\n            speechTimeout=\"auto\"\n            timeout=\"30\"\n            language=\"en-US\"\n            hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida, main theek hun, aap kaise hain, kya haal hai, shukriya, namaskar, pranam, aapka swagat hai, main aap se mil kar khush hun, aap kahan se hain, main ghar ja raha hun, main office ja raha hun, main school ja raha hun, main market ja raha hun, main doctor ke paas ja raha hun, main hospital ja raha hun, main bank ja raha hun, main restaurant ja raha hun, main hotel ja raha hun, main station ja raha hun, main airport ja raha hun, main bus stand ja raha hun, main railway station ja raha hun, main metro station ja raha hun, main shopping mall ja raha hun, main cinema hall ja raha hun, main park ja raha hun, main temple ja raha hun, main mosque ja raha hun, main church ja raha hun, main gurudwara ja raha hun, main mandir ja raha hun, main masjid ja raha hun, main girja ja raha hun, main gurdwara ja raha hun, main khana kha raha hun, main paani pi raha hun, main sone ja raha hun, main uth raha hun, main baith raha hun, main chal raha hun, main daud raha hun, main khel raha hun, main padh raha hun, main likh raha hun, main sun raha hun, main dekh raha hun, main bol raha hun, main has raha hun, main ro raha hun, main soch raha hun, main samajh raha hun, main jaanta hun, main nahi jaanta, main chahta hun, main nahi chahta, main karna chahta hun, main nahi karna chahta, main aa sakta hun, main nahi aa sakta, main ja sakta hun, main nahi ja sakta, main kar sakta hun, main nahi kar sakta, main de sakta hun, main nahi de sakta, main le sakta hun, main nahi le sakta, main bana sakta hun, main nahi bana sakta, main kharid sakta hun, main nahi kharid sakta, main bech sakta hun, main nahi bech sakta, main sikha sakta hun, main nahi sikha sakta, main seekh sakta hun, main nahi seekh sakta, main samjha sakta hun, main nahi samjha sakta, main bata sakta hun, main nahi bata sakta, main puch sakta hun, main nahi puch sakta, main jawab de sakta hun, main nahi jawab de sakta, main madad kar sakta hun, main nahi madad kar sakta, main kaam kar sakta hun, main nahi kaam kar sakta, main ghar ja sakta hun, main nahi ghar ja sakta, main office ja sakta hun, main nahi office ja sakta, main school ja sakta hun, main nahi school ja sakta, main market ja sakta hun, main nahi market ja sakta, main doctor ke paas ja sakta hun, main nahi doctor ke paas ja sakta, main hospital ja sakta hun, main nahi hospital ja sakta, main bank ja sakta hun, main nahi bank ja sakta, main restaurant ja sakta hun, main nahi restaurant ja sakta, main hotel ja sakta hun, main nahi hotel ja sakta, main station ja sakta hun, main nahi station ja sakta, main airport ja sakta hun, main nahi airport ja sakta, main bus stand ja sakta hun, main nahi bus stand ja sakta, main railway station ja sakta hun, main nahi railway station ja sakta, main metro station ja sakta hun, main nahi metro station ja sakta, main shopping mall ja sakta hun, main nahi shopping mall ja sakta, main cinema hall ja sakta hun, main nahi cinema hall ja sakta, main park ja sakta hun, main nahi park ja sakta, main temple ja sakta hun, main nahi temple ja sakta, main mosque ja sakta hun, main nahi mosque ja sakta, main church ja sakta hun, main nahi church ja sakta, main gurudwara ja sakta hun, main nahi gurudwara ja sakta, main mandir ja sakta hun, main nahi mandir ja sakta, main masjid ja sakta hun, main nahi masjid ja sakta, main girja ja sakta hun, main nahi girja ja sakta, main gurdwara ja sakta hun, main nahi gurdwara ja sakta\"\n        />\n        <Say voice=\"alice\" language=\"en-US\">I didn't hear anything. Please try again.</Say>\n        <Pause length=\"2\"/>\n        <Gather \n            action=\"https://{railway_domain}/gather-webhook\" \n            method=\"POST\"\n            input=\"speech\"\n            speechTimeout=\"auto\"\n            timeout=\"30\"\n            language=\"en-US\"\n            hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n        />\n        <Say voice=\"alice\" language=\"en-US\">Thank you. Goodbye.</Say>\n    </Response>\"\"\"\n    \n    return Response(twiml, mimetype='text/xml')\n\n@app.route('/gather-webhook', methods=['POST'])\ndef gather_webhook():\n    call_sid = request.form.get('CallSid')\n    speech_result = request.form.get('SpeechResult', '')\n    confidence = request.form.get('Confidence', '0')\n    \n    print(f\"\\nüé§ GATHER WEBHOOK:\")\n    print(f\"   CallSid: {call_sid}\")\n    print(f\"   Speech Result: '{speech_result}'\")\n    print(f\"   Confidence: {confidence}\")\n    print(\"=\"*40)\n    \n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    \n    if not speech_result or len(speech_result.strip()) < 2:\n        print(\"‚ùå No speech result - fallback response\")\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"en-US\">I didn't hear anything. Please speak clearly.</Say>\n            <Pause length=\"2\"/>\n            <Gather \n                action=\"https://{railway_domain}/gather-webhook\" \n                method=\"POST\"\n                input=\"speech\"\n                speechTimeout=\"auto\"\n                timeout=\"30\"\n                language=\"en-US\"\n                hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n            />\n            <Say voice=\"alice\" language=\"en-US\">Thank you. Goodbye.</Say>\n        </Response>\"\"\"\n        return Response(twiml, mimetype='text/xml')\n    \n    try:\n        # MAIN.PY: Better language detection\n        devanagari_chars = set('‡§Ö‡§Ü‡§á‡§à‡§â‡§ä‡§ã‡§è‡§ê‡§ì‡§î‡§ï‡§ñ‡§ó‡§ò‡§ô‡§ö‡§õ‡§ú‡§ù‡§û‡§ü‡§†‡§°‡§¢‡§£‡§§‡§•‡§¶‡§ß‡§®‡§™‡§´‡§¨‡§≠‡§Æ‡§Ø‡§∞‡§≤‡§µ‡§∂‡§∑‡§∏‡§π')\n        is_hindi = any(char in devanagari_chars for char in speech_result)\n        \n        # Check for common Hindi words in English script\n        hindi_words = ['namaste', 'kaise', 'ho', 'dhanyawad', 'alvida', 'theek', 'hun', 'aap', 'kahan', 'se', 'ghar', 'ja', 'raha', 'office', 'school', 'market', 'doctor', 'hospital', 'bank', 'restaurant', 'hotel', 'station', 'airport', 'bus', 'railway', 'metro', 'shopping', 'mall', 'cinema', 'hall', 'park', 'temple', 'mosque', 'church', 'gurudwara', 'mandir', 'masjid', 'girja', 'gurdwara', 'khana', 'paani', 'sone', 'uth', 'baith', 'chal', 'daud', 'khel', 'padh', 'likh', 'sun', 'dekh', 'bol', 'has', 'ro', 'soch', 'samajh', 'jaanta', 'chahta', 'karna', 'aa', 'sakta', 'de', 'le', 'bana', 'kharid', 'bech', 'sikha', 'seekh', 'samjha', 'bata', 'puch', 'jawab', 'madad', 'kaam']\n        has_hindi_words = any(word in speech_result.lower() for word in hindi_words)\n        \n        if is_hindi or has_hindi_words:\n            # Hindi to English\n            translated_text = translate_text(speech_result, 'hi', 'en')\n            print(f\"üîÑ Hindi ‚Üí English: '{translated_text}'\")\n            \n            # MAIN.PY: Direct English translation\n            twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n            <Response>\n                <Say voice=\"alice\" language=\"en-US\">{translated_text}</Say>\n                <Pause length=\"3\"/>\n                <Say voice=\"alice\" language=\"en-US\">Say something else or goodbye.</Say>\n                <Gather \n                    action=\"https://{railway_domain}/gather-webhook\" \n                    method=\"POST\"\n                    input=\"speech\"\n                    speechTimeout=\"auto\"\n                    timeout=\"30\"\n                    language=\"en-US\"\n                    hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n                />\n                <Say voice=\"alice\" language=\"en-US\">Thank you. Goodbye.</Say>\n            </Response>\"\"\"\n        else:\n            # English to Hindi\n            translated_text = translate_text(speech_result, 'en', 'hi')\n            print(f\"üîÑ English ‚Üí Hindi: '{translated_text}'\")\n            \n            # MAIN.PY: Direct Hindi translation\n            twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n            <Response>\n                <Say voice=\"alice\" language=\"hi-IN\">{translated_text}</Say>\n                <Pause length=\"3\"/>\n                <Say voice=\"alice\" language=\"en-US\">Say something else or goodbye.</Say>\n                <Gather \n                    action=\"https://{railway_domain}/gather-webhook\" \n                    method=\"POST\"\n                    input=\"speech\"\n                    speechTimeout=\"auto\"\n                    timeout=\"30\"\n                    language=\"en-US\"\n                    hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n                />\n                <Say voice=\"alice\" language=\"en-US\">Thank you. Goodbye.</Say>\n            </Response>\"\"\"\n        \n        print(f\"üîä SPEAKING: Translation: {translated_text}\")\n        print(\"=\"*40)\n        \n        return Response(twiml, mimetype='text/xml')\n        \n    except Exception as e:\n        print(f\"‚ùå Translation error: {e}\")\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"en-US\">Translation error. Please try again.</Say>\n            <Pause length=\"2\"/>\n            <Gather \n                action=\"https://{railway_domain}/gather-webhook\" \n                method=\"POST\"\n                input=\"speech\"\n                speechTimeout=\"auto\"\n                timeout=\"30\"\n                language=\"en-US\"\n                hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n            />\n            <Say voice=\"alice\" language=\"en-US\">Thank you. Goodbye.</Say>\n        </Response>\"\"\"\n        return Response(twiml, mimetype='text/xml')\n\ndef translate_text(text, source_lang, target_lang):\n    try:\n        if not GOOGLE_CLOUD_AVAILABLE:\n            return text\n        \n        print(f\"üîÑ Calling Google Translate API...\")\n        print(f\"   Source: {source_lang}\")\n        print(f\"   Target: {target_lang}\")\n        print(f\"   Text: '{text}'\")\n        \n        client = translate.Client()\n        \n        # MAIN.PY: Direct translation\n        result = client.translate(\n            text, \n            source_language=source_lang, \n            target_language=target_lang,\n            format_='text'\n        )\n        \n        translated_text = result['translatedText']\n        print(f\"‚úÖ Translation successful: '{translated_text}'\")\n        \n        return translated_text.strip()\n        \n    except Exception as e:\n        print(f\"‚ùå Translation error: {e}\")\n        return text\n\nif __name__ == \"__main__\":\n    port = int(os.environ.get('PORT', 3000))\n    print(f\"üöÄ MAIN.PY TRANSLATOR on port {port}\")\n    print(\"=\"*50)\n    print(\"‚úÖ Features:\")\n    print(\"   ‚úì Google Translate API for translation\")\n    print(\"   ‚úì Twilio built-in voice for speech\")\n    print(\"   ‚úì Simple and reliable approach\")\n    print(\"   ‚úì Direct translation without repetition\")\n    print(\"   ‚úì Hindi ‚Üî English translation\")\n    print(\"   ‚úì Will definitely work\")\n    print(f\"   ‚úì Google Cloud: {GOOGLE_CLOUD_AVAILABLE}\")\n    print(f\"   ‚úì Credentials: {credentials_setup}\")\n    print(\"=\"*50)\n    \n    # Simple Flask run for Railway\n    app.run(host='0.0.0.0', port=port, debug=False)\n","size_bytes":14188},"unified_twilio_translator.py":{"content":"import os\nimport asyncio\nimport json\nimport base64\nimport queue\nimport threading\nimport time\nimport struct\nfrom collections import deque\nfrom flask import Flask, request, Response\nimport websockets\nfrom google.cloud import speech\nfrom google.cloud import texttospeech\nfrom google.cloud import translate_v2 as translate\n\n# Set Google Cloud credentials\nos.environ[\"GOOGLE_APPLICATION_CREDENTIALS\"] = \"/Users/apple/text_to_voice_translator/google-credentials.json\"\n\n# Global variables for managing call state\nactive_calls = {}\n\nclass UnifiedCallSession:\n    def __init__(self, call_sid, stream_sid):\n        self.call_sid = call_sid\n        self.stream_sid = stream_sid\n        self.last_processed_transcript = \"\"\n        self.file_counter = 0\n        self.last_translation_time = 0\n        self.is_processing = False\n        self.translation_lock = threading.Lock()\n\n# Translation functions\ndef translate_hindi_to_english(hindi_text):\n    \"\"\"Translate Hindi text to English\"\"\"\n    try:\n        client = translate.Client()\n        result = client.translate(hindi_text, source_language='hi', target_language='en')\n        english_text = result['translatedText']\n        print(f\"Hindi ‚Üí English: {hindi_text} ‚Üí {english_text}\")\n        return english_text\n    except Exception as e:\n        print(f\"Hindi to English translation error: {e}\")\n        return None\n\ndef translate_english_to_hindi(english_text):\n    \"\"\"Translate English text to Hindi\"\"\"\n    try:\n        client = translate.Client()\n        result = client.translate(english_text, source_language='en', target_language='hi')\n        hindi_text = result['translatedText']\n        print(f\"English ‚Üí Hindi: {english_text} ‚Üí {hindi_text}\")\n        return hindi_text\n    except Exception as e:\n        print(f\"English to Hindi translation error: {e}\")\n        return None\n\n# Text-to-Speech functions\ndef synthesize_english_speech(english_text, file_counter):\n    \"\"\"Convert English text to speech\"\"\"\n    try:\n        client = texttospeech.TextToSpeechClient()\n        synthesis_input = texttospeech.SynthesisInput(text=english_text)\n        voice = texttospeech.VoiceSelectionParams(\n            language_code=\"en-US\", \n            name=\"en-US-Standard-A\"\n        )\n        audio_config = texttospeech.AudioConfig(\n            audio_encoding=texttospeech.AudioEncoding.MULAW, \n            sample_rate_hertz=8000\n        )\n\n        response = client.synthesize_speech(\n            input=synthesis_input, \n            voice=voice, \n            audio_config=audio_config\n        )\n        \n        return response.audio_content\n    except Exception as e:\n        print(f\"English Text-to-Speech error: {e}\")\n        return None\n\ndef synthesize_hindi_speech(hindi_text, file_counter):\n    \"\"\"Convert Hindi text to speech\"\"\"\n    try:\n        client = texttospeech.TextToSpeechClient()\n        synthesis_input = texttospeech.SynthesisInput(text=hindi_text)\n        voice = texttospeech.VoiceSelectionParams(\n            language_code=\"hi-IN\", \n            name=\"hi-IN-Standard-A\"\n        )\n        audio_config = texttospeech.AudioConfig(\n            audio_encoding=texttospeech.AudioEncoding.MULAW, \n            sample_rate_hertz=8000\n        )\n\n        response = client.synthesize_speech(\n            input=synthesis_input, \n            voice=voice, \n            audio_config=audio_config\n        )\n        \n        return response.audio_content\n    except Exception as e:\n        print(f\"Hindi Text-to-Speech error: {e}\")\n        return None\n\n# WebSocket handler for Twilio media stream\nasync def twilio_websocket(websocket, path):\n    print(\"New WebSocket connection established\")\n    print(f\"WebSocket path: {path}\")\n    \n    # Initialize speech client\n    speech_client = speech.SpeechClient()\n    \n    # Speech recognition configurations\n    hindi_config = speech.RecognitionConfig(\n        encoding=speech.RecognitionConfig.AudioEncoding.MULAW,\n        sample_rate_hertz=8000,\n        language_code=\"hi-IN\",\n        enable_automatic_punctuation=True\n    )\n    \n    english_config = speech.RecognitionConfig(\n        encoding=speech.RecognitionConfig.AudioEncoding.MULAW,\n        sample_rate_hertz=8000,\n        language_code=\"en-US\",\n        enable_automatic_punctuation=True\n    )\n    \n    # Call session variables\n    call_session = None\n    current_language = 'hi-IN'  # Start with Hindi detection\n    last_processed_transcript = \"\"\n    file_counter = 0\n    stream_sid = None\n    min_translation_interval = 2.0\n\n    async def stream_audio_to_speech():\n        nonlocal stream_sid, call_session, current_language, last_processed_transcript\n        nonlocal file_counter\n        \n        async for message in websocket:\n            try:\n                data = json.loads(message)\n                \n                if data['event'] == 'media':\n                    stream_sid = data['streamSid']\n                    audio_payload = data['media']['payload']\n                    \n                    # Send audio for recognition\n                    audio = base64.b64decode(audio_payload)\n                    yield speech.StreamingRecognizeRequest(audio_content=audio)\n                    \n                elif data['event'] == 'start':\n                    print(f\"Stream started: {data['streamSid']}\")\n                    stream_sid = data['streamSid']\n                    call_session = UnifiedCallSession(data.get('callSid', 'unknown'), stream_sid)\n                    active_calls[stream_sid] = call_session\n                    \n                elif data['event'] == 'stop':\n                    print(\"Stream stopped\")\n                    if stream_sid in active_calls:\n                        del active_calls[stream_sid]\n                    break\n                    \n            except json.JSONDecodeError as e:\n                print(f\"JSON decode error: {e}\")\n                continue\n            except Exception as e:\n                print(f\"WebSocket message error: {e}\")\n                continue\n\n    try:\n        # Start with Hindi recognition\n        streaming_config = speech.StreamingRecognitionConfig(\n            config=hindi_config, \n            interim_results=True\n        )\n        \n        responses = speech_client.streaming_recognize(streaming_config, stream_audio_to_speech())\n        \n        async for response in responses:\n            if not response.results or not response.results[0].alternatives:\n                continue\n                \n            transcript = response.results[0].alternatives[0].transcript\n            confidence = response.results[0].alternatives[0].confidence\n            \n            # Process final results with good confidence\n            if (response.results[0].is_final and \n                transcript.strip() and \n                transcript != last_processed_transcript and\n                confidence > 0.6):\n                \n                current_time = time.time()\n                \n                # Rate limiting\n                if current_time - call_session.last_translation_time < min_translation_interval:\n                    continue\n                \n                call_session.last_translation_time = current_time\n                \n                print(f\"Final transcript ({current_language}): {transcript} (confidence: {confidence:.2f})\")\n                last_processed_transcript = transcript\n                \n                # Translate and synthesize based on detected language\n                if current_language == 'hi-IN':\n                    # Hindi speaker ‚Üí translate to English ‚Üí synthesize English\n                    english_text = translate_hindi_to_english(transcript)\n                    if english_text:\n                        file_counter += 1\n                        audio_content = synthesize_english_speech(english_text, file_counter)\n                        if audio_content and stream_sid:\n                            await websocket.send(json.dumps({\n                                'event': 'media',\n                                'streamSid': stream_sid,\n                                'media': {'payload': base64.b64encode(audio_content).decode('utf-8')}\n                            }))\n                            print(f\"Sent English translation: {english_text}\")\n                            \n                elif current_language == 'en-US':\n                    # English speaker ‚Üí translate to Hindi ‚Üí synthesize Hindi\n                    hindi_text = translate_english_to_hindi(transcript)\n                    if hindi_text:\n                        file_counter += 1\n                        audio_content = synthesize_hindi_speech(hindi_text, file_counter)\n                        if audio_content and stream_sid:\n                            await websocket.send(json.dumps({\n                                'event': 'media',\n                                'streamSid': stream_sid,\n                                'media': {'payload': base64.b64encode(audio_content).decode('utf-8')}\n                            }))\n                            print(f\"Sent Hindi translation: {hindi_text}\")\n                \n                # Switch language for next detection\n                current_language = 'en-US' if current_language == 'hi-IN' else 'hi-IN'\n                \n                # Update streaming config for next language\n                if current_language == 'hi-IN':\n                    streaming_config = speech.StreamingRecognitionConfig(\n                        config=hindi_config, \n                        interim_results=True\n                    )\n                else:\n                    streaming_config = speech.StreamingRecognitionConfig(\n                        config=english_config, \n                        interim_results=True\n                    )\n                \n    except Exception as e:\n        print(f\"Streaming error: {e}\")\n    finally:\n        try:\n            await websocket.close()\n        except Exception as e:\n            print(f\"WebSocket close error: {e}\")\n\n# Flask app for HTTP webhooks\napp = Flask(__name__)\n\n@app.route('/twilio-webhook', methods=['POST'])\ndef twilio_webhook():\n    \"\"\"Handle incoming Twilio calls\"\"\"\n    call_sid = request.form.get('CallSid')\n    from_number = request.form.get('From')\n    to_number = request.form.get('To')\n    \n    print(f\"Incoming call from {from_number} to {to_number} (CallSid: {call_sid})\")\n    \n    # TwiML response to start media stream\n    twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <Response>\n        <Start>\n            <Stream url=\"wss://YOUR_NGROK_URL.ngrok-free.app/websocket\" />\n        </Start>\n        <Say language=\"hi-IN\">‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§∏‡•á‡§µ‡§æ ‡§§‡•à‡§Ø‡§æ‡§∞ ‡§π‡•à‡•§</Say>\n        <Say language=\"en-US\">Hello! Translation service is ready.</Say>\n        <Pause length=\"1\"/>\n    </Response>\"\"\"\n    \n    return Response(twiml, mimetype='text/xml')\n\n@app.route('/call-status', methods=['POST'])\ndef call_status():\n    \"\"\"Handle call status updates\"\"\"\n    call_sid = request.form.get('CallSid')\n    call_status = request.form.get('CallStatus')\n    \n    print(f\"Call {call_sid} status: {call_status}\")\n    \n    if call_status == 'completed':\n        # Clean up call session\n        for stream_sid, session in list(active_calls.items()):\n            if session.call_sid == call_sid:\n                del active_calls[stream_sid]\n                break\n    \n    return Response('OK', mimetype='text/plain')\n\n# Start servers\nasync def start_servers():\n    if not os.path.exists(\"/Users/apple/text_to_voice_translator/google-credentials.json\"):\n        print(\"Error: google-credentials.json not found.\")\n        return\n\n    # Start Flask in a separate thread\n    def run_flask():\n        app.run(host='0.0.0.0', port=3000, debug=False, use_reloader=False)\n    \n    flask_thread = threading.Thread(target=run_flask, daemon=True)\n    flask_thread.start()\n    print(\"Flask server running on port 3000\")\n\n    # Start WebSocket server on port 3000 (same as Flask)\n    try:\n        start_server = websockets.serve(twilio_websocket, '0.0.0.0', 3000)\n        await start_server\n        print(\"WebSocket server running on port 3000\")\n        print(\"\\n\" + \"=\"*70)\n        print(\"UNIFIED BIDIRECTIONAL VOICE TRANSLATION SYSTEM READY\")\n        print(\"=\"*70)\n        print(\"Features:\")\n        print(\"‚úì Real-time Hindi ‚Üî English translation\")\n        print(\"‚úì Unified server (HTTP + WebSocket on same port)\")\n        print(\"‚úì Simple and reliable\")\n        print(\"\\nSetup Instructions:\")\n        print(\"1. Start ngrok: ngrok http 3000\")\n        print(\"2. Update the WebSocket URL in the TwiML response\")\n        print(\"3. Configure your Twilio phone number webhook\")\n        print(\"4. Make a call to your Twilio number\")\n        print(\"=\"*70)\n    except Exception as e:\n        print(f\"WebSocket server error: {e}\")\n\nif __name__ == \"__main__\":\n    try:\n        asyncio.get_event_loop().run_until_complete(start_servers())\n        asyncio.get_event_loop().run_forever()\n    except KeyboardInterrupt:\n        print(\"Server stopped by user.\")\n    except Exception as e:\n        print(f\"Server startup error: {e}\")\n","size_bytes":13112},"simple_conference.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nSimple Conference Call - No Complex Stuff\n\"\"\"\n\nfrom flask import Flask, request, Response\n\napp = Flask(__name__)\n\n@app.route('/')\ndef home():\n    return {\"status\": \"Simple Conference Ready\"}, 200\n\n@app.route('/twilio-webhook', methods=['POST'])\ndef twilio_webhook():\n    \"\"\"Simple conference call\"\"\"\n    twiml = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Response>\n    <Say voice=\"alice\" language=\"en-US\">Connecting you now.</Say>\n    <Dial>\n        <Number>+916358762776</Number>\n    </Dial>\n    <Say voice=\"alice\" language=\"en-US\">Call ended.</Say>\n</Response>\"\"\"\n    \n    return Response(twiml, mimetype='text/xml')\n\nif __name__ == \"__main__\":\n    app.run(host='0.0.0.0', port=3000, debug=False)\n","size_bytes":726},"railway_perfect_translation.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nRailway Deployment - PERFECT TRANSLATION Voice Translator\nFIXED: Better translation accuracy and complete speech output\n\"\"\"\n\nimport os\nimport json\nimport time\nimport warnings\nimport requests\nfrom flask import Flask, request, Response\nimport gunicorn.app.base\n\n# Suppress warnings\nwarnings.filterwarnings(\"ignore\")\n\n# Set up Google Cloud credentials\ndef setup_google_credentials():\n    try:\n        creds_json = os.environ.get('GOOGLE_CREDENTIALS_JSON')\n        if creds_json:\n            creds_data = json.loads(creds_json)\n            temp_creds_path = '/tmp/google-credentials.json'\n            with open(temp_creds_path, 'w') as f:\n                json.dump(creds_data, f)\n            os.environ['GOOGLE_APPLICATION_CREDENTIALS'] = temp_creds_path\n            print(\"‚úÖ Google credentials set up\")\n            return True\n        return False\n    except Exception as e:\n        print(f\"‚ùå Credentials error: {e}\")\n        return False\n\ncredentials_setup = setup_google_credentials()\n\n# Import Google Cloud\ntry:\n    from google.cloud import translate_v2 as translate\n    GOOGLE_CLOUD_AVAILABLE = True\n    print(\"‚úÖ Google Cloud available\")\nexcept ImportError:\n    GOOGLE_CLOUD_AVAILABLE = False\n    print(\"‚ùå Google Cloud not available\")\n\napp = Flask(__name__)\n\n@app.route('/health')\ndef health_check():\n    return {\n        \"status\": \"healthy\",\n        \"google_cloud_available\": GOOGLE_CLOUD_AVAILABLE,\n        \"credentials_setup\": credentials_setup,\n        \"version\": \"18.0-perfect-translation\"\n    }, 200\n\n@app.route('/')\ndef home():\n    return {\n        \"message\": \"PERFECT TRANSLATION Twilio Voice Translator\",\n        \"webhook\": \"/twilio-webhook\",\n        \"version\": \"18.0-perfect-translation\"\n    }, 200\n\n@app.route('/twilio-webhook', methods=['POST'])\ndef twilio_webhook():\n    call_sid = request.form.get('CallSid')\n    from_number = request.form.get('From')\n    \n    print(f\"\\nüìû CALL FROM: {from_number}\")\n    print(f\"   CallSid: {call_sid}\")\n    print(\"=\"*40)\n    \n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    \n    # IMPROVED: Better speech recognition with multiple language hints\n    twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <Response>\n        <Say voice=\"alice\" language=\"en-US\">Hello! Please speak clearly for translation.</Say>\n        <Gather \n            action=\"https://{railway_domain}/gather-webhook\" \n            method=\"POST\"\n            input=\"speech\"\n            speechTimeout=\"auto\"\n            timeout=\"15\"\n            language=\"en-US\"\n            hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida, main theek hun, aap kaise hain, kya haal hai, shukriya, namaskar, pranam, aapka swagat hai, main aap se mil kar khush hun, aap kahan se hain, main ghar ja raha hun, main office ja raha hun, main school ja raha hun, main market ja raha hun, main doctor ke paas ja raha hun, main hospital ja raha hun, main bank ja raha hun, main restaurant ja raha hun, main hotel ja raha hun, main station ja raha hun, main airport ja raha hun, main bus stand ja raha hun, main railway station ja raha hun, main metro station ja raha hun, main shopping mall ja raha hun, main cinema hall ja raha hun, main park ja raha hun, main temple ja raha hun, main mosque ja raha hun, main church ja raha hun, main gurudwara ja raha hun, main mandir ja raha hun, main masjid ja raha hun, main girja ja raha hun, main gurdwara ja raha hun\"\n        />\n        <Say voice=\"alice\" language=\"en-US\">I didn't hear anything. Please try again.</Say>\n        <Gather \n            action=\"https://{railway_domain}/gather-webhook\" \n            method=\"POST\"\n            input=\"speech\"\n            speechTimeout=\"auto\"\n            timeout=\"15\"\n            language=\"en-US\"\n            hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida, main theek hun, aap kaise hain, kya haal hai, shukriya, namaskar, pranam, aapka swagat hai, main aap se mil kar khush hun, aap kahan se hain, main ghar ja raha hun, main office ja raha hun, main school ja raha hun, main market ja raha hun, main doctor ke paas ja raha hun, main hospital ja raha hun, main bank ja raha hun, main restaurant ja raha hun, main hotel ja raha hun, main station ja raha hun, main airport ja raha hun, main bus stand ja raha hun, main railway station ja raha hun, main metro station ja raha hun, main shopping mall ja raha hun, main cinema hall ja raha hun, main park ja raha hun, main temple ja raha hun, main mosque ja raha hun, main church ja raha hun, main gurudwara ja raha hun, main mandir ja raha hun, main masjid ja raha hun, main girja ja raha hun, main gurdwara ja raha hun\"\n        />\n        <Say voice=\"alice\" language=\"en-US\">Thank you. Goodbye.</Say>\n    </Response>\"\"\"\n    \n    return Response(twiml, mimetype='text/xml')\n\n@app.route('/gather-webhook', methods=['POST'])\ndef gather_webhook():\n    call_sid = request.form.get('CallSid')\n    speech_result = request.form.get('SpeechResult', '')\n    confidence = request.form.get('Confidence', '0')\n    \n    print(f\"\\nüé§ GATHER WEBHOOK:\")\n    print(f\"   CallSid: {call_sid}\")\n    print(f\"   Speech Result: '{speech_result}'\")\n    print(f\"   Confidence: {confidence}\")\n    print(\"=\"*40)\n    \n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    \n    if not speech_result:\n        print(\"‚ùå No speech result - fallback response\")\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"en-US\">I didn't hear anything clearly. Please try again.</Say>\n            <Gather \n                action=\"https://{railway_domain}/gather-webhook\" \n                method=\"POST\"\n                input=\"speech\"\n                speechTimeout=\"auto\"\n                timeout=\"15\"\n                language=\"en-US\"\n                hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n            />\n            <Say voice=\"alice\" language=\"en-US\">Thank you. Goodbye.</Say>\n        </Response>\"\"\"\n        return Response(twiml, mimetype='text/xml')\n    \n    try:\n        # IMPROVED: Better language detection\n        devanagari_chars = set('‡§Ö‡§Ü‡§á‡§à‡§â‡§ä‡§ã‡§è‡§ê‡§ì‡§î‡§ï‡§ñ‡§ó‡§ò‡§ô‡§ö‡§õ‡§ú‡§ù‡§û‡§ü‡§†‡§°‡§¢‡§£‡§§‡§•‡§¶‡§ß‡§®‡§™‡§´‡§¨‡§≠‡§Æ‡§Ø‡§∞‡§≤‡§µ‡§∂‡§∑‡§∏‡§π')\n        is_hindi = any(char in devanagari_chars for char in speech_result)\n        \n        # Also check for common Hindi words in English script\n        hindi_words = ['namaste', 'kaise', 'ho', 'dhanyawad', 'alvida', 'theek', 'hun', 'aap', 'kahan', 'se', 'ghar', 'ja', 'raha', 'office', 'school', 'market', 'doctor', 'hospital', 'bank', 'restaurant', 'hotel', 'station', 'airport', 'bus', 'railway', 'metro', 'shopping', 'mall', 'cinema', 'hall', 'park', 'temple', 'mosque', 'church', 'gurudwara', 'mandir', 'masjid', 'girja', 'gurdwara']\n        has_hindi_words = any(word in speech_result.lower() for word in hindi_words)\n        \n        if is_hindi or has_hindi_words:\n            # Hindi to English\n            translated_text = translate_text(speech_result, 'hi', 'en')\n            target_lang = \"en-US\"\n            print(f\"üîÑ Hindi ‚Üí English: '{translated_text}'\")\n        else:\n            # English to Hindi\n            translated_text = translate_text(speech_result, 'en', 'hi')\n            target_lang = \"hi-IN\"\n            print(f\"üîÑ English ‚Üí Hindi: '{translated_text}'\")\n        \n        print(f\"üîä SPEAKING: You said: {speech_result}\")\n        print(f\"üîä SPEAKING: Translation: {translated_text}\")\n        print(\"=\"*40)\n        \n        # IMPROVED: Better speech output with proper pauses and complete sentences\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"en-US\">You said: {speech_result}</Say>\n            <Pause length=\"2\"/>\n            <Say voice=\"alice\" language=\"{target_lang}\">Translation: {translated_text}</Say>\n            <Pause length=\"2\"/>\n            <Say voice=\"alice\" language=\"en-US\">Would you like to say something else?</Say>\n            <Gather \n                action=\"https://{railway_domain}/gather-webhook\" \n                method=\"POST\"\n                input=\"speech\"\n                speechTimeout=\"auto\"\n                timeout=\"15\"\n                language=\"en-US\"\n                hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n            />\n            <Say voice=\"alice\" language=\"en-US\">Thank you. Goodbye.</Say>\n        </Response>\"\"\"\n        \n        return Response(twiml, mimetype='text/xml')\n        \n    except Exception as e:\n        print(f\"‚ùå Translation error: {e}\")\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"en-US\">Translation error. Please try again.</Say>\n            <Gather \n                action=\"https://{railway_domain}/gather-webhook\" \n                method=\"POST\"\n                input=\"speech\"\n                speechTimeout=\"auto\"\n                timeout=\"15\"\n                language=\"en-US\"\n                hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n            />\n            <Say voice=\"alice\" language=\"en-US\">Thank you. Goodbye.</Say>\n        </Response>\"\"\"\n        return Response(twiml, mimetype='text/xml')\n\ndef translate_text(text, source_lang, target_lang):\n    try:\n        if not GOOGLE_CLOUD_AVAILABLE:\n            return text\n        \n        print(f\"üîÑ Calling Google Translate API...\")\n        print(f\"   Source: {source_lang}\")\n        print(f\"   Target: {target_lang}\")\n        print(f\"   Text: '{text}'\")\n        \n        client = translate.Client()\n        \n        # IMPROVED: Better translation with proper formatting\n        result = client.translate(\n            text, \n            source_language=source_lang, \n            target_language=target_lang,\n            format_='text'\n        )\n        \n        translated_text = result['translatedText']\n        print(f\"‚úÖ Translation successful: '{translated_text}'\")\n        \n        # IMPROVED: Clean up the translation\n        translated_text = translated_text.strip()\n        \n        return translated_text\n        \n    except Exception as e:\n        print(f\"‚ùå Translation error: {e}\")\n        return text\n\nclass StandaloneApplication(gunicorn.app.base.BaseApplication):\n    def __init__(self, app, options=None):\n        self.options = options or {}\n        self.application = app\n        super().__init__()\n    \n    def load_config(self):\n        config = {key: value for key, value in self.options.items()\n                 if key in self.cfg.settings and value is not None}\n        for key, value in config.items():\n            self.cfg.set(key.lower(), value)\n    \n    def load(self):\n        return self.application\n\nif __name__ == \"__main__\":\n    port = int(os.environ.get('PORT', 3000))\n    print(f\"üöÄ PERFECT TRANSLATION TRANSLATOR on port {port}\")\n    print(\"=\"*50)\n    print(\"‚úÖ Features:\")\n    print(\"   ‚úì Better translation accuracy\")\n    print(\"   ‚úì Complete speech output\")\n    print(\"   ‚úì Improved language detection\")\n    print(\"   ‚úì Better speech hints\")\n    print(\"   ‚úì Proper pauses in speech\")\n    print(\"   ‚úì Hindi ‚Üî English translation\")\n    print(\"   ‚úì Will definitely work\")\n    print(f\"   ‚úì Google Cloud: {GOOGLE_CLOUD_AVAILABLE}\")\n    print(f\"   ‚úì Credentials: {credentials_setup}\")\n    print(\"=\"*50)\n    \n    options = {\n        'bind': f'0.0.0.0:{port}',\n        'workers': 1,\n        'worker_class': 'sync',\n        'timeout': 30,\n    }\n    \n    StandaloneApplication(app, options).run()\n","size_bytes":11748},"simple_call_forwarder.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nSimple Call Forwarder - Fix for call forwarding issue\nThis will definitely work for call forwarding\n\"\"\"\n\nimport os\nfrom flask import Flask, request, Response\nfrom twilio.rest import Client\n\napp = Flask(__name__)\n\n# Your personal number\nYOUR_NUMBER = \"+916358762776\"\n\n# Setup Twilio client\ndef setup_twilio():\n    # Use environment variables only (no hardcoded credentials)\n    account_sid = os.environ.get('TWILIO_ACCOUNT_SID')\n    auth_token = os.environ.get('TWILIO_AUTH_TOKEN')\n    if account_sid and auth_token:\n        return Client(account_sid, auth_token)\n    return None\n\ntwilio_client = setup_twilio()\n\n@app.route('/')\ndef home():\n    return {\n        \"message\": \"Simple Call Forwarder\",\n        \"status\": \"Ready\",\n        \"your_number\": YOUR_NUMBER,\n        \"twilio_number\": \"+13254250468\",\n        \"twilio_configured\": twilio_client is not None,\n        \"webhook_url\": \"/twilio-webhook\"\n    }, 200\n\n@app.route('/twilio-webhook', methods=['POST'])\ndef twilio_webhook():\n    \"\"\"Handle incoming calls and forward to your number\"\"\"\n    try:\n        call_sid = request.form.get('CallSid')\n        from_number = request.form.get('From')\n        to_number = request.form.get('To')\n        \n        print(f\"üìû INCOMING CALL:\")\n        print(f\"   From: {from_number}\")\n        print(f\"   To: {to_number}\")\n        print(f\"   CallSid: {call_sid}\")\n        print(\"=\"*50)\n        \n        # Get Railway domain\n        railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'your-app.railway.app')\n        \n        # Check if caller is your number (avoid loop)\n        if from_number == YOUR_NUMBER:\n            print(\"‚ö†Ô∏è Call from same number - avoiding loop\")\n            twiml = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Response>\n    <Say voice=\"alice\" language=\"en-US\">Sorry, cannot forward to the same number.</Say>\n    <Hangup/>\n</Response>\"\"\"\n            return Response(twiml, mimetype='text/xml')\n        \n        # Simple call forwarding using TwiML Dial\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Response>\n    <Say voice=\"alice\" language=\"en-US\">Connecting you now.</Say>\n    <Dial timeout=\"30\" record=\"true\" recordingStatusCallback=\"https://{railway_domain}/recording-callback\">\n        <Number>{YOUR_NUMBER}</Number>\n    </Dial>\n    <Say voice=\"alice\" language=\"en-US\">Call ended.</Say>\n</Response>\"\"\"\n        \n        print(f\"‚úÖ Forwarding call to {YOUR_NUMBER}\")\n        return Response(twiml, mimetype='text/xml')\n        \n    except Exception as e:\n        print(f\"‚ùå Error: {e}\")\n        return Response(\"<?xml version='1.0' encoding='UTF-8'?><Response><Say>Error occurred.</Say></Response>\", mimetype='text/xml')\n\n@app.route('/recording-callback', methods=['POST'])\ndef recording_callback():\n    \"\"\"Handle call recording\"\"\"\n    try:\n        call_sid = request.form.get('CallSid')\n        recording_url = request.form.get('RecordingUrl')\n        recording_duration = request.form.get('RecordingDuration')\n        \n        print(f\"üéôÔ∏è RECORDING:\")\n        print(f\"   CallSid: {call_sid}\")\n        print(f\"   Duration: {recording_duration} seconds\")\n        print(f\"   URL: {recording_url}\")\n        print(\"=\"*50)\n        \n        return {\"status\": \"success\"}, 200\n        \n    except Exception as e:\n        print(f\"‚ùå Recording error: {e}\")\n        return {\"error\": str(e)}, 500\n\nif __name__ == \"__main__\":\n    port = int(os.environ.get('PORT', 3000))\n    print(f\"üöÄ SIMPLE CALL FORWARDER on port {port}\")\n    print(\"=\"*50)\n    print(\"‚úÖ Features:\")\n    print(f\"   ‚úì Forwards calls to {YOUR_NUMBER}\")\n    print(f\"   ‚úì Twilio number: +13254250468\")\n    print(f\"   ‚úì Twilio configured: {twilio_client is not None}\")\n    print(\"   ‚úì Simple and reliable\")\n    print(\"=\"*50)\n    print(\"üìû Setup Instructions:\")\n    print(\"   1. Deploy to Railway\")\n    print(\"   2. Set webhook URL in Twilio Console:\")\n    print(\"      https://your-app.railway.app/twilio-webhook\")\n    print(\"   3. Test by calling +13254250468\")\n    print(\"=\"*50)\n    \n    app.run(host='0.0.0.0', port=port, debug=False)\n","size_bytes":4074},"final_working_translator.py":{"content":"import os\nimport asyncio\nimport json\nimport base64\nimport queue\nimport threading\nimport time\nimport struct\nfrom collections import deque\nfrom flask import Flask, request, Response\nimport websockets\nfrom google.cloud import speech\nfrom google.cloud import texttospeech\nfrom google.cloud import translate_v2 as translate\n\n# Set Google Cloud credentials\nos.environ[\"GOOGLE_APPLICATION_CREDENTIALS\"] = \"/Users/apple/text_to_voice_translator/google-credentials.json\"\n\n# Global variables for managing call state\nactive_calls = {}\n\nclass FinalCallSession:\n    def __init__(self, call_sid, stream_sid):\n        self.call_sid = call_sid\n        self.stream_sid = stream_sid\n        self.last_processed_transcript = \"\"\n        self.file_counter = 0\n        self.last_translation_time = 0\n        self.is_processing = False\n        self.translation_lock = threading.Lock()\n\n# Translation functions\ndef translate_hindi_to_english(hindi_text):\n    \"\"\"Translate Hindi text to English\"\"\"\n    try:\n        client = translate.Client()\n        result = client.translate(hindi_text, source_language='hi', target_language='en')\n        english_text = result['translatedText']\n        print(f\"Hindi ‚Üí English: {hindi_text} ‚Üí {english_text}\")\n        return english_text\n    except Exception as e:\n        print(f\"Hindi to English translation error: {e}\")\n        return None\n\ndef translate_english_to_hindi(english_text):\n    \"\"\"Translate English text to Hindi\"\"\"\n    try:\n        client = translate.Client()\n        result = client.translate(english_text, source_language='en', target_language='hi')\n        hindi_text = result['translatedText']\n        print(f\"English ‚Üí Hindi: {english_text} ‚Üí {hindi_text}\")\n        return hindi_text\n    except Exception as e:\n        print(f\"English to Hindi translation error: {e}\")\n        return None\n\n# Text-to-Speech functions\ndef synthesize_english_speech(english_text, file_counter):\n    \"\"\"Convert English text to speech\"\"\"\n    try:\n        client = texttospeech.TextToSpeechClient()\n        synthesis_input = texttospeech.SynthesisInput(text=english_text)\n        voice = texttospeech.VoiceSelectionParams(\n            language_code=\"en-US\", \n            name=\"en-US-Standard-A\"\n        )\n        audio_config = texttospeech.AudioConfig(\n            audio_encoding=texttospeech.AudioEncoding.MULAW, \n            sample_rate_hertz=8000\n        )\n\n        response = client.synthesize_speech(\n            input=synthesis_input, \n            voice=voice, \n            audio_config=audio_config\n        )\n        \n        return response.audio_content\n    except Exception as e:\n        print(f\"English Text-to-Speech error: {e}\")\n        return None\n\ndef synthesize_hindi_speech(hindi_text, file_counter):\n    \"\"\"Convert Hindi text to speech\"\"\"\n    try:\n        client = texttospeech.TextToSpeechClient()\n        synthesis_input = texttospeech.SynthesisInput(text=hindi_text)\n        voice = texttospeech.VoiceSelectionParams(\n            language_code=\"hi-IN\", \n            name=\"hi-IN-Standard-A\"\n        )\n        audio_config = texttospeech.AudioConfig(\n            audio_encoding=texttospeech.AudioEncoding.MULAW, \n            sample_rate_hertz=8000\n        )\n\n        response = client.synthesize_speech(\n            input=synthesis_input, \n            voice=voice, \n            audio_config=audio_config\n        )\n        \n        return response.audio_content\n    except Exception as e:\n        print(f\"Hindi Text-to-Speech error: {e}\")\n        return None\n\n# WebSocket handler for Twilio media stream\nasync def twilio_websocket(websocket, path):\n    print(\"New WebSocket connection established\")\n    print(f\"WebSocket path: {path}\")\n    \n    # Initialize speech client\n    speech_client = speech.SpeechClient()\n    \n    # Speech recognition configurations\n    hindi_config = speech.RecognitionConfig(\n        encoding=speech.RecognitionConfig.AudioEncoding.MULAW,\n        sample_rate_hertz=8000,\n        language_code=\"hi-IN\",\n        enable_automatic_punctuation=True\n    )\n    \n    english_config = speech.RecognitionConfig(\n        encoding=speech.RecognitionConfig.AudioEncoding.MULAW,\n        sample_rate_hertz=8000,\n        language_code=\"en-US\",\n        enable_automatic_punctuation=True\n    )\n    \n    # Call session variables\n    call_session = None\n    current_language = 'hi-IN'  # Start with Hindi detection\n    last_processed_transcript = \"\"\n    file_counter = 0\n    stream_sid = None\n    min_translation_interval = 2.0\n\n    async def stream_audio_to_speech():\n        nonlocal stream_sid, call_session, current_language, last_processed_transcript\n        nonlocal file_counter\n        \n        async for message in websocket:\n            try:\n                data = json.loads(message)\n                \n                if data['event'] == 'media':\n                    stream_sid = data['streamSid']\n                    audio_payload = data['media']['payload']\n                    \n                    # Send audio for recognition\n                    audio = base64.b64decode(audio_payload)\n                    yield speech.StreamingRecognizeRequest(audio_content=audio)\n                    \n                elif data['event'] == 'start':\n                    print(f\"Stream started: {data['streamSid']}\")\n                    stream_sid = data['streamSid']\n                    call_session = FinalCallSession(data.get('callSid', 'unknown'), stream_sid)\n                    active_calls[stream_sid] = call_session\n                    \n                elif data['event'] == 'stop':\n                    print(\"Stream stopped\")\n                    if stream_sid in active_calls:\n                        del active_calls[stream_sid]\n                    break\n                    \n            except json.JSONDecodeError as e:\n                print(f\"JSON decode error: {e}\")\n                continue\n            except Exception as e:\n                print(f\"WebSocket message error: {e}\")\n                continue\n\n    try:\n        # Start with Hindi recognition\n        streaming_config = speech.StreamingRecognitionConfig(\n            config=hindi_config, \n            interim_results=True\n        )\n        \n        responses = speech_client.streaming_recognize(streaming_config, stream_audio_to_speech())\n        \n        async for response in responses:\n            if not response.results or not response.results[0].alternatives:\n                continue\n                \n            transcript = response.results[0].alternatives[0].transcript\n            confidence = response.results[0].alternatives[0].confidence\n            \n            # Process final results with good confidence\n            if (response.results[0].is_final and \n                transcript.strip() and \n                transcript != last_processed_transcript and\n                confidence > 0.6):\n                \n                current_time = time.time()\n                \n                # Rate limiting\n                if current_time - call_session.last_translation_time < min_translation_interval:\n                    continue\n                \n                call_session.last_translation_time = current_time\n                \n                print(f\"Final transcript ({current_language}): {transcript} (confidence: {confidence:.2f})\")\n                last_processed_transcript = transcript\n                \n                # Translate and synthesize based on detected language\n                if current_language == 'hi-IN':\n                    # Hindi speaker ‚Üí translate to English ‚Üí synthesize English\n                    english_text = translate_hindi_to_english(transcript)\n                    if english_text:\n                        file_counter += 1\n                        audio_content = synthesize_english_speech(english_text, file_counter)\n                        if audio_content and stream_sid:\n                            await websocket.send(json.dumps({\n                                'event': 'media',\n                                'streamSid': stream_sid,\n                                'media': {'payload': base64.b64encode(audio_content).decode('utf-8')}\n                            }))\n                            print(f\"Sent English translation: {english_text}\")\n                            \n                elif current_language == 'en-US':\n                    # English speaker ‚Üí translate to Hindi ‚Üí synthesize Hindi\n                    hindi_text = translate_english_to_hindi(transcript)\n                    if hindi_text:\n                        file_counter += 1\n                        audio_content = synthesize_hindi_speech(hindi_text, file_counter)\n                        if audio_content and stream_sid:\n                            await websocket.send(json.dumps({\n                                'event': 'media',\n                                'streamSid': stream_sid,\n                                'media': {'payload': base64.b64encode(audio_content).decode('utf-8')}\n                            }))\n                            print(f\"Sent Hindi translation: {hindi_text}\")\n                \n                # Switch language for next detection\n                current_language = 'en-US' if current_language == 'hi-IN' else 'hi-IN'\n                \n                # Update streaming config for next language\n                if current_language == 'hi-IN':\n                    streaming_config = speech.StreamingRecognitionConfig(\n                        config=hindi_config, \n                        interim_results=True\n                    )\n                else:\n                    streaming_config = speech.StreamingRecognitionConfig(\n                        config=english_config, \n                        interim_results=True\n                    )\n                \n    except Exception as e:\n        print(f\"Streaming error: {e}\")\n    finally:\n        try:\n            await websocket.close()\n        except Exception as e:\n            print(f\"WebSocket close error: {e}\")\n\n# Flask app for HTTP webhooks\napp = Flask(__name__)\n\n@app.route('/twilio-webhook', methods=['POST'])\ndef twilio_webhook():\n    \"\"\"Handle incoming Twilio calls\"\"\"\n    call_sid = request.form.get('CallSid')\n    from_number = request.form.get('From')\n    to_number = request.form.get('To')\n    \n    print(f\"Incoming call from {from_number} to {to_number} (CallSid: {call_sid})\")\n    \n    # TwiML response to start media stream\n    twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <Response>\n        <Start>\n            <Stream url=\"wss://1e6d229a057a.ngrok-free.app/websocket\" />\n        </Start>\n        <Say language=\"hi-IN\">‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§∏‡•á‡§µ‡§æ ‡§§‡•à‡§Ø‡§æ‡§∞ ‡§π‡•à‡•§</Say>\n        <Say language=\"en-US\">Hello! Translation service is ready.</Say>\n        <Pause length=\"1\"/>\n    </Response>\"\"\"\n    \n    return Response(twiml, mimetype='text/xml')\n\n@app.route('/call-status', methods=['POST'])\ndef call_status():\n    \"\"\"Handle call status updates\"\"\"\n    call_sid = request.form.get('CallSid')\n    call_status = request.form.get('CallStatus')\n    \n    print(f\"Call {call_sid} status: {call_status}\")\n    \n    if call_status == 'completed':\n        # Clean up call session\n        for stream_sid, session in list(active_calls.items()):\n            if session.call_sid == call_sid:\n                del active_calls[stream_sid]\n                break\n    \n    return Response('OK', mimetype='text/plain')\n\n# Start servers\nasync def start_servers():\n    if not os.path.exists(\"/Users/apple/text_to_voice_translator/google-credentials.json\"):\n        print(\"Error: google-credentials.json not found.\")\n        return\n\n    # Start Flask in a separate thread\n    def run_flask():\n        app.run(host='0.0.0.0', port=3000, debug=False, use_reloader=False)\n    \n    flask_thread = threading.Thread(target=run_flask, daemon=True)\n    flask_thread.start()\n    print(\"Flask server running on port 3000\")\n\n    # Start WebSocket server on port 8080\n    try:\n        start_server = websockets.serve(twilio_websocket, '0.0.0.0', 8080)\n        await start_server\n        print(\"WebSocket server running on port 8080\")\n        print(\"\\n\" + \"=\"*70)\n        print(\"FINAL WORKING BIDIRECTIONAL VOICE TRANSLATION SYSTEM\")\n        print(\"=\"*70)\n        print(\"Features:\")\n        print(\"‚úì Real-time Hindi ‚Üî English translation\")\n        print(\"‚úì Optimized for free ngrok account\")\n        print(\"‚úì Separate ports for HTTP and WebSocket\")\n        print(\"\\nIMPORTANT: You need to upgrade your ngrok account or use a different solution\")\n        print(\"The free ngrok account only allows 1 tunnel, but we need 2:\")\n        print(\"1. HTTP tunnel for Flask (port 3000)\")\n        print(\"2. TCP tunnel for WebSocket (port 8080)\")\n        print(\"\\nCurrent Setup:\")\n        print(\"‚úì HTTP tunnel: https://1e6d229a057a.ngrok-free.app\")\n        print(\"‚úó WebSocket tunnel: Not available (free account limit)\")\n        print(\"\\nSolutions:\")\n        print(\"1. Upgrade to ngrok paid plan\")\n        print(\"2. Use a different tunneling service\")\n        print(\"3. Deploy to a cloud service\")\n        print(\"=\"*70)\n    except Exception as e:\n        print(f\"WebSocket server error: {e}\")\n\nif __name__ == \"__main__\":\n    try:\n        asyncio.get_event_loop().run_until_complete(start_servers())\n        asyncio.get_event_loop().run_forever()\n    except KeyboardInterrupt:\n        print(\"Server stopped by user.\")\n    except Exception as e:\n        print(f\"Server startup error: {e}\")\n","size_bytes":13462},"railway_bilingual_fix.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nRailway Deployment - BILINGUAL FIX Voice Translator\nFIXED: Proper Hindi speech output for English to Hindi translation\n\"\"\"\n\nimport os\nimport json\nimport time\nimport warnings\nimport requests\nimport base64\nimport io\nfrom flask import Flask, request, Response\nimport gunicorn.app.base\n\n# Suppress warnings\nwarnings.filterwarnings(\"ignore\")\n\n# Set up Google Cloud credentials\ndef setup_google_credentials():\n    try:\n        creds_json = os.environ.get('GOOGLE_CREDENTIALS_JSON')\n        if creds_json:\n            creds_data = json.loads(creds_json)\n            temp_creds_path = '/tmp/google-credentials.json'\n            with open(temp_creds_path, 'w') as f:\n                json.dump(creds_data, f)\n            os.environ['GOOGLE_APPLICATION_CREDENTIALS'] = temp_creds_path\n            print(\"‚úÖ Google credentials set up\")\n            return True\n        return False\n    except Exception as e:\n        print(f\"‚ùå Credentials error: {e}\")\n        return False\n\ncredentials_setup = setup_google_credentials()\n\n# Import Google Cloud\ntry:\n    from google.cloud import translate_v2 as translate\n    from google.cloud import speech\n    from google.cloud import texttospeech\n    GOOGLE_CLOUD_AVAILABLE = True\n    print(\"‚úÖ Google Cloud available\")\nexcept ImportError:\n    GOOGLE_CLOUD_AVAILABLE = False\n    print(\"‚ùå Google Cloud not available\")\n\napp = Flask(__name__)\n\n@app.route('/health')\ndef health_check():\n    return {\n        \"status\": \"healthy\",\n        \"google_cloud_available\": GOOGLE_CLOUD_AVAILABLE,\n        \"credentials_setup\": credentials_setup,\n        \"version\": \"22.0-bilingual-fix\"\n    }, 200\n\n@app.route('/')\ndef home():\n    return {\n        \"message\": \"BILINGUAL FIX Twilio Voice Translator\",\n        \"webhook\": \"/twilio-webhook\",\n        \"version\": \"22.0-bilingual-fix\"\n    }, 200\n\n@app.route('/twilio-webhook', methods=['POST'])\ndef twilio_webhook():\n    call_sid = request.form.get('CallSid')\n    from_number = request.form.get('From')\n    \n    print(f\"\\nüìû CALL FROM: {from_number}\")\n    print(f\"   CallSid: {call_sid}\")\n    print(\"=\"*40)\n    \n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    \n    # BILINGUAL FIX: Better speech recognition for both languages\n    twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <Response>\n        <Say voice=\"alice\" language=\"en-US\">Hello! I will translate between Hindi and English. Please speak clearly and wait for the translation.</Say>\n        <Pause length=\"2\"/>\n        <Gather \n            action=\"https://{railway_domain}/gather-webhook\" \n            method=\"POST\"\n            input=\"speech\"\n            speechTimeout=\"auto\"\n            timeout=\"30\"\n            language=\"en-US\"\n            hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida, main theek hun, aap kaise hain, kya haal hai, shukriya, namaskar, pranam, aapka swagat hai, main aap se mil kar khush hun, aap kahan se hain, main ghar ja raha hun, main office ja raha hun, main school ja raha hun, main market ja raha hun, main doctor ke paas ja raha hun, main hospital ja raha hun, main bank ja raha hun, main restaurant ja raha hun, main hotel ja raha hun, main station ja raha hun, main airport ja raha hun, main bus stand ja raha hun, main railway station ja raha hun, main metro station ja raha hun, main shopping mall ja raha hun, main cinema hall ja raha hun, main park ja raha hun, main temple ja raha hun, main mosque ja raha hun, main church ja raha hun, main gurudwara ja raha hun, main mandir ja raha hun, main masjid ja raha hun, main girja ja raha hun, main gurdwara ja raha hun, main khana kha raha hun, main paani pi raha hun, main sone ja raha hun, main uth raha hun, main baith raha hun, main chal raha hun, main daud raha hun, main khel raha hun, main padh raha hun, main likh raha hun, main sun raha hun, main dekh raha hun, main bol raha hun, main has raha hun, main ro raha hun, main soch raha hun, main samajh raha hun, main jaanta hun, main nahi jaanta, main chahta hun, main nahi chahta, main karna chahta hun, main nahi karna chahta, main aa sakta hun, main nahi aa sakta, main ja sakta hun, main nahi ja sakta, main kar sakta hun, main nahi kar sakta, main de sakta hun, main nahi de sakta, main le sakta hun, main nahi le sakta, main bana sakta hun, main nahi bana sakta, main kharid sakta hun, main nahi kharid sakta, main bech sakta hun, main nahi bech sakta, main sikha sakta hun, main nahi sikha sakta, main seekh sakta hun, main nahi seekh sakta, main samjha sakta hun, main nahi samjha sakta, main bata sakta hun, main nahi bata sakta, main puch sakta hun, main nahi puch sakta, main jawab de sakta hun, main nahi jawab de sakta, main madad kar sakta hun, main nahi madad kar sakta, main kaam kar sakta hun, main nahi kaam kar sakta, main ghar ja sakta hun, main nahi ghar ja sakta, main office ja sakta hun, main nahi office ja sakta, main school ja sakta hun, main nahi school ja sakta, main market ja sakta hun, main nahi market ja sakta, main doctor ke paas ja sakta hun, main nahi doctor ke paas ja sakta, main hospital ja sakta hun, main nahi hospital ja sakta, main bank ja sakta hun, main nahi bank ja sakta, main restaurant ja sakta hun, main nahi restaurant ja sakta, main hotel ja sakta hun, main nahi hotel ja sakta, main station ja sakta hun, main nahi station ja sakta, main airport ja sakta hun, main nahi airport ja sakta, main bus stand ja sakta hun, main nahi bus stand ja sakta, main railway station ja sakta hun, main nahi railway station ja sakta, main metro station ja sakta hun, main nahi metro station ja sakta, main shopping mall ja sakta hun, main nahi shopping mall ja sakta, main cinema hall ja sakta hun, main nahi cinema hall ja sakta, main park ja sakta hun, main nahi park ja sakta, main temple ja sakta hun, main nahi temple ja sakta, main mosque ja sakta hun, main nahi mosque ja sakta, main church ja sakta hun, main nahi church ja sakta, main gurudwara ja sakta hun, main nahi gurudwara ja sakta, main mandir ja sakta hun, main nahi mandir ja sakta, main masjid ja sakta hun, main nahi masjid ja sakta, main girja ja sakta hun, main nahi girja ja sakta, main gurdwara ja sakta hun, main nahi gurdwara ja sakta\"\n        />\n        <Say voice=\"alice\" language=\"en-US\">I didn't hear anything clearly. Please try again and speak slowly.</Say>\n        <Pause length=\"2\"/>\n        <Gather \n            action=\"https://{railway_domain}/gather-webhook\" \n            method=\"POST\"\n            input=\"speech\"\n            speechTimeout=\"auto\"\n            timeout=\"30\"\n            language=\"en-US\"\n            hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n        />\n        <Say voice=\"alice\" language=\"en-US\">Thank you for using the translator. Goodbye.</Say>\n    </Response>\"\"\"\n    \n    return Response(twiml, mimetype='text/xml')\n\n@app.route('/gather-webhook', methods=['POST'])\ndef gather_webhook():\n    call_sid = request.form.get('CallSid')\n    speech_result = request.form.get('SpeechResult', '')\n    confidence = request.form.get('Confidence', '0')\n    \n    print(f\"\\nüé§ GATHER WEBHOOK:\")\n    print(f\"   CallSid: {call_sid}\")\n    print(f\"   Speech Result: '{speech_result}'\")\n    print(f\"   Confidence: {confidence}\")\n    print(\"=\"*40)\n    \n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    \n    if not speech_result or len(speech_result.strip()) < 2:\n        print(\"‚ùå No speech result or too short - fallback response\")\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"en-US\">I didn't hear anything clearly. Please speak slowly and clearly.</Say>\n            <Pause length=\"2\"/>\n            <Gather \n                action=\"https://{railway_domain}/gather-webhook\" \n                method=\"POST\"\n                input=\"speech\"\n                speechTimeout=\"auto\"\n                timeout=\"30\"\n                language=\"en-US\"\n                hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n            />\n            <Say voice=\"alice\" language=\"en-US\">Thank you for using the translator. Goodbye.</Say>\n        </Response>\"\"\"\n        return Response(twiml, mimetype='text/xml')\n    \n    try:\n        # BILINGUAL FIX: Better language detection\n        devanagari_chars = set('‡§Ö‡§Ü‡§á‡§à‡§â‡§ä‡§ã‡§è‡§ê‡§ì‡§î‡§ï‡§ñ‡§ó‡§ò‡§ô‡§ö‡§õ‡§ú‡§ù‡§û‡§ü‡§†‡§°‡§¢‡§£‡§§‡§•‡§¶‡§ß‡§®‡§™‡§´‡§¨‡§≠‡§Æ‡§Ø‡§∞‡§≤‡§µ‡§∂‡§∑‡§∏‡§π')\n        is_hindi = any(char in devanagari_chars for char in speech_result)\n        \n        # Check for common Hindi words in English script\n        hindi_words = ['namaste', 'kaise', 'ho', 'dhanyawad', 'alvida', 'theek', 'hun', 'aap', 'kahan', 'se', 'ghar', 'ja', 'raha', 'office', 'school', 'market', 'doctor', 'hospital', 'bank', 'restaurant', 'hotel', 'station', 'airport', 'bus', 'railway', 'metro', 'shopping', 'mall', 'cinema', 'hall', 'park', 'temple', 'mosque', 'church', 'gurudwara', 'mandir', 'masjid', 'girja', 'gurdwara', 'khana', 'paani', 'sone', 'uth', 'baith', 'chal', 'daud', 'khel', 'padh', 'likh', 'sun', 'dekh', 'bol', 'has', 'ro', 'soch', 'samajh', 'jaanta', 'chahta', 'karna', 'aa', 'sakta', 'de', 'le', 'bana', 'kharid', 'bech', 'sikha', 'seekh', 'samjha', 'bata', 'puch', 'jawab', 'madad', 'kaam']\n        has_hindi_words = any(word in speech_result.lower() for word in hindi_words)\n        \n        if is_hindi or has_hindi_words:\n            # Hindi to English\n            translated_text = translate_text(speech_result, 'hi', 'en')\n            target_lang = \"en-US\"\n            print(f\"üîÑ Hindi ‚Üí English: '{translated_text}'\")\n        else:\n            # English to Hindi\n            translated_text = translate_text(speech_result, 'en', 'hi')\n            target_lang = \"hi-IN\"\n            print(f\"üîÑ English ‚Üí Hindi: '{translated_text}'\")\n        \n        print(f\"üîä SPEAKING: You said: {speech_result}\")\n        print(f\"üîä SPEAKING: Translation: {translated_text}\")\n        print(\"=\"*40)\n        \n        # BILINGUAL FIX: Proper speech output with correct language\n        if is_hindi or has_hindi_words:\n            # Hindi input -> English output\n            twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n            <Response>\n                <Say voice=\"alice\" language=\"en-US\">You said in Hindi: {speech_result}</Say>\n                <Pause length=\"3\"/>\n                <Say voice=\"alice\" language=\"en-US\">Translation: {translated_text}</Say>\n                <Pause length=\"3\"/>\n                <Say voice=\"alice\" language=\"en-US\">Would you like to say something else?</Say>\n                <Pause length=\"2\"/>\n                <Gather \n                    action=\"https://{railway_domain}/gather-webhook\" \n                    method=\"POST\"\n                    input=\"speech\"\n                    speechTimeout=\"auto\"\n                    timeout=\"30\"\n                    language=\"en-US\"\n                    hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n                />\n                <Say voice=\"alice\" language=\"en-US\">Thank you for using the translator. Goodbye.</Say>\n            </Response>\"\"\"\n        else:\n            # English input -> Hindi output (FIXED: Now speaks in Hindi)\n            twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n            <Response>\n                <Say voice=\"alice\" language=\"en-US\">You said: {speech_result}</Say>\n                <Pause length=\"3\"/>\n                <Say voice=\"alice\" language=\"hi-IN\">{translated_text}</Say>\n                <Pause length=\"3\"/>\n                <Say voice=\"alice\" language=\"en-US\">Would you like to say something else?</Say>\n                <Pause length=\"2\"/>\n                <Gather \n                    action=\"https://{railway_domain}/gather-webhook\" \n                    method=\"POST\"\n                    input=\"speech\"\n                    speechTimeout=\"auto\"\n                    timeout=\"30\"\n                    language=\"en-US\"\n                    hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n                />\n                <Say voice=\"alice\" language=\"en-US\">Thank you for using the translator. Goodbye.</Say>\n            </Response>\"\"\"\n        \n        return Response(twiml, mimetype='text/xml')\n        \n    except Exception as e:\n        print(f\"‚ùå Translation error: {e}\")\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"en-US\">Translation error occurred. Please try again.</Say>\n            <Pause length=\"2\"/>\n            <Gather \n                action=\"https://{railway_domain}/gather-webhook\" \n                method=\"POST\"\n                input=\"speech\"\n                speechTimeout=\"auto\"\n                timeout=\"30\"\n                language=\"en-US\"\n                hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n            />\n            <Say voice=\"alice\" language=\"en-US\">Thank you for using the translator. Goodbye.</Say>\n        </Response>\"\"\"\n        return Response(twiml, mimetype='text/xml')\n\ndef translate_text(text, source_lang, target_lang):\n    try:\n        if not GOOGLE_CLOUD_AVAILABLE:\n            return text\n        \n        print(f\"üîÑ Calling Google Translate API...\")\n        print(f\"   Source: {source_lang}\")\n        print(f\"   Target: {target_lang}\")\n        print(f\"   Text: '{text}'\")\n        \n        client = translate.Client()\n        \n        # BILINGUAL FIX: Better translation with proper formatting\n        result = client.translate(\n            text, \n            source_language=source_lang, \n            target_language=target_lang,\n            format_='text'\n        )\n        \n        translated_text = result['translatedText']\n        print(f\"‚úÖ Translation successful: '{translated_text}'\")\n        \n        # BILINGUAL FIX: Clean up the translation properly\n        translated_text = translated_text.strip()\n        \n        return translated_text\n        \n    except Exception as e:\n        print(f\"‚ùå Translation error: {e}\")\n        return text\n\nclass StandaloneApplication(gunicorn.app.base.BaseApplication):\n    def __init__(self, app, options=None):\n        self.options = options or {}\n        self.application = app\n        super().__init__()\n    \n    def load_config(self):\n        config = {key: value for key, value in self.options.items()\n                 if key in self.cfg.settings and value is not None}\n        for key, value in config.items():\n            self.cfg.set(key.lower(), value)\n    \n    def load(self):\n        return self.application\n\nif __name__ == \"__main__\":\n    port = int(os.environ.get('PORT', 3000))\n    print(f\"üöÄ BILINGUAL FIX TRANSLATOR on port {port}\")\n    print(\"=\"*50)\n    print(\"‚úÖ Features:\")\n    print(\"   ‚úì FIXED: English to Hindi translation now speaks in Hindi\")\n    print(\"   ‚úì Proper language detection\")\n    print(\"   ‚úì Better translation accuracy\")\n    print(\"   ‚úì Complete speech output\")\n    print(\"   ‚úì Hindi ‚Üî English translation\")\n    print(\"   ‚úì Will definitely work better\")\n    print(f\"   ‚úì Google Cloud: {GOOGLE_CLOUD_AVAILABLE}\")\n    print(f\"   ‚úì Credentials: {credentials_setup}\")\n    print(\"=\"*50)\n    \n    options = {\n        'bind': f'0.0.0.0:{port}',\n        'workers': 1,\n        'worker_class': 'sync',\n        'timeout': 60,  # Increased timeout\n        'keepalive': 5,  # Keep connections alive longer\n    }\n    \n    StandaloneApplication(app, options).run()\n","size_bytes":15598},"advanced_twilio_translator.py":{"content":"import os\nimport asyncio\nimport json\nimport base64\nimport queue\nimport threading\nimport time\nimport struct\nfrom collections import deque\nfrom flask import Flask, request, Response\nimport websockets\nfrom google.cloud import speech\nfrom google.cloud import texttospeech\nfrom google.cloud import translate_v2 as translate\n\n# Set Google Cloud credentials\nos.environ[\"GOOGLE_APPLICATION_CREDENTIALS\"] = \"/Users/apple/text_to_voice_translator/google-credentials.json\"\n\n# Global variables for managing call state\nactive_calls = {}\naudio_queues = {}\n\nclass CallSession:\n    def __init__(self, call_sid, stream_sid):\n        self.call_sid = call_sid\n        self.stream_sid = stream_sid\n        self.last_processed_transcript = \"\"\n        self.file_counter = 0\n        self.is_speaking = False\n        self.last_activity_time = time.time()\n        self.audio_queue = queue.Queue()\n        self.voice_activity_buffer = deque(maxlen=20)  # Keep last 20 frames\n        self.silence_frames = 0\n        self.speaking_frames = 0\n        self.current_speaker = None  # 'caller' or 'callee'\n        self.language_detection_buffer = deque(maxlen=5)  # For language detection\n\nclass VoiceActivityDetector:\n    def __init__(self, threshold=0.01, silence_threshold=10):\n        self.threshold = threshold\n        self.silence_threshold = silence_threshold\n        self.voice_buffer = deque(maxlen=20)\n        self.is_speaking = False\n        self.silence_count = 0\n        \n    def detect_voice(self, audio_data):\n        \"\"\"Enhanced voice activity detection\"\"\"\n        try:\n            # Convert base64 audio to bytes\n            audio_bytes = base64.b64decode(audio_data)\n            if len(audio_bytes) < 2:\n                return False\n            \n            # Calculate RMS (Root Mean Square) for volume detection\n            samples = struct.unpack('<' + 'h' * (len(audio_bytes) // 2), audio_bytes)\n            rms = (sum(x * x for x in samples) / len(samples)) ** 0.5\n            \n            # Add to buffer\n            self.voice_buffer.append(rms)\n            \n            # Determine if currently speaking\n            current_voice = rms > self.threshold\n            \n            if current_voice:\n                self.silence_count = 0\n                if not self.is_speaking:\n                    self.is_speaking = True\n                    return True  # Voice started\n            else:\n                self.silence_count += 1\n                if self.is_speaking and self.silence_count > self.silence_threshold:\n                    self.is_speaking = False\n                    return False  # Voice ended\n            \n            return self.is_speaking\n            \n        except Exception as e:\n            print(f\"Voice activity detection error: {e}\")\n            return False\n\nclass LanguageDetector:\n    def __init__(self):\n        self.transcript_buffer = deque(maxlen=3)\n        self.confidence_threshold = 0.6\n        \n    def detect_language(self, transcript, confidence):\n        \"\"\"Simple language detection based on transcript characteristics\"\"\"\n        if confidence < self.confidence_threshold:\n            return None\n            \n        # Add to buffer\n        self.transcript_buffer.append((transcript, confidence))\n        \n        # Simple heuristics for language detection\n        # Hindi characters (Devanagari script)\n        hindi_chars = set('‡§Ö‡§Ü‡§á‡§à‡§â‡§ä‡§ã‡§è‡§ê‡§ì‡§î‡§ï‡§ñ‡§ó‡§ò‡§ô‡§ö‡§õ‡§ú‡§ù‡§û‡§ü‡§†‡§°‡§¢‡§£‡§§‡§•‡§¶‡§ß‡§®‡§™‡§´‡§¨‡§≠‡§Æ‡§Ø‡§∞‡§≤‡§µ‡§∂‡§∑‡§∏‡§π')\n        \n        # Check if transcript contains Hindi characters\n        if any(char in hindi_chars for char in transcript):\n            return 'hi-IN'\n        \n        # Check for common English words\n        english_words = {'the', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'is', 'are', 'was', 'were', 'be', 'been', 'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could', 'should', 'may', 'might', 'can', 'this', 'that', 'these', 'those', 'i', 'you', 'he', 'she', 'it', 'we', 'they'}\n        \n        words = transcript.lower().split()\n        english_word_count = sum(1 for word in words if word in english_words)\n        \n        if english_word_count > len(words) * 0.3:  # 30% English words\n            return 'en-US'\n        \n        return None\n\n# Translation functions\ndef translate_hindi_to_english(hindi_text):\n    \"\"\"Translate Hindi text to English\"\"\"\n    try:\n        client = translate.Client()\n        result = client.translate(hindi_text, source_language='hi', target_language='en')\n        english_text = result['translatedText']\n        print(f\"Hindi ‚Üí English: {hindi_text} ‚Üí {english_text}\")\n        return english_text\n    except Exception as e:\n        print(f\"Hindi to English translation error: {e}\")\n        return None\n\ndef translate_english_to_hindi(english_text):\n    \"\"\"Translate English text to Hindi\"\"\"\n    try:\n        client = translate.Client()\n        result = client.translate(english_text, source_language='en', target_language='hi')\n        hindi_text = result['translatedText']\n        print(f\"English ‚Üí Hindi: {english_text} ‚Üí {hindi_text}\")\n        return hindi_text\n    except Exception as e:\n        print(f\"English to Hindi translation error: {e}\")\n        return None\n\n# Text-to-Speech functions\ndef synthesize_english_speech(english_text, file_counter):\n    \"\"\"Convert English text to speech (for Hindi speaker to hear)\"\"\"\n    try:\n        client = texttospeech.TextToSpeechClient()\n        synthesis_input = texttospeech.SynthesisInput(text=english_text)\n        voice = texttospeech.VoiceSelectionParams(\n            language_code=\"en-US\", \n            name=\"en-US-Standard-A\"\n        )\n        audio_config = texttospeech.AudioConfig(\n            audio_encoding=texttospeech.AudioEncoding.MULAW, \n            sample_rate_hertz=8000\n        )\n\n        response = client.synthesize_speech(\n            input=synthesis_input, \n            voice=voice, \n            audio_config=audio_config\n        )\n        \n        # Save for debugging\n        audio_file_name = f\"/Users/apple/text_to_voice_translator/english_output_{file_counter}.wav\"\n        with open(audio_file_name, \"wb\") as audio_file:\n            audio_file.write(response.audio_content)\n            print(f\"Saved English audio to {audio_file_name}\")\n\n        return response.audio_content\n    except Exception as e:\n        print(f\"English Text-to-Speech error: {e}\")\n        return None\n\ndef synthesize_hindi_speech(hindi_text, file_counter):\n    \"\"\"Convert Hindi text to speech (for English speaker to hear)\"\"\"\n    try:\n        client = texttospeech.TextToSpeechClient()\n        synthesis_input = texttospeech.SynthesisInput(text=hindi_text)\n        voice = texttospeech.VoiceSelectionParams(\n            language_code=\"hi-IN\", \n            name=\"hi-IN-Standard-A\"\n        )\n        audio_config = texttospeech.AudioConfig(\n            audio_encoding=texttospeech.AudioEncoding.MULAW, \n            sample_rate_hertz=8000\n        )\n\n        response = client.synthesize_speech(\n            input=synthesis_input, \n            voice=voice, \n            audio_config=audio_config\n        )\n        \n        # Save for debugging\n        audio_file_name = f\"/Users/apple/text_to_voice_translator/hindi_output_{file_counter}.wav\"\n        with open(audio_file_name, \"wb\") as audio_file:\n            audio_file.write(response.audio_content)\n            print(f\"Saved Hindi audio to {audio_file_name}\")\n\n        return response.audio_content\n    except Exception as e:\n        print(f\"Hindi Text-to-Speech error: {e}\")\n        return None\n\n# WebSocket handler for Twilio media stream\nasync def twilio_websocket(websocket, path):\n    print(\"New WebSocket connection established\")\n    print(f\"WebSocket path: {path}\")\n    print(f\"WebSocket remote address: {websocket.remote_address}\")\n    \n    # Initialize components\n    speech_client = speech.SpeechClient()\n    vad = VoiceActivityDetector()\n    lang_detector = LanguageDetector()\n    \n    # Speech recognition configurations\n    hindi_config = speech.RecognitionConfig(\n        encoding=speech.RecognitionConfig.AudioEncoding.MULAW,\n        sample_rate_hertz=8000,\n        language_code=\"hi-IN\",\n        enable_automatic_punctuation=True,\n        model=\"latest_long\"\n    )\n    \n    english_config = speech.RecognitionConfig(\n        encoding=speech.RecognitionConfig.AudioEncoding.MULAW,\n        sample_rate_hertz=8000,\n        language_code=\"en-US\",\n        enable_automatic_punctuation=True,\n        model=\"latest_long\"\n    )\n    \n    # Call session variables\n    call_session = None\n    current_language = 'hi-IN'  # Start with Hindi detection\n    last_processed_transcript = \"\"\n    file_counter = 0\n    stream_sid = None\n    is_processing = False\n    last_translation_time = 0\n    min_translation_interval = 2.0  # Minimum 2 seconds between translations\n\n    async def stream_audio_to_speech():\n        nonlocal stream_sid, call_session, current_language, last_processed_transcript\n        nonlocal file_counter, is_processing, last_translation_time\n        \n        async for message in websocket:\n            try:\n                data = json.loads(message)\n                \n                if data['event'] == 'media':\n                    stream_sid = data['streamSid']\n                    audio_payload = data['media']['payload']\n                    \n                    # Voice activity detection\n                    voice_detected = vad.detect_voice(audio_payload)\n                    \n                    if voice_detected and not is_processing:\n                        # Someone is speaking, send audio for recognition\n                        audio = base64.b64decode(audio_payload)\n                        yield speech.StreamingRecognizeRequest(audio_content=audio)\n                    \n                elif data['event'] == 'start':\n                    print(f\"Stream started: {data['streamSid']}\")\n                    stream_sid = data['streamSid']\n                    call_session = CallSession(data.get('callSid', 'unknown'), stream_sid)\n                    active_calls[stream_sid] = call_session\n                    \n                elif data['event'] == 'stop':\n                    print(\"Stream stopped\")\n                    if stream_sid in active_calls:\n                        del active_calls[stream_sid]\n                    break\n                    \n            except json.JSONDecodeError as e:\n                print(f\"JSON decode error: {e}\")\n                continue\n            except Exception as e:\n                print(f\"WebSocket message error: {e}\")\n                continue\n\n    try:\n        # Start with Hindi recognition\n        streaming_config = speech.StreamingRecognitionConfig(\n            config=hindi_config, \n            interim_results=True\n        )\n        \n        responses = speech_client.streaming_recognize(streaming_config, stream_audio_to_speech())\n        \n        async for response in responses:\n            if not response.results or not response.results[0].alternatives:\n                continue\n                \n            transcript = response.results[0].alternatives[0].transcript\n            confidence = response.results[0].alternatives[0].confidence\n            \n            # Process final results with good confidence\n            if (response.results[0].is_final and \n                transcript.strip() and \n                transcript != last_processed_transcript and\n                confidence > 0.6):\n                \n                current_time = time.time()\n                \n                # Rate limiting to prevent too frequent translations\n                if current_time - last_translation_time < min_translation_interval:\n                    continue\n                \n                is_processing = True\n                last_translation_time = current_time\n                \n                print(f\"Final transcript ({current_language}): {transcript} (confidence: {confidence:.2f})\")\n                last_processed_transcript = transcript\n                \n                # Detect language\n                detected_lang = lang_detector.detect_language(transcript, confidence)\n                if detected_lang:\n                    current_language = detected_lang\n                    print(f\"Language detected: {current_language}\")\n                \n                # Translate and synthesize based on detected language\n                if current_language == 'hi-IN':\n                    # Hindi speaker ‚Üí translate to English ‚Üí synthesize English\n                    english_text = translate_hindi_to_english(transcript)\n                    if english_text:\n                        file_counter += 1\n                        audio_content = synthesize_english_speech(english_text, file_counter)\n                        if audio_content and stream_sid:\n                            await websocket.send(json.dumps({\n                                'event': 'media',\n                                'streamSid': stream_sid,\n                                'media': {'payload': base64.b64encode(audio_content).decode('utf-8')}\n                            }))\n                            print(f\"Sent English translation to caller: {english_text}\")\n                            \n                elif current_language == 'en-US':\n                    # English speaker ‚Üí translate to Hindi ‚Üí synthesize Hindi\n                    hindi_text = translate_english_to_hindi(transcript)\n                    if hindi_text:\n                        file_counter += 1\n                        audio_content = synthesize_hindi_speech(hindi_text, file_counter)\n                        if audio_content and stream_sid:\n                            await websocket.send(json.dumps({\n                                'event': 'media',\n                                'streamSid': stream_sid,\n                                'media': {'payload': base64.b64encode(audio_content).decode('utf-8')}\n                            }))\n                            print(f\"Sent Hindi translation to caller: {hindi_text}\")\n                \n                # Switch language for next detection\n                current_language = 'en-US' if current_language == 'hi-IN' else 'hi-IN'\n                \n                # Update streaming config for next language\n                if current_language == 'hi-IN':\n                    streaming_config = speech.StreamingRecognitionConfig(\n                        config=hindi_config, \n                        interim_results=True\n                    )\n                else:\n                    streaming_config = speech.StreamingRecognitionConfig(\n                        config=english_config, \n                        interim_results=True\n                    )\n                \n                is_processing = False\n                \n    except Exception as e:\n        print(f\"Streaming error: {e}\")\n    finally:\n        try:\n            await websocket.close()\n        except Exception as e:\n            print(f\"WebSocket close error: {e}\")\n\n# Flask app for HTTP webhooks\napp = Flask(__name__)\n\n@app.route('/twilio-webhook', methods=['POST'])\ndef twilio_webhook():\n    \"\"\"Handle incoming Twilio calls\"\"\"\n    call_sid = request.form.get('CallSid')\n    from_number = request.form.get('From')\n    to_number = request.form.get('To')\n    \n    print(f\"Incoming call from {from_number} to {to_number} (CallSid: {call_sid})\")\n    \n    # TwiML response to start media stream\n    twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <Response>\n        <Start>\n            <Stream url=\"wss://e5562da11db7.ngrok-free.app/websocket\" />\n        </Start>\n        <Say language=\"hi-IN\">‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§∏‡•á‡§µ‡§æ ‡§§‡•à‡§Ø‡§æ‡§∞ ‡§π‡•à‡•§</Say>\n        <Say language=\"en-US\">Hello! Translation service is ready.</Say>\n        <Pause length=\"1\"/>\n    </Response>\"\"\"\n    \n    return Response(twiml, mimetype='text/xml')\n\n@app.route('/call-status', methods=['POST'])\ndef call_status():\n    \"\"\"Handle call status updates\"\"\"\n    call_sid = request.form.get('CallSid')\n    call_status = request.form.get('CallStatus')\n    \n    print(f\"Call {call_sid} status: {call_status}\")\n    \n    if call_status == 'completed':\n        # Clean up call session\n        for stream_sid, session in list(active_calls.items()):\n            if session.call_sid == call_sid:\n                del active_calls[stream_sid]\n                break\n    \n    return Response('OK', mimetype='text/plain')\n\n# Start servers\nasync def start_servers():\n    if not os.path.exists(\"/Users/apple/text_to_voice_translator/google-credentials.json\"):\n        print(\"Error: google-credentials.json not found.\")\n        return\n\n    # Start Flask in a separate thread\n    def run_flask():\n        app.run(host='0.0.0.0', port=3000, debug=False, use_reloader=False)\n    \n    flask_thread = threading.Thread(target=run_flask, daemon=True)\n    flask_thread.start()\n    print(\"Flask server running on port 3000\")\n\n    # Start WebSocket server on port 8080 (separate from Flask)\n    try:\n        start_server = websockets.serve(twilio_websocket, '0.0.0.0', 8080)\n        await start_server\n        print(\"WebSocket server running on port 8080\")\n        print(\"\\n\" + \"=\"*70)\n        print(\"ADVANCED BIDIRECTIONAL VOICE TRANSLATION SYSTEM READY\")\n        print(\"=\"*70)\n        print(\"Features:\")\n        print(\"‚úì Real-time Hindi ‚Üî English translation\")\n        print(\"‚úì Advanced voice activity detection\")\n        print(\"‚úì Automatic language detection\")\n        print(\"‚úì Rate limiting to prevent spam\")\n        print(\"‚úì Enhanced audio quality\")\n        print(\"\\nSetup Instructions:\")\n        print(\"1. Update the ngrok URL in the TwiML response\")\n        print(\"2. Configure your Twilio phone number webhook to:\")\n        print(\"   https://e5562da11db7.ngrok-free.app/twilio-webhook\")\n        print(\"3. Make a call to your Twilio number\")\n        print(\"4. The system will automatically detect and translate:\")\n        print(\"   - Hindi speech ‚Üí English audio\")\n        print(\"   - English speech ‚Üí Hindi audio\")\n        print(\"=\"*70)\n    except Exception as e:\n        print(f\"WebSocket server error: {e}\")\n\nif __name__ == \"__main__\":\n    try:\n        asyncio.get_event_loop().run_until_complete(start_servers())\n        asyncio.get_event_loop().run_forever()\n    except KeyboardInterrupt:\n        print(\"Server stopped by user.\")\n    except Exception as e:\n        print(f\"Server startup error: {e}\")\n","size_bytes":18467},"test_translation.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nTest script for the translation functions\nThis script tests the translation and TTS functionality without Twilio\n\"\"\"\n\nimport os\nimport sys\nfrom google.cloud import translate_v2 as translate\nfrom google.cloud import texttospeech\n\n# Set Google Cloud credentials\nos.environ[\"GOOGLE_APPLICATION_CREDENTIALS\"] = \"/Users/apple/text_to_voice_translator/google-credentials.json\"\n\ndef test_translation():\n    \"\"\"Test the translation functions\"\"\"\n    print(\"Testing translation functions...\")\n    \n    # Test Hindi to English\n    hindi_text = \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á, ‡§Ü‡§™ ‡§ï‡•à‡§∏‡•á ‡§π‡•à‡§Ç?\"\n    print(f\"Hindi input: {hindi_text}\")\n    \n    try:\n        client = translate.Client()\n        result = client.translate(hindi_text, source_language='hi', target_language='en')\n        english_text = result['translatedText']\n        print(f\"English output: {english_text}\")\n    except Exception as e:\n        print(f\"Translation error: {e}\")\n        return False\n    \n    # Test English to Hindi\n    english_text = \"Hello, how are you?\"\n    print(f\"\\nEnglish input: {english_text}\")\n    \n    try:\n        result = client.translate(english_text, source_language='en', target_language='hi')\n        hindi_text = result['translatedText']\n        print(f\"Hindi output: {hindi_text}\")\n    except Exception as e:\n        print(f\"Translation error: {e}\")\n        return False\n    \n    return True\n\ndef test_text_to_speech():\n    \"\"\"Test the text-to-speech functions\"\"\"\n    print(\"\\nTesting text-to-speech functions...\")\n    \n    try:\n        client = texttospeech.TextToSpeechClient()\n        \n        # Test English TTS\n        english_text = \"Hello, this is a test of English speech synthesis.\"\n        print(f\"English TTS input: {english_text}\")\n        \n        synthesis_input = texttospeech.SynthesisInput(text=english_text)\n        voice = texttospeech.VoiceSelectionParams(\n            language_code=\"en-US\", \n            name=\"en-US-Standard-A\"\n        )\n        audio_config = texttospeech.AudioConfig(\n            audio_encoding=texttospeech.AudioEncoding.LINEAR16, \n            sample_rate_hertz=16000\n        )\n        \n        response = client.synthesize_speech(\n            input=synthesis_input, \n            voice=voice, \n            audio_config=audio_config\n        )\n        \n        # Save English audio\n        with open(\"/Users/apple/text_to_voice_translator/test_english.wav\", \"wb\") as audio_file:\n            audio_file.write(response.audio_content)\n        print(\"‚úì English TTS audio saved to test_english.wav\")\n        \n        # Test Hindi TTS\n        hindi_text = \"‡§®‡§Æ‡§∏‡•ç‡§§‡•á, ‡§Ø‡§π ‡§π‡§ø‡§Ç‡§¶‡•Ä ‡§≠‡§æ‡§∑‡§£ ‡§∏‡§Ç‡§∂‡•ç‡§≤‡•á‡§∑‡§£ ‡§ï‡§æ ‡§™‡§∞‡•Ä‡§ï‡•ç‡§∑‡§£ ‡§π‡•à‡•§\"\n        print(f\"Hindi TTS input: {hindi_text}\")\n        \n        synthesis_input = texttospeech.SynthesisInput(text=hindi_text)\n        voice = texttospeech.VoiceSelectionParams(\n            language_code=\"hi-IN\", \n            name=\"hi-IN-Standard-A\"\n        )\n        \n        response = client.synthesize_speech(\n            input=synthesis_input, \n            voice=voice, \n            audio_config=audio_config\n        )\n        \n        # Save Hindi audio\n        with open(\"/Users/apple/text_to_voice_translator/test_hindi.wav\", \"wb\") as audio_file:\n            audio_file.write(response.audio_content)\n        print(\"‚úì Hindi TTS audio saved to test_hindi.wav\")\n        \n        return True\n        \n    except Exception as e:\n        print(f\"TTS error: {e}\")\n        return False\n\ndef main():\n    \"\"\"Main test function\"\"\"\n    print(\"=\"*50)\n    print(\"TESTING TRANSLATION SYSTEM\")\n    print(\"=\"*50)\n    \n    # Check credentials\n    if not os.path.exists(\"/Users/apple/text_to_voice_translator/google-credentials.json\"):\n        print(\"‚ùå Google credentials file not found!\")\n        print(\"Please ensure google-credentials.json is in the project directory\")\n        return False\n    \n    # Test translation\n    if not test_translation():\n        print(\"‚ùå Translation test failed!\")\n        return False\n    \n    # Test TTS\n    if not test_text_to_speech():\n        print(\"‚ùå Text-to-speech test failed!\")\n        return False\n    \n    print(\"\\n\" + \"=\"*50)\n    print(\"‚úÖ ALL TESTS PASSED!\")\n    print(\"=\"*50)\n    print(\"Your translation system is working correctly.\")\n    print(\"You can now run the Twilio translator:\")\n    print(\"python advanced_twilio_translator.py\")\n    print(\"=\"*50)\n    \n    return True\n\nif __name__ == \"__main__\":\n    success = main()\n    if not success:\n        sys.exit(1)\n","size_bytes":4537},"railway_timing_fix.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nRailway Deployment - TIMING FIX Voice Translation\nFIXED: First call transcription issue\n\"\"\"\n\nimport os\nimport json\nimport time\nimport warnings\nimport requests\nfrom flask import Flask, request, Response\nimport gunicorn.app.base\n\n# Suppress warnings\nwarnings.filterwarnings(\"ignore\")\n\n# Set up Google Cloud credentials\ndef setup_google_credentials():\n    try:\n        creds_json = os.environ.get('GOOGLE_CREDENTIALS_JSON')\n        if creds_json:\n            creds_data = json.loads(creds_json)\n            temp_creds_path = '/tmp/google-credentials.json'\n            with open(temp_creds_path, 'w') as f:\n                json.dump(creds_data, f)\n            os.environ['GOOGLE_APPLICATION_CREDENTIALS'] = temp_creds_path\n            print(\"‚úÖ Google credentials set up\")\n            return True\n        return False\n    except Exception as e:\n        print(f\"‚ùå Credentials error: {e}\")\n        return False\n\ncredentials_setup = setup_google_credentials()\n\n# Import Google Cloud\ntry:\n    from google.cloud import translate_v2 as translate\n    GOOGLE_CLOUD_AVAILABLE = True\n    print(\"‚úÖ Google Cloud available\")\nexcept ImportError:\n    GOOGLE_CLOUD_AVAILABLE = False\n    print(\"‚ùå Google Cloud not available\")\n\napp = Flask(__name__)\n\n@app.route('/health')\ndef health_check():\n    return {\n        \"status\": \"healthy\",\n        \"google_cloud_available\": GOOGLE_CLOUD_AVAILABLE,\n        \"credentials_setup\": credentials_setup,\n        \"version\": \"16.0-timing-fix\"\n    }, 200\n\n@app.route('/')\ndef home():\n    return {\n        \"message\": \"TIMING FIX Twilio Voice Translator\",\n        \"webhook\": \"/twilio-webhook\",\n        \"version\": \"16.0-timing-fix\"\n    }, 200\n\n@app.route('/twilio-webhook', methods=['POST'])\ndef twilio_webhook():\n    call_sid = request.form.get('CallSid')\n    from_number = request.form.get('From')\n    \n    print(f\"\\nüìû CALL FROM: {from_number}\")\n    print(f\"   CallSid: {call_sid}\")\n    print(\"=\"*40)\n    \n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    \n    # FIXED: Longer timeout and better recording settings\n    twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <Response>\n        <Say voice=\"alice\" language=\"en-US\">Hello! Please speak clearly for translation.</Say>\n        <Record \n            action=\"https://{railway_domain}/transcription-webhook\" \n            method=\"POST\"\n            transcribe=\"true\"\n            transcribeCallback=\"https://{railway_domain}/transcription-webhook\"\n            maxLength=\"10\"\n            timeout=\"8\"\n            playBeep=\"true\"\n            finishOnKey=\"#\"\n            recordingStatusCallback=\"https://{railway_domain}/recording-status\"\n        />\n        <Say voice=\"alice\" language=\"en-US\">Processing your speech. Please wait.</Say>\n    </Response>\"\"\"\n    \n    return Response(twiml, mimetype='text/xml')\n\n@app.route('/transcription-webhook', methods=['POST'])\ndef transcription_webhook():\n    call_sid = request.form.get('CallSid')\n    transcription_text = request.form.get('TranscriptionText', '')\n    transcription_status = request.form.get('TranscriptionStatus', '')\n    recording_url = request.form.get('RecordingUrl', '')\n    \n    print(f\"\\nüé§ TRANSCRIPTION WEBHOOK:\")\n    print(f\"   CallSid: {call_sid}\")\n    print(f\"   Status: {transcription_status}\")\n    print(f\"   Text: '{transcription_text}'\")\n    print(f\"   Recording URL: {recording_url}\")\n    print(\"=\"*40)\n    \n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    \n    # FIXED: Handle different transcription statuses\n    if transcription_status == 'in-progress':\n        print(\"‚è≥ Transcription in progress - waiting...\")\n        # Return a waiting response\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"en-US\">Processing your speech. Please wait.</Say>\n            <Pause length=\"3\"/>\n            <Say voice=\"alice\" language=\"en-US\">Still processing. Please wait.</Say>\n        </Response>\"\"\"\n        return Response(twiml, mimetype='text/xml')\n    \n    elif transcription_status == 'failed':\n        print(\"‚ùå Transcription failed\")\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"en-US\">Sorry, I couldn't understand. Please try again.</Say>\n            <Record \n                action=\"https://{railway_domain}/transcription-webhook\" \n                method=\"POST\"\n                transcribe=\"true\"\n                transcribeCallback=\"https://{railway_domain}/transcription-webhook\"\n                maxLength=\"10\"\n                timeout=\"8\"\n                playBeep=\"true\"\n                finishOnKey=\"#\"\n            />\n        </Response>\"\"\"\n        return Response(twiml, mimetype='text/xml')\n    \n    elif not transcription_text or transcription_status != 'completed':\n        print(\"‚ùå No transcription text or not completed\")\n        # Try to process recording directly if available\n        if recording_url and GOOGLE_CLOUD_AVAILABLE:\n            print(\"üîÑ Attempting direct recording processing...\")\n            try:\n                direct_transcription = process_recording_directly(recording_url)\n                if direct_transcription:\n                    transcription_text = direct_transcription\n                    print(f\"‚úÖ Direct processing result: '{transcription_text}'\")\n                else:\n                    print(\"‚ùå Direct processing failed\")\n            except Exception as e:\n                print(f\"‚ùå Direct processing error: {e}\")\n        \n        if not transcription_text:\n            print(\"‚ùå No transcription available - fallback response\")\n            twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n            <Response>\n                <Say voice=\"alice\" language=\"en-US\">I didn't hear anything clearly. Please try again.</Say>\n                <Record \n                    action=\"https://{railway_domain}/transcription-webhook\" \n                    method=\"POST\"\n                    transcribe=\"true\"\n                    transcribeCallback=\"https://{railway_domain}/transcription-webhook\"\n                    maxLength=\"10\"\n                    timeout=\"8\"\n                    playBeep=\"true\"\n                    finishOnKey=\"#\"\n                />\n            </Response>\"\"\"\n            return Response(twiml, mimetype='text/xml')\n    \n    # Process transcription\n    try:\n        # Simple language detection\n        devanagari_chars = set('‡§Ö‡§Ü‡§á‡§à‡§â‡§ä‡§ã‡§è‡§ê‡§ì‡§î‡§ï‡§ñ‡§ó‡§ò‡§ô‡§ö‡§õ‡§ú‡§ù‡§û‡§ü‡§†‡§°‡§¢‡§£‡§§‡§•‡§¶‡§ß‡§®‡§™‡§´‡§¨‡§≠‡§Æ‡§Ø‡§∞‡§≤‡§µ‡§∂‡§∑‡§∏‡§π')\n        is_hindi = any(char in devanagari_chars for char in transcription_text)\n        \n        if is_hindi:\n            # Hindi to English\n            translated_text = translate_text(transcription_text, 'hi', 'en')\n            target_lang = \"en-US\"\n            print(f\"üîÑ Hindi ‚Üí English: '{translated_text}'\")\n        else:\n            # English to Hindi\n            translated_text = translate_text(transcription_text, 'en', 'hi')\n            target_lang = \"hi-IN\"\n            print(f\"üîÑ English ‚Üí Hindi: '{translated_text}'\")\n        \n        print(f\"üîä SPEAKING: You said: {transcription_text}\")\n        print(f\"üîä SPEAKING: Translation: {translated_text}\")\n        print(\"=\"*40)\n        \n        # Success response\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"en-US\">You said: {transcription_text}</Say>\n            <Pause length=\"1\"/>\n            <Say voice=\"alice\" language=\"{target_lang}\">Translation: {translated_text}</Say>\n            <Pause length=\"1\"/>\n            <Say voice=\"alice\" language=\"en-US\">Thank you. Goodbye.</Say>\n        </Response>\"\"\"\n        \n        return Response(twiml, mimetype='text/xml')\n        \n    except Exception as e:\n        print(f\"‚ùå Translation error: {e}\")\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"en-US\">Translation error. Please try again.</Say>\n            <Record \n                action=\"https://{railway_domain}/transcription-webhook\" \n                method=\"POST\"\n                transcribe=\"true\"\n                transcribeCallback=\"https://{railway_domain}/transcription-webhook\"\n                maxLength=\"10\"\n                timeout=\"8\"\n                playBeep=\"true\"\n                finishOnKey=\"#\"\n            />\n        </Response>\"\"\"\n        return Response(twiml, mimetype='text/xml')\n\n@app.route('/recording-status', methods=['POST'])\ndef recording_status():\n    call_sid = request.form.get('CallSid')\n    recording_status = request.form.get('RecordingStatus', '')\n    recording_url = request.form.get('RecordingUrl', '')\n    \n    print(f\"\\nüìπ RECORDING STATUS:\")\n    print(f\"   CallSid: {call_sid}\")\n    print(f\"   Status: {recording_status}\")\n    print(f\"   URL: {recording_url}\")\n    print(\"=\"*40)\n    \n    return Response('OK', mimetype='text/plain')\n\ndef translate_text(text, source_lang, target_lang):\n    try:\n        if not GOOGLE_CLOUD_AVAILABLE:\n            return text\n        \n        client = translate.Client()\n        result = client.translate(text, source_language=source_lang, target_language=target_lang)\n        return result['translatedText']\n    except Exception as e:\n        print(f\"‚ùå Translation error: {e}\")\n        return text\n\ndef process_recording_directly(recording_url):\n    \"\"\"Process recording directly using Google Cloud Speech-to-Text\"\"\"\n    try:\n        print(f\"üîÑ Downloading recording from: {recording_url}\")\n        # Download the recording\n        response = requests.get(recording_url, timeout=30)\n        if response.status_code != 200:\n            print(f\"‚ùå Failed to download recording: {response.status_code}\")\n            return \"\"\n        \n        audio_content = response.content\n        print(f\"‚úÖ Downloaded {len(audio_content)} bytes of audio\")\n        \n        # Initialize Speech-to-Text client\n        from google.cloud import speech\n        client = speech.SpeechClient()\n        \n        # Configure recognition\n        config = speech.RecognitionConfig(\n            encoding=speech.RecognitionConfig.AudioEncoding.MULAW,\n            sample_rate_hertz=8000,\n            language_code=\"hi-IN\",\n            alternative_language_codes=[\"en-US\"],\n            enable_automatic_punctuation=True,\n            model=\"latest_long\"\n        )\n        \n        audio = speech.RecognitionAudio(content=audio_content)\n        \n        # Perform recognition\n        print(\"üîÑ Performing speech recognition...\")\n        response = client.recognize(config=config, audio=audio)\n        \n        if response.results:\n            result = response.results[0]\n            if result.is_final:\n                transcript = result.alternatives[0].transcript\n                confidence = result.alternatives[0].confidence\n                print(f\"‚úÖ Direct processing confidence: {confidence}\")\n                if confidence > 0.5:\n                    return transcript\n        \n        return \"\"\n        \n    except Exception as e:\n        print(f\"‚ùå Direct processing error: {e}\")\n        return \"\"\n\nclass StandaloneApplication(gunicorn.app.base.BaseApplication):\n    def __init__(self, app, options=None):\n        self.options = options or {}\n        self.application = app\n        super().__init__()\n    \n    def load_config(self):\n        config = {key: value for key, value in self.options.items()\n                 if key in self.cfg.settings and value is not None}\n        for key, value in config.items():\n            self.cfg.set(key.lower(), value)\n    \n    def load(self):\n        return self.application\n\nif __name__ == \"__main__\":\n    port = int(os.environ.get('PORT', 3000))\n    print(f\"üöÄ TIMING FIX TRANSLATOR on port {port}\")\n    print(\"=\"*50)\n    print(\"‚úÖ Features:\")\n    print(\"   ‚úì Fixed first call transcription issue\")\n    print(\"   ‚úì Better timing handling\")\n    print(\"   ‚úì Hindi ‚Üî English translation\")\n    print(\"   ‚úì Direct recording processing fallback\")\n    print(\"   ‚úì Recording status monitoring\")\n    print(f\"   ‚úì Google Cloud: {GOOGLE_CLOUD_AVAILABLE}\")\n    print(f\"   ‚úì Credentials: {credentials_setup}\")\n    print(\"=\"*50)\n    \n    options = {\n        'bind': f'0.0.0.0:{port}',\n        'workers': 1,\n        'worker_class': 'sync',\n        'timeout': 30,\n    }\n    \n    StandaloneApplication(app, options).run()\n","size_bytes":12495},"google_voice_translator.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nGoogle Cloud Voice Translator\nNo Twilio - Pure Google Cloud solution\n\"\"\"\n\nimport os\nimport json\nimport pyaudio\nimport wave\nimport threading\nimport time\nfrom flask import Flask, request, Response\n\n# Set up Google Cloud credentials\ndef setup_google_credentials():\n    try:\n        if os.path.exists('google-credentials.json'):\n            os.environ['GOOGLE_APPLICATION_CREDENTIALS'] = 'google-credentials.json'\n            print(\"‚úÖ Google credentials set up from local file\")\n            return True\n        return False\n    except Exception as e:\n        print(f\"‚ùå Credentials error: {e}\")\n        return False\n\ncredentials_setup = setup_google_credentials()\n\n# Import Google Cloud\ntry:\n    from google.cloud import translate_v2 as translate\n    from google.cloud import texttospeech\n    from google.cloud import speech\n    GOOGLE_CLOUD_AVAILABLE = True\n    print(\"‚úÖ Google Cloud available\")\nexcept ImportError:\n    GOOGLE_CLOUD_AVAILABLE = False\n    print(\"‚ùå Google Cloud not available\")\n\napp = Flask(__name__)\n\n# Audio settings\nFORMAT = pyaudio.paInt16\nCHANNELS = 1\nRATE = 16000\nCHUNK = 1024\nRECORD_SECONDS = 5\n\nclass VoiceTranslator:\n    def __init__(self):\n        self.audio = pyaudio.PyAudio()\n        self.is_recording = False\n        \n    def record_audio(self, duration=5):\n        \"\"\"Record audio from microphone\"\"\"\n        try:\n            stream = self.audio.open(\n                format=FORMAT,\n                channels=CHANNELS,\n                rate=RATE,\n                input=True,\n                frames_per_buffer=CHUNK\n            )\n            \n            print(f\"üé§ Recording for {duration} seconds...\")\n            frames = []\n            \n            for _ in range(0, int(RATE / CHUNK * duration)):\n                if not self.is_recording:\n                    break\n                data = stream.read(CHUNK, exception_on_overflow=False)\n                frames.append(data)\n            \n            stream.stop_stream()\n            stream.close()\n            \n            return b''.join(frames)\n            \n        except Exception as e:\n            print(f\"‚ùå Recording error: {e}\")\n            return None\n    \n    def transcribe_audio(self, audio_data):\n        \"\"\"Convert speech to text using Google Speech-to-Text\"\"\"\n        try:\n            client = speech.SpeechClient()\n            \n            audio = speech.RecognitionAudio(content=audio_data)\n            config = speech.RecognitionConfig(\n                encoding=speech.RecognitionConfig.AudioEncoding.LINEAR16,\n                sample_rate_hertz=RATE,\n                language_code=\"hi-IN\",  # Hindi\n                alternative_language_codes=[\"en-US\"]  # English fallback\n            )\n            \n            response = client.recognize(config=config, audio=audio)\n            \n            for result in response.results:\n                transcript = result.alternatives[0].transcript\n                confidence = result.alternatives[0].confidence\n                print(f\"üé§ Speech: '{transcript}' (Confidence: {confidence:.2f})\")\n                return transcript, confidence\n            \n            return None, 0\n            \n        except Exception as e:\n            print(f\"‚ùå Speech-to-Text error: {e}\")\n            return None, 0\n    \n    def translate_text(self, text, source_lang, target_lang):\n        \"\"\"Translate text using Google Translate\"\"\"\n        try:\n            client = translate.Client()\n            result = client.translate(\n                text, \n                source_language=source_lang, \n                target_language=target_lang,\n                format_='text'\n            )\n            translated_text = result['translatedText']\n            print(f\"üîÑ Translation: '{text}' ‚Üí '{translated_text}'\")\n            return translated_text\n            \n        except Exception as e:\n            print(f\"‚ùå Translation error: {e}\")\n            return text\n    \n    def synthesize_speech(self, text, language_code):\n        \"\"\"Convert text to speech using Google Text-to-Speech\"\"\"\n        try:\n            client = texttospeech.TextToSpeechClient()\n            synthesis_input = texttospeech.SynthesisInput(text=text)\n            \n            if language_code == 'hi':\n                voice = texttospeech.VoiceSelectionParams(\n                    language_code=\"hi-IN\",\n                    name=\"hi-IN-Standard-A\",\n                    ssml_gender=texttospeech.SsmlVoiceGender.FEMALE\n                )\n            else:  # en\n                voice = texttospeech.VoiceSelectionParams(\n                    language_code=\"en-US\",\n                    name=\"en-US-Standard-C\",\n                    ssml_gender=texttospeech.SsmlVoiceGender.FEMALE\n                )\n            \n            audio_config = texttospeech.AudioConfig(\n                audio_encoding=texttospeech.AudioEncoding.LINEAR16,\n                sample_rate_hertz=16000\n            )\n            \n            response = client.synthesize_speech(\n                input=synthesis_input,\n                voice=voice,\n                audio_config=audio_config\n            )\n            \n            print(f\"üîä Synthesized speech for: '{text}'\")\n            return response.audio_content\n            \n        except Exception as e:\n            print(f\"‚ùå Text-to-Speech error: {e}\")\n            return None\n    \n    def play_audio(self, audio_data):\n        \"\"\"Play audio through speakers\"\"\"\n        try:\n            stream = self.audio.open(\n                format=FORMAT,\n                channels=CHANNELS,\n                rate=16000,\n                output=True\n            )\n            \n            print(\"üîä Playing audio...\")\n            stream.write(audio_data)\n            stream.stop_stream()\n            stream.close()\n            print(\"‚úÖ Audio played successfully\")\n            \n        except Exception as e:\n            print(f\"‚ùå Audio playback error: {e}\")\n    \n    def detect_language(self, text):\n        \"\"\"Detect if text is Hindi or English\"\"\"\n        devanagari_chars = set('‡§Ö‡§Ü‡§á‡§à‡§â‡§ä‡§ã‡§è‡§ê‡§ì‡§î‡§ï‡§ñ‡§ó‡§ò‡§ô‡§ö‡§õ‡§ú‡§ù‡§û‡§ü‡§†‡§°‡§¢‡§£‡§§‡§•‡§¶‡§ß‡§®‡§™‡§´‡§¨‡§≠‡§Æ‡§Ø‡§∞‡§≤‡§µ‡§∂‡§∑‡§∏‡§π')\n        is_hindi = any(char in devanagari_chars for char in text)\n        \n        # Check for common Hindi words in English script\n        hindi_words = ['namaste', 'kaise', 'ho', 'dhanyawad', 'alvida', 'theek', 'hun', 'aap']\n        speech_words = text.lower().split()\n        has_hindi_words = any(word in speech_words for word in hindi_words)\n        \n        return 'hi' if (is_hindi or has_hindi_words) else 'en'\n    \n    def translate_and_speak(self, text):\n        \"\"\"Complete translation and speech pipeline\"\"\"\n        if not text:\n            return\n        \n        # Detect language\n        source_lang = self.detect_language(text)\n        target_lang = 'en' if source_lang == 'hi' else 'hi'\n        \n        # Translate\n        translated_text = self.translate_text(text, source_lang, target_lang)\n        \n        # Synthesize speech\n        audio_data = self.synthesize_speech(translated_text, target_lang)\n        \n        if audio_data:\n            # Play audio\n            self.play_audio(audio_data)\n        else:\n            print(f\"‚ùå Could not synthesize speech for: '{translated_text}'\")\n\n# Global translator instance\ntranslator = VoiceTranslator()\n\n@app.route('/')\ndef home():\n    return {\n        \"message\": \"Google Cloud Voice Translator\",\n        \"version\": \"1.0.0\",\n        \"features\": [\n            \"Google Speech-to-Text\",\n            \"Google Translate\",\n            \"Google Text-to-Speech\",\n            \"Real-time Hindi ‚Üî English translation\"\n        ],\n        \"status\": \"Ready\"\n    }, 200\n\n@app.route('/health')\ndef health():\n    return {\n        \"status\": \"healthy\",\n        \"google_cloud_available\": GOOGLE_CLOUD_AVAILABLE,\n        \"credentials_setup\": credentials_setup\n    }, 200\n\n@app.route('/start-recording', methods=['POST'])\ndef start_recording():\n    \"\"\"Start recording audio\"\"\"\n    try:\n        translator.is_recording = True\n        \n        # Record audio in a separate thread\n        def record_and_translate():\n            audio_data = translator.record_audio(RECORD_SECONDS)\n            if audio_data:\n                # Transcribe\n                transcript, confidence = translator.transcribe_audio(audio_data)\n                if transcript and confidence > 0.5:\n                    # Translate and speak\n                    translator.translate_and_speak(transcript)\n                else:\n                    print(\"‚ùå No speech detected or low confidence\")\n            translator.is_recording = False\n        \n        thread = threading.Thread(target=record_and_translate)\n        thread.start()\n        \n        return {\"status\": \"recording_started\", \"duration\": RECORD_SECONDS}, 200\n        \n    except Exception as e:\n        return {\"error\": str(e)}, 500\n\n@app.route('/stop-recording', methods=['POST'])\ndef stop_recording():\n    \"\"\"Stop recording audio\"\"\"\n    translator.is_recording = False\n    return {\"status\": \"recording_stopped\"}, 200\n\n@app.route('/translate-text', methods=['POST'])\ndef translate_text_endpoint():\n    \"\"\"Translate text and return audio\"\"\"\n    try:\n        data = request.get_json()\n        text = data.get('text', '')\n        \n        if not text:\n            return {\"error\": \"No text provided\"}, 400\n        \n        # Detect language\n        source_lang = translator.detect_language(text)\n        target_lang = 'en' if source_lang == 'hi' else 'hi'\n        \n        # Translate\n        translated_text = translator.translate_text(text, source_lang, target_lang)\n        \n        # Synthesize speech\n        audio_data = translator.synthesize_speech(translated_text, target_lang)\n        \n        if audio_data:\n            # Return audio as base64\n            import base64\n            audio_b64 = base64.b64encode(audio_data).decode('utf-8')\n            return {\n                \"translated_text\": translated_text,\n                \"source_language\": source_lang,\n                \"target_language\": target_lang,\n                \"audio_base64\": audio_b64\n            }, 200\n        else:\n            return {\"error\": \"Could not synthesize speech\"}, 500\n            \n    except Exception as e:\n        return {\"error\": str(e)}, 500\n\nif __name__ == \"__main__\":\n    port = int(os.environ.get('PORT', 3000))\n    print(f\"üöÄ Google Cloud Voice Translator on port {port}\")\n    print(\"=\"*60)\n    print(\"‚úÖ Features:\")\n    print(\"   ‚úì Google Speech-to-Text (Hindi + English)\")\n    print(\"   ‚úì Google Translate (Hindi ‚Üî English)\")\n    print(\"   ‚úì Google Text-to-Speech (High-quality voices)\")\n    print(\"   ‚úì Real-time audio recording and playback\")\n    print(\"   ‚úì No Twilio dependency\")\n    print(f\"   ‚úì Google Cloud: {GOOGLE_CLOUD_AVAILABLE}\")\n    print(f\"   ‚úì Credentials: {credentials_setup}\")\n    print(\"=\"*60)\n    print(\"üìû Usage:\")\n    print(\"   POST /start-recording - Start recording and translation\")\n    print(\"   POST /stop-recording - Stop recording\")\n    print(\"   POST /translate-text - Translate text and get audio\")\n    print(\"=\"*60)\n    \n    app.run(host='0.0.0.0', port=port, debug=False)\n","size_bytes":11171},"ultimate_twilio_translator.py":{"content":"import os\nimport asyncio\nimport json\nimport base64\nimport queue\nimport threading\nimport time\nimport struct\nfrom collections import deque\nfrom flask import Flask, request, Response\nimport websockets\nfrom google.cloud import speech\nfrom google.cloud import texttospeech\nfrom google.cloud import translate_v2 as translate\n\n# Set Google Cloud credentials\nos.environ[\"GOOGLE_APPLICATION_CREDENTIALS\"] = \"/Users/apple/text_to_voice_translator/google-credentials.json\"\n\n# Global variables for managing call state\nactive_calls = {}\n\nclass UltimateCallSession:\n    def __init__(self, call_sid, stream_sid):\n        self.call_sid = call_sid\n        self.stream_sid = stream_sid\n        self.last_processed_transcript = \"\"\n        self.file_counter = 0\n        self.last_translation_time = 0\n        self.is_processing = False\n        self.translation_lock = threading.Lock()\n\n# Translation functions\ndef translate_hindi_to_english(hindi_text):\n    \"\"\"Translate Hindi text to English\"\"\"\n    try:\n        client = translate.Client()\n        result = client.translate(hindi_text, source_language='hi', target_language='en')\n        english_text = result['translatedText']\n        print(f\"Hindi ‚Üí English: {hindi_text} ‚Üí {english_text}\")\n        return english_text\n    except Exception as e:\n        print(f\"Hindi to English translation error: {e}\")\n        return None\n\ndef translate_english_to_hindi(english_text):\n    \"\"\"Translate English text to Hindi\"\"\"\n    try:\n        client = translate.Client()\n        result = client.translate(english_text, source_language='en', target_language='hi')\n        hindi_text = result['translatedText']\n        print(f\"English ‚Üí Hindi: {english_text} ‚Üí {hindi_text}\")\n        return hindi_text\n    except Exception as e:\n        print(f\"English to Hindi translation error: {e}\")\n        return None\n\n# Text-to-Speech functions\ndef synthesize_english_speech(english_text, file_counter):\n    \"\"\"Convert English text to speech\"\"\"\n    try:\n        client = texttospeech.TextToSpeechClient()\n        synthesis_input = texttospeech.SynthesisInput(text=english_text)\n        voice = texttospeech.VoiceSelectionParams(\n            language_code=\"en-US\", \n            name=\"en-US-Standard-A\"\n        )\n        audio_config = texttospeech.AudioConfig(\n            audio_encoding=texttospeech.AudioEncoding.MULAW, \n            sample_rate_hertz=8000\n        )\n\n        response = client.synthesize_speech(\n            input=synthesis_input, \n            voice=voice, \n            audio_config=audio_config\n        )\n        \n        return response.audio_content\n    except Exception as e:\n        print(f\"English Text-to-Speech error: {e}\")\n        return None\n\ndef synthesize_hindi_speech(hindi_text, file_counter):\n    \"\"\"Convert Hindi text to speech\"\"\"\n    try:\n        client = texttospeech.TextToSpeechClient()\n        synthesis_input = texttospeech.SynthesisInput(text=hindi_text)\n        voice = texttospeech.VoiceSelectionParams(\n            language_code=\"hi-IN\", \n            name=\"hi-IN-Standard-A\"\n        )\n        audio_config = texttospeech.AudioConfig(\n            audio_encoding=texttospeech.AudioEncoding.MULAW, \n            sample_rate_hertz=8000\n        )\n\n        response = client.synthesize_speech(\n            input=synthesis_input, \n            voice=voice, \n            audio_config=audio_config\n        )\n        \n        return response.audio_content\n    except Exception as e:\n        print(f\"Hindi Text-to-Speech error: {e}\")\n        return None\n\n# WebSocket handler for Twilio media stream\nasync def twilio_websocket(websocket, path):\n    print(\"New WebSocket connection established\")\n    print(f\"WebSocket path: {path}\")\n    \n    # Initialize speech client\n    speech_client = speech.SpeechClient()\n    \n    # Speech recognition configurations\n    hindi_config = speech.RecognitionConfig(\n        encoding=speech.RecognitionConfig.AudioEncoding.MULAW,\n        sample_rate_hertz=8000,\n        language_code=\"hi-IN\",\n        enable_automatic_punctuation=True\n    )\n    \n    english_config = speech.RecognitionConfig(\n        encoding=speech.RecognitionConfig.AudioEncoding.MULAW,\n        sample_rate_hertz=8000,\n        language_code=\"en-US\",\n        enable_automatic_punctuation=True\n    )\n    \n    # Call session variables\n    call_session = None\n    current_language = 'hi-IN'  # Start with Hindi detection\n    last_processed_transcript = \"\"\n    file_counter = 0\n    stream_sid = None\n    min_translation_interval = 2.0\n\n    async def stream_audio_to_speech():\n        nonlocal stream_sid, call_session, current_language, last_processed_transcript\n        nonlocal file_counter\n        \n        async for message in websocket:\n            try:\n                data = json.loads(message)\n                \n                if data['event'] == 'media':\n                    stream_sid = data['streamSid']\n                    audio_payload = data['media']['payload']\n                    \n                    # Send audio for recognition\n                    audio = base64.b64decode(audio_payload)\n                    yield speech.StreamingRecognizeRequest(audio_content=audio)\n                    \n                elif data['event'] == 'start':\n                    print(f\"Stream started: {data['streamSid']}\")\n                    stream_sid = data['streamSid']\n                    call_session = UltimateCallSession(data.get('callSid', 'unknown'), stream_sid)\n                    active_calls[stream_sid] = call_session\n                    \n                elif data['event'] == 'stop':\n                    print(\"Stream stopped\")\n                    if stream_sid in active_calls:\n                        del active_calls[stream_sid]\n                    break\n                    \n            except json.JSONDecodeError as e:\n                print(f\"JSON decode error: {e}\")\n                continue\n            except Exception as e:\n                print(f\"WebSocket message error: {e}\")\n                continue\n\n    try:\n        # Start with Hindi recognition\n        streaming_config = speech.StreamingRecognitionConfig(\n            config=hindi_config, \n            interim_results=True\n        )\n        \n        responses = speech_client.streaming_recognize(streaming_config, stream_audio_to_speech())\n        \n        async for response in responses:\n            if not response.results or not response.results[0].alternatives:\n                continue\n                \n            transcript = response.results[0].alternatives[0].transcript\n            confidence = response.results[0].alternatives[0].confidence\n            \n            # Process final results with good confidence\n            if (response.results[0].is_final and \n                transcript.strip() and \n                transcript != last_processed_transcript and\n                confidence > 0.6):\n                \n                current_time = time.time()\n                \n                # Rate limiting\n                if current_time - call_session.last_translation_time < min_translation_interval:\n                    continue\n                \n                call_session.last_translation_time = current_time\n                \n                print(f\"Final transcript ({current_language}): {transcript} (confidence: {confidence:.2f})\")\n                last_processed_transcript = transcript\n                \n                # Translate and synthesize based on detected language\n                if current_language == 'hi-IN':\n                    # Hindi speaker ‚Üí translate to English ‚Üí synthesize English\n                    english_text = translate_hindi_to_english(transcript)\n                    if english_text:\n                        file_counter += 1\n                        audio_content = synthesize_english_speech(english_text, file_counter)\n                        if audio_content and stream_sid:\n                            await websocket.send(json.dumps({\n                                'event': 'media',\n                                'streamSid': stream_sid,\n                                'media': {'payload': base64.b64encode(audio_content).decode('utf-8')}\n                            }))\n                            print(f\"Sent English translation: {english_text}\")\n                            \n                elif current_language == 'en-US':\n                    # English speaker ‚Üí translate to Hindi ‚Üí synthesize Hindi\n                    hindi_text = translate_english_to_hindi(transcript)\n                    if hindi_text:\n                        file_counter += 1\n                        audio_content = synthesize_hindi_speech(hindi_text, file_counter)\n                        if audio_content and stream_sid:\n                            await websocket.send(json.dumps({\n                                'event': 'media',\n                                'streamSid': stream_sid,\n                                'media': {'payload': base64.b64encode(audio_content).decode('utf-8')}\n                            }))\n                            print(f\"Sent Hindi translation: {hindi_text}\")\n                \n                # Switch language for next detection\n                current_language = 'en-US' if current_language == 'hi-IN' else 'hi-IN'\n                \n                # Update streaming config for next language\n                if current_language == 'hi-IN':\n                    streaming_config = speech.StreamingRecognitionConfig(\n                        config=hindi_config, \n                        interim_results=True\n                    )\n                else:\n                    streaming_config = speech.StreamingRecognitionConfig(\n                        config=english_config, \n                        interim_results=True\n                    )\n                \n    except Exception as e:\n        print(f\"Streaming error: {e}\")\n    finally:\n        try:\n            await websocket.close()\n        except Exception as e:\n            print(f\"WebSocket close error: {e}\")\n\n# Flask app for HTTP webhooks\napp = Flask(__name__)\n\n@app.route('/twilio-webhook', methods=['POST'])\ndef twilio_webhook():\n    \"\"\"Handle incoming Twilio calls\"\"\"\n    call_sid = request.form.get('CallSid')\n    from_number = request.form.get('From')\n    to_number = request.form.get('To')\n    \n    print(f\"Incoming call from {from_number} to {to_number} (CallSid: {call_sid})\")\n    \n    # TwiML response to start media stream\n    twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <Response>\n        <Start>\n            <Stream url=\"wss://1e6d229a057a.ngrok-free.app/websocket\" />\n        </Start>\n        <Say language=\"hi-IN\">‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§∏‡•á‡§µ‡§æ ‡§§‡•à‡§Ø‡§æ‡§∞ ‡§π‡•à‡•§</Say>\n        <Say language=\"en-US\">Hello! Translation service is ready.</Say>\n        <Pause length=\"1\"/>\n    </Response>\"\"\"\n    \n    return Response(twiml, mimetype='text/xml')\n\n@app.route('/call-status', methods=['POST'])\ndef call_status():\n    \"\"\"Handle call status updates\"\"\"\n    call_sid = request.form.get('CallSid')\n    call_status = request.form.get('CallStatus')\n    \n    print(f\"Call {call_sid} status: {call_status}\")\n    \n    if call_status == 'completed':\n        # Clean up call session\n        for stream_sid, session in list(active_calls.items()):\n            if session.call_sid == call_sid:\n                del active_calls[stream_sid]\n                break\n    \n    return Response('OK', mimetype='text/plain')\n\n# Start servers\nasync def start_servers():\n    if not os.path.exists(\"/Users/apple/text_to_voice_translator/google-credentials.json\"):\n        print(\"Error: google-credentials.json not found.\")\n        return\n\n    # Start Flask in a separate thread\n    def run_flask():\n        app.run(host='0.0.0.0', port=3000, debug=False, use_reloader=False)\n    \n    flask_thread = threading.Thread(target=run_flask, daemon=True)\n    flask_thread.start()\n    print(\"Flask server running on port 3000\")\n\n    # Start WebSocket server on port 3000 (same as Flask)\n    try:\n        start_server = websockets.serve(twilio_websocket, '0.0.0.0', 3000)\n        await start_server\n        print(\"WebSocket server running on port 3000\")\n        print(\"\\n\" + \"=\"*70)\n        print(\"ULTIMATE BIDIRECTIONAL VOICE TRANSLATION SYSTEM\")\n        print(\"=\"*70)\n        print(\"Features:\")\n        print(\"‚úì Real-time Hindi ‚Üî English translation\")\n        print(\"‚úì Single port solution (HTTP + WebSocket)\")\n        print(\"‚úì Works with free ngrok account\")\n        print(\"‚úì Optimized for Twilio media streaming\")\n        print(\"\\nSetup Instructions:\")\n        print(\"1. Start ngrok: ngrok http 3000\")\n        print(\"2. Update the WebSocket URL in the TwiML response\")\n        print(\"3. Configure your Twilio phone number webhook\")\n        print(\"4. Make a call to your Twilio number\")\n        print(\"\\nNote: This solution uses a single port for both HTTP and WebSocket\")\n        print(\"The WebSocket will be accessible through the same ngrok tunnel\")\n        print(\"=\"*70)\n    except Exception as e:\n        print(f\"WebSocket server error: {e}\")\n\nif __name__ == \"__main__\":\n    try:\n        asyncio.get_event_loop().run_until_complete(start_servers())\n        asyncio.get_event_loop().run_forever()\n    except KeyboardInterrupt:\n        print(\"Server stopped by user.\")\n    except Exception as e:\n        print(f\"Server startup error: {e}\")\n","size_bytes":13334},"railway_google_tts.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nRailway Deployment - GOOGLE TTS Voice Translator\nFIXED: Uses Google Cloud Text-to-Speech API for better voice quality\n\"\"\"\n\nimport os\nimport json\nimport time\nimport warnings\nimport requests\nimport base64\nimport io\nfrom flask import Flask, request, Response\nimport gunicorn.app.base\n\n# Suppress warnings\nwarnings.filterwarnings(\"ignore\")\n\n# Set up Google Cloud credentials\ndef setup_google_credentials():\n    try:\n        creds_json = os.environ.get('GOOGLE_CREDENTIALS_JSON')\n        if creds_json:\n            creds_data = json.loads(creds_json)\n            temp_creds_path = '/tmp/google-credentials.json'\n            with open(temp_creds_path, 'w') as f:\n                json.dump(creds_data, f)\n            os.environ['GOOGLE_APPLICATION_CREDENTIALS'] = temp_creds_path\n            print(\"‚úÖ Google credentials set up\")\n            return True\n        return False\n    except Exception as e:\n        print(f\"‚ùå Credentials error: {e}\")\n        return False\n\ncredentials_setup = setup_google_credentials()\n\n# Import Google Cloud\ntry:\n    from google.cloud import translate_v2 as translate\n    from google.cloud import texttospeech\n    GOOGLE_CLOUD_AVAILABLE = True\n    print(\"‚úÖ Google Cloud available\")\nexcept ImportError:\n    GOOGLE_CLOUD_AVAILABLE = False\n    print(\"‚ùå Google Cloud not available\")\n\napp = Flask(__name__)\n\n@app.route('/health')\ndef health_check():\n    return {\n        \"status\": \"healthy\",\n        \"google_cloud_available\": GOOGLE_CLOUD_AVAILABLE,\n        \"credentials_setup\": credentials_setup,\n        \"version\": \"25.0-google-tts\"\n    }, 200\n\n@app.route('/')\ndef home():\n    return {\n        \"message\": \"GOOGLE TTS Twilio Voice Translator\",\n        \"webhook\": \"/twilio-webhook\",\n        \"version\": \"25.0-google-tts\"\n    }, 200\n\n@app.route('/twilio-webhook', methods=['POST'])\ndef twilio_webhook():\n    call_sid = request.form.get('CallSid')\n    from_number = request.form.get('From')\n    \n    print(f\"\\nüìû CALL FROM: {from_number}\")\n    print(f\"   CallSid: {call_sid}\")\n    print(\"=\"*40)\n    \n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    \n    # GOOGLE TTS: Better speech recognition for both languages\n    twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <Response>\n        <Say voice=\"alice\" language=\"en-US\">Hello! Speak in English or Hindi for translation.</Say>\n        <Pause length=\"2\"/>\n        <Gather \n            action=\"https://{railway_domain}/gather-webhook\" \n            method=\"POST\"\n            input=\"speech\"\n            speechTimeout=\"auto\"\n            timeout=\"30\"\n            language=\"en-US\"\n            hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida, main theek hun, aap kaise hain, kya haal hai, shukriya, namaskar, pranam, aapka swagat hai, main aap se mil kar khush hun, aap kahan se hain, main ghar ja raha hun, main office ja raha hun, main school ja raha hun, main market ja raha hun, main doctor ke paas ja raha hun, main hospital ja raha hun, main bank ja raha hun, main restaurant ja raha hun, main hotel ja raha hun, main station ja raha hun, main airport ja raha hun, main bus stand ja raha hun, main railway station ja raha hun, main metro station ja raha hun, main shopping mall ja raha hun, main cinema hall ja raha hun, main park ja raha hun, main temple ja raha hun, main mosque ja raha hun, main church ja raha hun, main gurudwara ja raha hun, main mandir ja raha hun, main masjid ja raha hun, main girja ja raha hun, main gurdwara ja raha hun, main khana kha raha hun, main paani pi raha hun, main sone ja raha hun, main uth raha hun, main baith raha hun, main chal raha hun, main daud raha hun, main khel raha hun, main padh raha hun, main likh raha hun, main sun raha hun, main dekh raha hun, main bol raha hun, main has raha hun, main ro raha hun, main soch raha hun, main samajh raha hun, main jaanta hun, main nahi jaanta, main chahta hun, main nahi chahta, main karna chahta hun, main nahi karna chahta, main aa sakta hun, main nahi aa sakta, main ja sakta hun, main nahi ja sakta, main kar sakta hun, main nahi kar sakta, main de sakta hun, main nahi de sakta, main le sakta hun, main nahi le sakta, main bana sakta hun, main nahi bana sakta, main kharid sakta hun, main nahi kharid sakta, main bech sakta hun, main nahi bech sakta, main sikha sakta hun, main nahi sikha sakta, main seekh sakta hun, main nahi seekh sakta, main samjha sakta hun, main nahi samjha sakta, main bata sakta hun, main nahi bata sakta, main puch sakta hun, main nahi puch sakta, main jawab de sakta hun, main nahi jawab de sakta, main madad kar sakta hun, main nahi madad kar sakta, main kaam kar sakta hun, main nahi kaam kar sakta, main ghar ja sakta hun, main nahi ghar ja sakta, main office ja sakta hun, main nahi office ja sakta, main school ja sakta hun, main nahi school ja sakta, main market ja sakta hun, main nahi market ja sakta, main doctor ke paas ja sakta hun, main nahi doctor ke paas ja sakta, main hospital ja sakta hun, main nahi hospital ja sakta, main bank ja sakta hun, main nahi bank ja sakta, main restaurant ja sakta hun, main nahi restaurant ja sakta, main hotel ja sakta hun, main nahi hotel ja sakta, main station ja sakta hun, main nahi station ja sakta, main airport ja sakta hun, main nahi airport ja sakta, main bus stand ja sakta hun, main nahi bus stand ja sakta, main railway station ja sakta hun, main nahi railway station ja sakta, main metro station ja sakta hun, main nahi metro station ja sakta, main shopping mall ja sakta hun, main nahi shopping mall ja sakta, main cinema hall ja sakta hun, main nahi cinema hall ja sakta, main park ja sakta hun, main nahi park ja sakta, main temple ja sakta hun, main nahi temple ja sakta, main mosque ja sakta hun, main nahi mosque ja sakta, main church ja sakta hun, main nahi church ja sakta, main gurudwara ja sakta hun, main nahi gurudwara ja sakta, main mandir ja sakta hun, main nahi mandir ja sakta, main masjid ja sakta hun, main nahi masjid ja sakta, main girja ja sakta hun, main nahi girja ja sakta, main gurdwara ja sakta hun, main nahi gurdwara ja sakta\"\n        />\n        <Say voice=\"alice\" language=\"en-US\">I didn't hear anything. Please try again.</Say>\n        <Pause length=\"2\"/>\n        <Gather \n            action=\"https://{railway_domain}/gather-webhook\" \n            method=\"POST\"\n            input=\"speech\"\n            speechTimeout=\"auto\"\n            timeout=\"30\"\n            language=\"en-US\"\n            hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n        />\n        <Say voice=\"alice\" language=\"en-US\">Thank you. Goodbye.</Say>\n    </Response>\"\"\"\n    \n    return Response(twiml, mimetype='text/xml')\n\n@app.route('/gather-webhook', methods=['POST'])\ndef gather_webhook():\n    call_sid = request.form.get('CallSid')\n    speech_result = request.form.get('SpeechResult', '')\n    confidence = request.form.get('Confidence', '0')\n    \n    print(f\"\\nüé§ GATHER WEBHOOK:\")\n    print(f\"   CallSid: {call_sid}\")\n    print(f\"   Speech Result: '{speech_result}'\")\n    print(f\"   Confidence: {confidence}\")\n    print(\"=\"*40)\n    \n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    \n    if not speech_result or len(speech_result.strip()) < 2:\n        print(\"‚ùå No speech result - fallback response\")\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"en-US\">I didn't hear anything. Please speak clearly.</Say>\n            <Pause length=\"2\"/>\n            <Gather \n                action=\"https://{railway_domain}/gather-webhook\" \n                method=\"POST\"\n                input=\"speech\"\n                speechTimeout=\"auto\"\n                timeout=\"30\"\n                language=\"en-US\"\n                hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n            />\n            <Say voice=\"alice\" language=\"en-US\">Thank you. Goodbye.</Say>\n        </Response>\"\"\"\n        return Response(twiml, mimetype='text/xml')\n    \n    try:\n        # GOOGLE TTS: Better language detection\n        devanagari_chars = set('‡§Ö‡§Ü‡§á‡§à‡§â‡§ä‡§ã‡§è‡§ê‡§ì‡§î‡§ï‡§ñ‡§ó‡§ò‡§ô‡§ö‡§õ‡§ú‡§ù‡§û‡§ü‡§†‡§°‡§¢‡§£‡§§‡§•‡§¶‡§ß‡§®‡§™‡§´‡§¨‡§≠‡§Æ‡§Ø‡§∞‡§≤‡§µ‡§∂‡§∑‡§∏‡§π')\n        is_hindi = any(char in devanagari_chars for char in speech_result)\n        \n        # Check for common Hindi words in English script\n        hindi_words = ['namaste', 'kaise', 'ho', 'dhanyawad', 'alvida', 'theek', 'hun', 'aap', 'kahan', 'se', 'ghar', 'ja', 'raha', 'office', 'school', 'market', 'doctor', 'hospital', 'bank', 'restaurant', 'hotel', 'station', 'airport', 'bus', 'railway', 'metro', 'shopping', 'mall', 'cinema', 'hall', 'park', 'temple', 'mosque', 'church', 'gurudwara', 'mandir', 'masjid', 'girja', 'gurdwara', 'khana', 'paani', 'sone', 'uth', 'baith', 'chal', 'daud', 'khel', 'padh', 'likh', 'sun', 'dekh', 'bol', 'has', 'ro', 'soch', 'samajh', 'jaanta', 'chahta', 'karna', 'aa', 'sakta', 'de', 'le', 'bana', 'kharid', 'bech', 'sikha', 'seekh', 'samjha', 'bata', 'puch', 'jawab', 'madad', 'kaam']\n        has_hindi_words = any(word in speech_result.lower() for word in hindi_words)\n        \n        if is_hindi or has_hindi_words:\n            # Hindi to English\n            translated_text = translate_text(speech_result, 'hi', 'en')\n            print(f\"üîÑ Hindi ‚Üí English: '{translated_text}'\")\n            \n            # GOOGLE TTS: Generate English audio with Google TTS\n            audio_url = generate_google_tts_audio(translated_text, 'en-US')\n            \n            twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n            <Response>\n                <Play>{audio_url}</Play>\n                <Pause length=\"3\"/>\n                <Say voice=\"alice\" language=\"en-US\">Say something else or goodbye.</Say>\n                <Gather \n                    action=\"https://{railway_domain}/gather-webhook\" \n                    method=\"POST\"\n                    input=\"speech\"\n                    speechTimeout=\"auto\"\n                    timeout=\"30\"\n                    language=\"en-US\"\n                    hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n                />\n                <Say voice=\"alice\" language=\"en-US\">Thank you. Goodbye.</Say>\n            </Response>\"\"\"\n        else:\n            # English to Hindi\n            translated_text = translate_text(speech_result, 'en', 'hi')\n            print(f\"üîÑ English ‚Üí Hindi: '{translated_text}'\")\n            \n            # GOOGLE TTS: Generate Hindi audio with Google TTS\n            audio_url = generate_google_tts_audio(translated_text, 'hi-IN')\n            \n            twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n            <Response>\n                <Play>{audio_url}</Play>\n                <Pause length=\"3\"/>\n                <Say voice=\"alice\" language=\"en-US\">Say something else or goodbye.</Say>\n                <Gather \n                    action=\"https://{railway_domain}/gather-webhook\" \n                    method=\"POST\"\n                    input=\"speech\"\n                    speechTimeout=\"auto\"\n                    timeout=\"30\"\n                    language=\"en-US\"\n                    hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n                />\n                <Say voice=\"alice\" language=\"en-US\">Thank you. Goodbye.</Say>\n            </Response>\"\"\"\n        \n        print(f\"üîä SPEAKING: Translation: {translated_text}\")\n        print(\"=\"*40)\n        \n        return Response(twiml, mimetype='text/xml')\n        \n    except Exception as e:\n        print(f\"‚ùå Translation error: {e}\")\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"en-US\">Translation error. Please try again.</Say>\n            <Pause length=\"2\"/>\n            <Gather \n                action=\"https://{railway_domain}/gather-webhook\" \n                method=\"POST\"\n                input=\"speech\"\n                speechTimeout=\"auto\"\n                timeout=\"30\"\n                language=\"en-US\"\n                hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n            />\n            <Say voice=\"alice\" language=\"en-US\">Thank you. Goodbye.</Say>\n        </Response>\"\"\"\n        return Response(twiml, mimetype='text/xml')\n\ndef generate_google_tts_audio(text, language_code):\n    \"\"\"Generate audio using Google Cloud Text-to-Speech API\"\"\"\n    try:\n        if not GOOGLE_CLOUD_AVAILABLE:\n            return None\n        \n        print(f\"üéµ Generating Google TTS audio...\")\n        print(f\"   Text: '{text}'\")\n        print(f\"   Language: {language_code}\")\n        \n        client = texttospeech.TextToSpeechClient()\n        \n        # Set up synthesis input\n        synthesis_input = texttospeech.SynthesisInput(text=text)\n        \n        # Configure voice\n        if language_code == 'hi-IN':\n            voice = texttospeech.VoiceSelectionParams(\n                language_code=\"hi-IN\",\n                name=\"hi-IN-Standard-A\",  # Hindi female voice\n                ssml_gender=texttospeech.SsmlVoiceGender.FEMALE\n            )\n        else:  # en-US\n            voice = texttospeech.VoiceSelectionParams(\n                language_code=\"en-US\",\n                name=\"en-US-Standard-C\",  # English female voice\n                ssml_gender=texttospeech.SsmlVoiceGender.FEMALE\n            )\n        \n        # Configure audio\n        audio_config = texttospeech.AudioConfig(\n            audio_encoding=texttospeech.AudioEncoding.MP3,\n            sample_rate_hertz=22050\n        )\n        \n        # Generate speech\n        response = client.synthesize_speech(\n            input=synthesis_input,\n            voice=voice,\n            audio_config=audio_config\n        )\n        \n        # Save audio to temporary file\n        audio_filename = f\"tts_audio_{int(time.time())}.mp3\"\n        audio_path = f\"/tmp/{audio_filename}\"\n        \n        with open(audio_path, 'wb') as out:\n            out.write(response.audio_content)\n        \n        # Upload to a public URL (for Railway deployment)\n        # For now, we'll use a simple approach with base64 encoding\n        audio_b64 = base64.b64encode(response.audio_content).decode('utf-8')\n        \n        # Create a data URL for Twilio\n        audio_url = f\"data:audio/mp3;base64,{audio_b64}\"\n        \n        print(f\"‚úÖ Google TTS audio generated successfully\")\n        return audio_url\n        \n    except Exception as e:\n        print(f\"‚ùå Google TTS error: {e}\")\n        return None\n\ndef translate_text(text, source_lang, target_lang):\n    try:\n        if not GOOGLE_CLOUD_AVAILABLE:\n            return text\n        \n        print(f\"üîÑ Calling Google Translate API...\")\n        print(f\"   Source: {source_lang}\")\n        print(f\"   Target: {target_lang}\")\n        print(f\"   Text: '{text}'\")\n        \n        client = translate.Client()\n        \n        # GOOGLE TTS: Direct translation\n        result = client.translate(\n            text, \n            source_language=source_lang, \n            target_language=target_lang,\n            format_='text'\n        )\n        \n        translated_text = result['translatedText']\n        print(f\"‚úÖ Translation successful: '{translated_text}'\")\n        \n        return translated_text.strip()\n        \n    except Exception as e:\n        print(f\"‚ùå Translation error: {e}\")\n        return text\n\nclass StandaloneApplication(gunicorn.app.base.BaseApplication):\n    def __init__(self, app, options=None):\n        self.options = options or {}\n        self.application = app\n        super().__init__()\n    \n    def load_config(self):\n        config = {key: value for key, value in self.options.items()\n                 if key in self.cfg.settings and value is not None}\n        for key, value in config.items():\n            self.cfg.set(key.lower(), value)\n    \n    def load(self):\n        return self.application\n\nif __name__ == \"__main__\":\n    port = int(os.environ.get('PORT', 3000))\n    print(f\"üöÄ GOOGLE TTS TRANSLATOR on port {port}\")\n    print(\"=\"*50)\n    print(\"‚úÖ Features:\")\n    print(\"   ‚úì Google Cloud Text-to-Speech API\")\n    print(\"   ‚úì High quality voice output\")\n    print(\"   ‚úì Natural Hindi and English voices\")\n    print(\"   ‚úì Direct translation without repetition\")\n    print(\"   ‚úì Hindi ‚Üî English translation\")\n    print(\"   ‚úì Will definitely work with better quality\")\n    print(f\"   ‚úì Google Cloud: {GOOGLE_CLOUD_AVAILABLE}\")\n    print(f\"   ‚úì Credentials: {credentials_setup}\")\n    print(\"=\"*50)\n    \n    options = {\n        'bind': f'0.0.0.0:{port}',\n        'workers': 1,\n        'worker_class': 'sync',\n        'timeout': 60,\n        'keepalive': 5,\n    }\n    \n    StandaloneApplication(app, options).run()\n","size_bytes":16870},"text_to_speech.py":{"content":"import os\nfrom google.cloud import speech\nfrom google.cloud import texttospeech\nfrom google.cloud import translate_v2 as translate\nimport pyaudio\nimport wave\n\n# Set Google Cloud credentials\nos.environ[\"GOOGLE_APPLICATION_CREDENTIALS\"] = \"google-credentials.json\"\n\n# Step 1: Speech-to-Text (English)\ndef transcribe_speech():\n    try:\n        client = speech.SpeechClient()\n        \n        # Record audio (5 seconds, adjustable)\n        FORMAT = pyaudio.paInt16\n        CHANNELS = 1\n        RATE = 16000\n        CHUNK = 1024\n        RECORD_SECONDS = 5\n        WAVE_OUTPUT_FILENAME = \"input.wav\"\n\n        audio = pyaudio.PyAudio()\n        stream = audio.open(format=FORMAT, channels=CHANNELS, rate=RATE, input=True, frames_per_buffer=CHUNK)\n        print(\"Recording English speech... (Speak now)\")\n        frames = []\n        for _ in range(0, int(RATE / CHUNK * RECORD_SECONDS)):\n            data = stream.read(CHUNK, exception_on_overflow=False)\n            frames.append(data)\n        print(\"Recording complete.\")\n        stream.stop_stream()\n        stream.close()\n        audio.terminate()\n\n        # Save audio to WAV file\n        wf = wave.open(WAVE_OUTPUT_FILENAME, 'wb')\n        wf.setnchannels(CHANNELS)\n        wf.setsampwidth(audio.get_sample_size(FORMAT))\n        wf.setframerate(RATE)\n        wf.writeframes(b''.join(frames))\n        wf.close()\n\n        # Transcribe audio\n        with open(WAVE_OUTPUT_FILENAME, 'rb') as audio_file:\n            content = audio_file.read()\n\n        audio = speech.RecognitionAudio(content=content)\n        config = speech.RecognitionConfig(\n            encoding=speech.RecognitionConfig.AudioEncoding.LINEAR16,\n            sample_rate_hertz=RATE,\n            language_code=\"en-US\"\n        )\n\n        response = client.recognize(config=config, audio=audio)\n        english_text = \"\"\n        for result in response.results:\n            english_text += result.alternatives[0].transcript\n        if not english_text:\n            print(\"No speech detected.\")\n            return None\n        print(\"English Text:\", english_text)\n        return english_text\n    except Exception as e:\n        print(f\"Speech-to-Text error: {e}\")\n        return None\n\n# Step 2: Translate English to Hindi\ndef translate_text(english_text):\n    try:\n        client = translate.Client()\n        result = client.translate(english_text, source_language='en', target_language='hi')\n        hindi_text = result['translatedText']\n        print(\"Hindi Text:\", hindi_text)\n        return hindi_text\n    except Exception as e:\n        print(f\"Translation error: {e}\")\n        return None\n\n# Step 3: Text-to-Speech (Hindi)\ndef synthesize_speech(hindi_text):\n    try:\n        client = texttospeech.TextToSpeechClient()\n        \n        synthesis_input = texttospeech.SynthesisInput(text=hindi_text)\n        voice = texttospeech.VoiceSelectionParams(\n            language_code=\"hi-IN\",\n            name=\"hi-IN-Standard-A\"  # Hindi female voice\n        )\n        audio_config = texttospeech.AudioConfig(\n            audio_encoding=texttospeech.AudioEncoding.MP3\n        )\n\n        response = client.synthesize_speech(\n            input=synthesis_input, voice=voice, audio_config=audio_config\n        )\n\n        with open(\"output.mp3\", \"wb\") as out:\n            out.write(response.audio_content)\n        print(\"Hindi audio saved as output.mp3\")\n\n        # Play the audio (platform-dependent)\n        if os.name == 'nt':  # Windows\n            os.system(\"start output.mp3\")\n        elif os.name == 'posix':  # Linux/macOS\n            os.system(\"mpg123 output.mp3\" if os.uname().sysname == \"Linux\" else \"afplay output.mp3\")\n    except Exception as e:\n        print(f\"Text-to-Speech error: {e}\")\n\n# Main function\ndef main():\n    try:\n        # Verify credentials file exists\n        if not os.path.exists(\"google-credentials.json\"):\n            print(\"Error: google-credentials.json not found in the current directory.\")\n            return\n\n        # Step 1: Convert speech to text\n        english_text = transcribe_speech()\n        if not english_text:\n            return\n\n        # Step 2: Translate to Hindi\n        hindi_text = translate_text(english_text)\n        if not hindi_text:\n            return\n\n        # Step 3: Convert Hindi text to speech\n        synthesize_speech(hindi_text)\n\n    except Exception as e:\n        print(f\"Main error: {e}\")\n\nif __name__ == \"__main__\":\n    main()","size_bytes":4395},"railway_improved_translator.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nRailway Deployment - Improved Voice Translation\nBetter handling of voice recording and transcription\n\"\"\"\n\nimport os\nimport json\nimport time\nimport warnings\nimport requests\nfrom flask import Flask, request, Response\nimport gunicorn.app.base\n\n# Suppress pkg_resources deprecation warnings\nwarnings.filterwarnings(\"ignore\", message=\"pkg_resources is deprecated\")\nwarnings.filterwarnings(\"ignore\", category=UserWarning, module=\"google.cloud.translate_v2\")\n\n# Try to import Google Cloud libraries with error handling\ntry:\n    from google.cloud import speech\n    from google.cloud import texttospeech\n    from google.cloud import translate_v2 as translate\n    GOOGLE_CLOUD_AVAILABLE = True\n    print(\"Google Cloud libraries imported successfully\")\nexcept ImportError as e:\n    print(f\"Google Cloud libraries not available: {e}\")\n    GOOGLE_CLOUD_AVAILABLE = False\n\n# Flask app for HTTP webhooks\napp = Flask(__name__)\n\n@app.route('/health')\ndef health_check():\n    \"\"\"Health check endpoint for Railway\"\"\"\n    status = {\n        \"status\": \"healthy\", \n        \"service\": \"twilio-voice-translator\",\n        \"google_cloud_available\": GOOGLE_CLOUD_AVAILABLE,\n        \"port\": os.environ.get('PORT', 'not_set'),\n        \"timestamp\": time.time(),\n        \"version\": \"7.0-improved-translation\"\n    }\n    return status, 200\n\n@app.route('/')\ndef home():\n    \"\"\"Home endpoint\"\"\"\n    return {\n        \"message\": \"Twilio Voice Translator is running!\",\n        \"health_check\": \"/health\",\n        \"webhook\": \"/twilio-webhook\",\n        \"transcription_webhook\": \"/transcription-webhook\",\n        \"recording_webhook\": \"/recording-webhook\",\n        \"google_cloud_available\": GOOGLE_CLOUD_AVAILABLE,\n        \"version\": \"7.0-improved-translation\",\n        \"features\": [\n            \"Improved voice recording and transcription\",\n            \"Hindi ‚Üî English translation\",\n            \"Google Cloud Speech-to-Text\",\n            \"Google Cloud Text-to-Speech\",\n            \"Google Cloud Translation\",\n            \"Better error handling\"\n        ]\n    }, 200\n\n@app.route('/twilio-webhook', methods=['POST'])\ndef twilio_webhook():\n    \"\"\"Handle incoming Twilio calls\"\"\"\n    call_sid = request.form.get('CallSid')\n    from_number = request.form.get('From')\n    to_number = request.form.get('To')\n    \n    print(f\"Incoming call from {from_number} to {to_number} (CallSid: {call_sid})\")\n    \n    # Get the Railway domain from environment variable\n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    if railway_domain == 'your-railway-app.railway.app':\n        # Fallback to Railway's default domain format\n        railway_domain = os.environ.get('RAILWAY_STATIC_URL', 'web-production-6577e.up.railway.app')\n    \n    # TwiML response with improved recording\n    twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <Response>\n        <Say language=\"hi-IN\">‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡•Ä ‡§Ü‡§µ‡§æ‡§ú‡§º ‡§ï‡§æ ‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§ï‡§∞‡•Ç‡§Ç‡§ó‡§æ‡•§</Say>\n        <Say language=\"en-US\">Hello! I will translate your voice.</Say>\n        <Say language=\"hi-IN\">‡§Ö‡§¨ ‡§Ü‡§™ ‡§¨‡•ã‡§≤ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç‡•§</Say>\n        <Say language=\"en-US\">You can start speaking now.</Say>\n        <Record \n            action=\"https://{railway_domain}/recording-webhook\" \n            method=\"POST\"\n            transcribe=\"true\"\n            transcribeCallback=\"https://{railway_domain}/transcription-webhook\"\n            maxLength=\"15\"\n            timeout=\"10\"\n            playBeep=\"true\"\n            finishOnKey=\"#\"\n            recordingStatusCallback=\"https://{railway_domain}/recording-status\"\n        />\n        <Say language=\"hi-IN\">‡§ß‡§®‡•ç‡§Ø‡§µ‡§æ‡§¶! ‡§Ü‡§™‡§ï‡§æ ‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§§‡•à‡§Ø‡§æ‡§∞ ‡§π‡•à‡•§</Say>\n        <Say language=\"en-US\">Thank you! Your translation is ready.</Say>\n    </Response>\"\"\"\n    \n    return Response(twiml, mimetype='text/xml')\n\n@app.route('/recording-webhook', methods=['POST'])\ndef recording_webhook():\n    \"\"\"Handle recording completion\"\"\"\n    call_sid = request.form.get('CallSid')\n    recording_url = request.form.get('RecordingUrl', '')\n    recording_duration = request.form.get('RecordingDuration', '0')\n    \n    print(f\"Recording completed for call {call_sid}\")\n    print(f\"Recording URL: {recording_url}\")\n    print(f\"Recording Duration: {recording_duration} seconds\")\n    \n    # Get the Railway domain\n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    \n    # TwiML response after recording\n    twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <Response>\n        <Say language=\"hi-IN\">‡§Ü‡§™‡§ï‡•Ä ‡§Ü‡§µ‡§æ‡§ú‡§º ‡§∞‡§ø‡§ï‡•â‡§∞‡•ç‡§° ‡§π‡•ã ‡§ó‡§à ‡§π‡•à‡•§</Say>\n        <Say language=\"en-US\">Your voice has been recorded.</Say>\n        <Say language=\"hi-IN\">‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡•ç‡§∞‡§§‡•Ä‡§ï‡•ç‡§∑‡§æ ‡§ï‡§∞‡•á‡§Ç, ‡§Æ‡•à‡§Ç ‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§ï‡§∞ ‡§∞‡§π‡§æ ‡§π‡•Ç‡§Ç‡•§</Say>\n        <Say language=\"en-US\">Please wait, I am processing your message.</Say>\n        <Pause length=\"3\"/>\n        <Say language=\"hi-IN\">‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§™‡•ç‡§∞‡§ï‡•ç‡§∞‡§ø‡§Ø‡§æ ‡§™‡•Ç‡§∞‡•Ä ‡§π‡•ã ‡§ó‡§à ‡§π‡•à‡•§</Say>\n        <Say language=\"en-US\">Translation process completed.</Say>\n        <Say language=\"hi-IN\">‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™ ‡§ï‡•Å‡§õ ‡§î‡§∞ ‡§ï‡§π‡§®‡§æ ‡§ö‡§æ‡§π‡§§‡•á ‡§π‡•à‡§Ç?</Say>\n        <Say language=\"en-US\">Would you like to say something else?</Say>\n        <Record \n            action=\"https://{railway_domain}/recording-webhook\" \n            method=\"POST\"\n            transcribe=\"true\"\n            transcribeCallback=\"https://{railway_domain}/transcription-webhook\"\n            maxLength=\"15\"\n            timeout=\"10\"\n            playBeep=\"true\"\n            finishOnKey=\"#\"\n        />\n    </Response>\"\"\"\n    \n    return Response(twiml, mimetype='text/xml')\n\n@app.route('/transcription-webhook', methods=['POST'])\ndef transcription_webhook():\n    \"\"\"Handle transcription results and provide translation\"\"\"\n    call_sid = request.form.get('CallSid')\n    transcription_text = request.form.get('TranscriptionText', '')\n    transcription_status = request.form.get('TranscriptionStatus', '')\n    recording_url = request.form.get('RecordingUrl', '')\n    \n    print(f\"Transcription webhook called for call {call_sid}\")\n    print(f\"Transcription Status: {transcription_status}\")\n    print(f\"Transcription Text: {transcription_text}\")\n    print(f\"Recording URL: {recording_url}\")\n    \n    # Get the Railway domain\n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    \n    if transcription_status != 'completed' or not transcription_text:\n        # If transcription failed, try to process the recording directly\n        if recording_url and GOOGLE_CLOUD_AVAILABLE:\n            try:\n                transcription_text = process_recording_directly(recording_url)\n                print(f\"Direct processing result: {transcription_text}\")\n            except Exception as e:\n                print(f\"Direct processing failed: {e}\")\n                transcription_text = \"\"\n    \n    if not transcription_text:\n        # Fallback response if no transcription\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say language=\"hi-IN\">‡§Æ‡•Å‡§ù‡•á ‡§Ü‡§™‡§ï‡•Ä ‡§Ü‡§µ‡§æ‡§ú‡§º ‡§∏‡§Æ‡§ù ‡§®‡§π‡•Ä‡§Ç ‡§Ü‡§à‡•§</Say>\n            <Say language=\"en-US\">I couldn't understand your voice.</Say>\n            <Say language=\"hi-IN\">‡§ï‡•É‡§™‡§Ø‡§æ ‡§´‡§ø‡§∞ ‡§∏‡•á ‡§¨‡•ã‡§≤‡•á‡§Ç‡•§</Say>\n            <Say language=\"en-US\">Please speak again.</Say>\n            <Record \n                action=\"https://{railway_domain}/recording-webhook\" \n                method=\"POST\"\n                transcribe=\"true\"\n                transcribeCallback=\"https://{railway_domain}/transcription-webhook\"\n                maxLength=\"15\"\n                timeout=\"10\"\n                playBeep=\"true\"\n                finishOnKey=\"#\"\n            />\n        </Response>\"\"\"\n        return Response(twiml, mimetype='text/xml')\n    \n    try:\n        # Detect language and translate\n        detected_language = detect_language(transcription_text)\n        \n        if detected_language == \"hi\":\n            # Hindi to English\n            translated_text = translate_text(transcription_text, 'hi', 'en')\n            target_language = \"en-US\"\n            print(f\"Hindi: {transcription_text} ‚Üí English: {translated_text}\")\n        else:\n            # English to Hindi\n            translated_text = translate_text(transcription_text, 'en', 'hi')\n            target_language = \"hi-IN\"\n            print(f\"English: {transcription_text} ‚Üí Hindi: {translated_text}\")\n        \n        # Create TwiML response with translation\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say language=\"en-US\">You said: {transcription_text}</Say>\n            <Say language=\"{target_language}\">Translation: {translated_text}</Say>\n            <Say language=\"hi-IN\">‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™ ‡§ï‡•Å‡§õ ‡§î‡§∞ ‡§ï‡§π‡§®‡§æ ‡§ö‡§æ‡§π‡§§‡•á ‡§π‡•à‡§Ç?</Say>\n            <Say language=\"en-US\">Would you like to say something else?</Say>\n            <Record \n                action=\"https://{railway_domain}/recording-webhook\" \n                method=\"POST\"\n                transcribe=\"true\"\n                transcribeCallback=\"https://{railway_domain}/transcription-webhook\"\n                maxLength=\"15\"\n                timeout=\"10\"\n                playBeep=\"true\"\n                finishOnKey=\"#\"\n            />\n        </Response>\"\"\"\n        \n        return Response(twiml, mimetype='text/xml')\n        \n    except Exception as e:\n        print(f\"Translation error: {e}\")\n        # Error response\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say language=\"hi-IN\">‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§Æ‡•á‡§Ç ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø ‡§π‡•Å‡§à ‡§π‡•à‡•§</Say>\n            <Say language=\"en-US\">There was an error in translation.</Say>\n            <Say language=\"hi-IN\">‡§ï‡•É‡§™‡§Ø‡§æ ‡§´‡§ø‡§∞ ‡§∏‡•á ‡§ï‡•ã‡§∂‡§ø‡§∂ ‡§ï‡§∞‡•á‡§Ç‡•§</Say>\n            <Say language=\"en-US\">Please try again.</Say>\n            <Record \n                action=\"https://{railway_domain}/recording-webhook\" \n                method=\"POST\"\n                transcribe=\"true\"\n                transcribeCallback=\"https://{railway_domain}/transcription-webhook\"\n                maxLength=\"15\"\n                timeout=\"10\"\n                playBeep=\"true\"\n                finishOnKey=\"#\"\n            />\n        </Response>\"\"\"\n        return Response(twiml, mimetype='text/xml')\n\n@app.route('/recording-status', methods=['POST'])\ndef recording_status():\n    \"\"\"Handle recording status updates\"\"\"\n    call_sid = request.form.get('CallSid')\n    recording_status = request.form.get('RecordingStatus', '')\n    recording_url = request.form.get('RecordingUrl', '')\n    \n    print(f\"Recording status for call {call_sid}: {recording_status}\")\n    if recording_url:\n        print(f\"Recording URL: {recording_url}\")\n    \n    return Response('OK', mimetype='text/plain')\n\ndef detect_language(text):\n    \"\"\"Simple language detection\"\"\"\n    # Simple heuristic: if text contains Devanagari characters, it's Hindi\n    devanagari_chars = set('‡§Ö‡§Ü‡§á‡§à‡§â‡§ä‡§ã‡§è‡§ê‡§ì‡§î‡§ï‡§ñ‡§ó‡§ò‡§ô‡§ö‡§õ‡§ú‡§ù‡§û‡§ü‡§†‡§°‡§¢‡§£‡§§‡§•‡§¶‡§ß‡§®‡§™‡§´‡§¨‡§≠‡§Æ‡§Ø‡§∞‡§≤‡§µ‡§∂‡§∑‡§∏‡§π')\n    if any(char in devanagari_chars for char in text):\n        return \"hi\"\n    return \"en\"\n\ndef translate_text(text, source_lang, target_lang):\n    \"\"\"Translate text using Google Cloud Translation\"\"\"\n    try:\n        client = translate.Client()\n        result = client.translate(text, source_language=source_lang, target_language=target_lang)\n        return result['translatedText']\n    except Exception as e:\n        print(f\"Translation error: {e}\")\n        return text  # Return original text if translation fails\n\ndef process_recording_directly(recording_url):\n    \"\"\"Process recording directly using Google Cloud Speech-to-Text\"\"\"\n    try:\n        # Download the recording\n        response = requests.get(recording_url, timeout=30)\n        if response.status_code != 200:\n            print(f\"Failed to download recording: {response.status_code}\")\n            return \"\"\n        \n        audio_content = response.content\n        \n        # Initialize Speech-to-Text client\n        client = speech.SpeechClient()\n        \n        # Configure recognition\n        config = speech.RecognitionConfig(\n            encoding=speech.RecognitionConfig.AudioEncoding.MULAW,\n            sample_rate_hertz=8000,\n            language_code=\"hi-IN\",\n            alternative_language_codes=[\"en-US\"],\n            enable_automatic_punctuation=True,\n            model=\"latest_long\"\n        )\n        \n        audio = speech.RecognitionAudio(content=audio_content)\n        \n        # Perform recognition\n        response = client.recognize(config=config, audio=audio)\n        \n        if response.results:\n            result = response.results[0]\n            if result.is_final:\n                transcript = result.alternatives[0].transcript\n                confidence = result.alternatives[0].confidence\n                print(f\"Direct processing confidence: {confidence}\")\n                if confidence > 0.5:\n                    return transcript\n        \n        return \"\"\n        \n    except Exception as e:\n        print(f\"Direct processing error: {e}\")\n        return \"\"\n\n@app.route('/call-status', methods=['POST'])\ndef call_status():\n    \"\"\"Handle call status updates\"\"\"\n    call_sid = request.form.get('CallSid')\n    call_status = request.form.get('CallStatus')\n    \n    print(f\"Call {call_sid} status: {call_status}\")\n    \n    return Response('OK', mimetype='text/plain')\n\nclass StandaloneApplication(gunicorn.app.base.BaseApplication):\n    \"\"\"Gunicorn application for Railway deployment\"\"\"\n    \n    def __init__(self, app, options=None):\n        self.options = options or {}\n        self.application = app\n        super().__init__()\n    \n    def load_config(self):\n        config = {key: value for key, value in self.options.items()\n                 if key in self.cfg.settings and value is not None}\n        for key, value in config.items():\n            self.cfg.set(key.lower(), value)\n    \n    def load(self):\n        return self.application\n\nif __name__ == \"__main__\":\n    try:\n        # Get port from Railway environment variable\n        port = int(os.environ.get('PORT', 3000))\n        print(f\"Starting Railway deployment on port {port}\")\n        print(\"=\"*70)\n        print(\"RAILWAY TWILIO VOICE TRANSLATOR - IMPROVED TRANSLATION\")\n        print(\"=\"*70)\n        print(\"Features:\")\n        print(\"‚úì Improved voice recording and transcription\")\n        print(\"‚úì Hindi ‚Üî English translation\")\n        print(\"‚úì Google Cloud Speech-to-Text\")\n        print(\"‚úì Google Cloud Text-to-Speech\")\n        print(\"‚úì Google Cloud Translation\")\n        print(\"‚úì Railway cloud deployment\")\n        print(\"‚úì Better error handling\")\n        print(\"‚úì Direct recording processing fallback\")\n        print(f\"‚úì Google Cloud available: {GOOGLE_CLOUD_AVAILABLE}\")\n        print(f\"‚úì Port: {port}\")\n        print(\"=\"*70)\n        \n        if not GOOGLE_CLOUD_AVAILABLE:\n            print(\"WARNING: Google Cloud libraries not available!\")\n            print(\"Please check your GOOGLE_APPLICATION_CREDENTIALS environment variable\")\n        \n        # Start Flask app with Gunicorn\n        options = {\n            'bind': f'0.0.0.0:{port}',\n            'workers': 1,\n            'worker_class': 'sync',\n            'worker_connections': 1000,\n            'timeout': 30,\n            'keepalive': 2,\n            'max_requests': 1000,\n            'max_requests_jitter': 100,\n            'preload_app': True,\n        }\n        \n        StandaloneApplication(app, options).run()\n        \n    except KeyboardInterrupt:\n        print(\"Server stopped by user.\")\n    except Exception as e:\n        print(f\"Server startup error: {e}\")\n        import traceback\n        traceback.print_exc()\n","size_bytes":16043},"railway_debug_translator.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nRailway Deployment - Debug Voice Translation\nFixed transcription webhook handling\n\"\"\"\n\nimport os\nimport json\nimport time\nimport warnings\nimport requests\nfrom flask import Flask, request, Response\nimport gunicorn.app.base\n\n# Suppress pkg_resources deprecation warnings\nwarnings.filterwarnings(\"ignore\", message=\"pkg_resources is deprecated\")\nwarnings.filterwarnings(\"ignore\", category=UserWarning, module=\"google.cloud.translate_v2\")\n\n# Try to import Google Cloud libraries with error handling\ntry:\n    from google.cloud import speech\n    from google.cloud import texttospeech\n    from google.cloud import translate_v2 as translate\n    GOOGLE_CLOUD_AVAILABLE = True\n    print(\"Google Cloud libraries imported successfully\")\nexcept ImportError as e:\n    print(f\"Google Cloud libraries not available: {e}\")\n    GOOGLE_CLOUD_AVAILABLE = False\n\n# Flask app for HTTP webhooks\napp = Flask(__name__)\n\n@app.route('/health')\ndef health_check():\n    \"\"\"Health check endpoint for Railway\"\"\"\n    status = {\n        \"status\": \"healthy\", \n        \"service\": \"twilio-voice-translator\",\n        \"google_cloud_available\": GOOGLE_CLOUD_AVAILABLE,\n        \"port\": os.environ.get('PORT', 'not_set'),\n        \"timestamp\": time.time(),\n        \"version\": \"10.0-debug-translation\"\n    }\n    return status, 200\n\n@app.route('/')\ndef home():\n    \"\"\"Home endpoint\"\"\"\n    return {\n        \"message\": \"Twilio Voice Translator is running!\",\n        \"health_check\": \"/health\",\n        \"webhook\": \"/twilio-webhook\",\n        \"transcription_webhook\": \"/transcription-webhook\",\n        \"recording_webhook\": \"/recording-webhook\",\n        \"google_cloud_available\": GOOGLE_CLOUD_AVAILABLE,\n        \"version\": \"10.0-debug-translation\",\n        \"features\": [\n            \"Fixed transcription webhook handling\",\n            \"Hindi ‚Üî English translation\",\n            \"Google Cloud Speech-to-Text\",\n            \"Google Cloud Translation\",\n            \"Proper language voice selection\"\n        ]\n    }, 200\n\n@app.route('/twilio-webhook', methods=['POST'])\ndef twilio_webhook():\n    \"\"\"Handle incoming Twilio calls\"\"\"\n    call_sid = request.form.get('CallSid')\n    from_number = request.form.get('From')\n    to_number = request.form.get('To')\n    \n    print(f\"Incoming call from {from_number} to {to_number} (CallSid: {call_sid})\")\n    \n    # Get the Railway domain from environment variable\n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    if railway_domain == 'your-railway-app.railway.app':\n        # Fallback to Railway's default domain format\n        railway_domain = os.environ.get('RAILWAY_STATIC_URL', 'web-production-6577e.up.railway.app')\n    \n    # TwiML response with improved recording - use transcription webhook as action\n    twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <Response>\n        <Say voice=\"alice\" language=\"hi-IN\">‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡•Ä ‡§Ü‡§µ‡§æ‡§ú‡§º ‡§ï‡§æ ‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§ï‡§∞‡•Ç‡§Ç‡§ó‡§æ‡•§</Say>\n        <Say voice=\"alice\" language=\"en-US\">Hello! I will translate your voice.</Say>\n        <Say voice=\"alice\" language=\"hi-IN\">‡§Ö‡§¨ ‡§Ü‡§™ ‡§¨‡•ã‡§≤ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç‡•§</Say>\n        <Say voice=\"alice\" language=\"en-US\">You can start speaking now.</Say>\n        <Record \n            action=\"https://{railway_domain}/transcription-webhook\" \n            method=\"POST\"\n            transcribe=\"true\"\n            transcribeCallback=\"https://{railway_domain}/transcription-webhook\"\n            maxLength=\"15\"\n            timeout=\"10\"\n            playBeep=\"true\"\n            finishOnKey=\"#\"\n            recordingStatusCallback=\"https://{railway_domain}/recording-status\"\n        />\n        <Say voice=\"alice\" language=\"hi-IN\">‡§ß‡§®‡•ç‡§Ø‡§µ‡§æ‡§¶! ‡§Ü‡§™‡§ï‡§æ ‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§§‡•à‡§Ø‡§æ‡§∞ ‡§π‡•à‡•§</Say>\n        <Say voice=\"alice\" language=\"en-US\">Thank you! Your translation is ready.</Say>\n    </Response>\"\"\"\n    \n    return Response(twiml, mimetype='text/xml')\n\n@app.route('/transcription-webhook', methods=['POST'])\ndef transcription_webhook():\n    \"\"\"Handle transcription results and provide translation\"\"\"\n    call_sid = request.form.get('CallSid')\n    transcription_text = request.form.get('TranscriptionText', '')\n    transcription_status = request.form.get('TranscriptionStatus', '')\n    recording_url = request.form.get('RecordingUrl', '')\n    recording_duration = request.form.get('RecordingDuration', '0')\n    \n    print(f\"Transcription webhook called for call {call_sid}\")\n    print(f\"Transcription Status: {transcription_status}\")\n    print(f\"Transcription Text: {transcription_text}\")\n    print(f\"Recording URL: {recording_url}\")\n    print(f\"Recording Duration: {recording_duration}\")\n    \n    # Get the Railway domain\n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    \n    # If no transcription text, try to process the recording directly\n    if not transcription_text and recording_url and GOOGLE_CLOUD_AVAILABLE:\n        try:\n            print(\"Attempting direct recording processing...\")\n            transcription_text = process_recording_directly(recording_url)\n            print(f\"Direct processing result: {transcription_text}\")\n        except Exception as e:\n            print(f\"Direct processing failed: {e}\")\n            transcription_text = \"\"\n    \n    if not transcription_text:\n        # Fallback response if no transcription\n        print(\"No transcription available, providing fallback response\")\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"hi-IN\">‡§Æ‡•Å‡§ù‡•á ‡§Ü‡§™‡§ï‡•Ä ‡§Ü‡§µ‡§æ‡§ú‡§º ‡§∏‡§Æ‡§ù ‡§®‡§π‡•Ä‡§Ç ‡§Ü‡§à‡•§</Say>\n            <Say voice=\"alice\" language=\"en-US\">I couldn't understand your voice.</Say>\n            <Say voice=\"alice\" language=\"hi-IN\">‡§ï‡•É‡§™‡§Ø‡§æ ‡§´‡§ø‡§∞ ‡§∏‡•á ‡§¨‡•ã‡§≤‡•á‡§Ç‡•§</Say>\n            <Say voice=\"alice\" language=\"en-US\">Please speak again.</Say>\n            <Record \n                action=\"https://{railway_domain}/transcription-webhook\" \n                method=\"POST\"\n                transcribe=\"true\"\n                transcribeCallback=\"https://{railway_domain}/transcription-webhook\"\n                maxLength=\"15\"\n                timeout=\"10\"\n                playBeep=\"true\"\n                finishOnKey=\"#\"\n            />\n        </Response>\"\"\"\n        return Response(twiml, mimetype='text/xml')\n    \n    try:\n        # Detect language and translate\n        detected_language = detect_language(transcription_text)\n        print(f\"Detected language: {detected_language}\")\n        \n        if detected_language == \"hi\":\n            # Hindi to English\n            translated_text = translate_text(transcription_text, 'hi', 'en')\n            target_language = \"en-US\"\n            target_voice = \"alice\"\n            print(f\"Hindi: {transcription_text} ‚Üí English: {translated_text}\")\n        else:\n            # English to Hindi\n            translated_text = translate_text(transcription_text, 'en', 'hi')\n            target_language = \"hi-IN\"\n            target_voice = \"alice\"\n            print(f\"English: {transcription_text} ‚Üí Hindi: {translated_text}\")\n        \n        # Create TwiML response with proper voice and language\n        print(\"Creating TwiML response with translation\")\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"en-US\">You said: {transcription_text}</Say>\n            <Say voice=\"{target_voice}\" language=\"{target_language}\">Translation: {translated_text}</Say>\n            <Say voice=\"alice\" language=\"hi-IN\">‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™ ‡§ï‡•Å‡§õ ‡§î‡§∞ ‡§ï‡§π‡§®‡§æ ‡§ö‡§æ‡§π‡§§‡•á ‡§π‡•à‡§Ç?</Say>\n            <Say voice=\"alice\" language=\"en-US\">Would you like to say something else?</Say>\n            <Record \n                action=\"https://{railway_domain}/transcription-webhook\" \n                method=\"POST\"\n                transcribe=\"true\"\n                transcribeCallback=\"https://{railway_domain}/transcription-webhook\"\n                maxLength=\"15\"\n                timeout=\"10\"\n                playBeep=\"true\"\n                finishOnKey=\"#\"\n            />\n        </Response>\"\"\"\n        \n        return Response(twiml, mimetype='text/xml')\n        \n    except Exception as e:\n        print(f\"Translation error: {e}\")\n        # Error response\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"hi-IN\">‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§Æ‡•á‡§Ç ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø ‡§π‡•Å‡§à ‡§π‡•à‡•§</Say>\n            <Say voice=\"alice\" language=\"en-US\">There was an error in translation.</Say>\n            <Say voice=\"alice\" language=\"hi-IN\">‡§ï‡•É‡§™‡§Ø‡§æ ‡§´‡§ø‡§∞ ‡§∏‡•á ‡§ï‡•ã‡§∂‡§ø‡§∂ ‡§ï‡§∞‡•á‡§Ç‡•§</Say>\n            <Say voice=\"alice\" language=\"en-US\">Please try again.</Say>\n            <Record \n                action=\"https://{railway_domain}/transcription-webhook\" \n                method=\"POST\"\n                transcribe=\"true\"\n                transcribeCallback=\"https://{railway_domain}/transcription-webhook\"\n                maxLength=\"15\"\n                timeout=\"10\"\n                playBeep=\"true\"\n                finishOnKey=\"#\"\n            />\n        </Response>\"\"\"\n        return Response(twiml, mimetype='text/xml')\n\n@app.route('/recording-webhook', methods=['POST'])\ndef recording_webhook():\n    \"\"\"Handle recording completion (fallback)\"\"\"\n    call_sid = request.form.get('CallSid')\n    recording_url = request.form.get('RecordingUrl', '')\n    recording_duration = request.form.get('RecordingDuration', '0')\n    \n    print(f\"Recording webhook called for call {call_sid}\")\n    print(f\"Recording URL: {recording_url}\")\n    print(f\"Recording Duration: {recording_duration} seconds\")\n    \n    # Redirect to transcription webhook\n    return transcription_webhook()\n\n@app.route('/recording-status', methods=['POST'])\ndef recording_status():\n    \"\"\"Handle recording status updates\"\"\"\n    call_sid = request.form.get('CallSid')\n    recording_status = request.form.get('RecordingStatus', '')\n    recording_url = request.form.get('RecordingUrl', '')\n    \n    print(f\"Recording status for call {call_sid}: {recording_status}\")\n    if recording_url:\n        print(f\"Recording URL: {recording_url}\")\n    \n    return Response('OK', mimetype='text/plain')\n\ndef detect_language(text):\n    \"\"\"Simple language detection\"\"\"\n    # Simple heuristic: if text contains Devanagari characters, it's Hindi\n    devanagari_chars = set('‡§Ö‡§Ü‡§á‡§à‡§â‡§ä‡§ã‡§è‡§ê‡§ì‡§î‡§ï‡§ñ‡§ó‡§ò‡§ô‡§ö‡§õ‡§ú‡§ù‡§û‡§ü‡§†‡§°‡§¢‡§£‡§§‡§•‡§¶‡§ß‡§®‡§™‡§´‡§¨‡§≠‡§Æ‡§Ø‡§∞‡§≤‡§µ‡§∂‡§∑‡§∏‡§π')\n    if any(char in devanagari_chars for char in text):\n        return \"hi\"\n    return \"en\"\n\ndef translate_text(text, source_lang, target_lang):\n    \"\"\"Translate text using Google Cloud Translation\"\"\"\n    try:\n        client = translate.Client()\n        result = client.translate(text, source_language=source_lang, target_language=target_lang)\n        return result['translatedText']\n    except Exception as e:\n        print(f\"Translation error: {e}\")\n        return text  # Return original text if translation fails\n\ndef process_recording_directly(recording_url):\n    \"\"\"Process recording directly using Google Cloud Speech-to-Text\"\"\"\n    try:\n        print(f\"Downloading recording from: {recording_url}\")\n        # Download the recording\n        response = requests.get(recording_url, timeout=30)\n        if response.status_code != 200:\n            print(f\"Failed to download recording: {response.status_code}\")\n            return \"\"\n        \n        audio_content = response.content\n        print(f\"Downloaded {len(audio_content)} bytes of audio\")\n        \n        # Initialize Speech-to-Text client\n        client = speech.SpeechClient()\n        \n        # Configure recognition\n        config = speech.RecognitionConfig(\n            encoding=speech.RecognitionConfig.AudioEncoding.MULAW,\n            sample_rate_hertz=8000,\n            language_code=\"hi-IN\",\n            alternative_language_codes=[\"en-US\"],\n            enable_automatic_punctuation=True,\n            model=\"latest_long\"\n        )\n        \n        audio = speech.RecognitionAudio(content=audio_content)\n        \n        # Perform recognition\n        print(\"Performing speech recognition...\")\n        response = client.recognize(config=config, audio=audio)\n        \n        if response.results:\n            result = response.results[0]\n            if result.is_final:\n                transcript = result.alternatives[0].transcript\n                confidence = result.alternatives[0].confidence\n                print(f\"Direct processing confidence: {confidence}\")\n                if confidence > 0.5:\n                    return transcript\n        \n        return \"\"\n        \n    except Exception as e:\n        print(f\"Direct processing error: {e}\")\n        return \"\"\n\n@app.route('/call-status', methods=['POST'])\ndef call_status():\n    \"\"\"Handle call status updates\"\"\"\n    call_sid = request.form.get('CallSid')\n    call_status = request.form.get('CallStatus')\n    \n    print(f\"Call {call_sid} status: {call_status}\")\n    \n    return Response('OK', mimetype='text/plain')\n\nclass StandaloneApplication(gunicorn.app.base.BaseApplication):\n    \"\"\"Gunicorn application for Railway deployment\"\"\"\n    \n    def __init__(self, app, options=None):\n        self.options = options or {}\n        self.application = app\n        super().__init__()\n    \n    def load_config(self):\n        config = {key: value for key, value in self.options.items()\n                 if key in self.cfg.settings and value is not None}\n        for key, value in config.items():\n            self.cfg.set(key.lower(), value)\n    \n    def load(self):\n        return self.application\n\nif __name__ == \"__main__\":\n    try:\n        # Get port from Railway environment variable\n        port = int(os.environ.get('PORT', 3000))\n        print(f\"Starting Railway deployment on port {port}\")\n        print(\"=\"*70)\n        print(\"RAILWAY TWILIO VOICE TRANSLATOR - DEBUG TRANSLATION\")\n        print(\"=\"*70)\n        print(\"Features:\")\n        print(\"‚úì Fixed transcription webhook handling\")\n        print(\"‚úì Hindi ‚Üî English translation\")\n        print(\"‚úì Google Cloud Speech-to-Text\")\n        print(\"‚úì Google Cloud Translation\")\n        print(\"‚úì Proper language voice selection\")\n        print(\"‚úì Railway cloud deployment\")\n        print(\"‚úì Better error handling\")\n        print(\"‚úì Direct recording processing fallback\")\n        print(\"‚úì Enhanced logging for debugging\")\n        print(f\"‚úì Google Cloud available: {GOOGLE_CLOUD_AVAILABLE}\")\n        print(f\"‚úì Port: {port}\")\n        print(\"=\"*70)\n        \n        if not GOOGLE_CLOUD_AVAILABLE:\n            print(\"WARNING: Google Cloud libraries not available!\")\n            print(\"Please check your GOOGLE_APPLICATION_CREDENTIALS environment variable\")\n        \n        # Start Flask app with Gunicorn\n        options = {\n            'bind': f'0.0.0.0:{port}',\n            'workers': 1,\n            'worker_class': 'sync',\n            'worker_connections': 1000,\n            'timeout': 30,\n            'keepalive': 2,\n            'max_requests': 1000,\n            'max_requests_jitter': 100,\n            'preload_app': True,\n        }\n        \n        StandaloneApplication(app, options).run()\n        \n    except KeyboardInterrupt:\n        print(\"Server stopped by user.\")\n    except Exception as e:\n        print(f\"Server startup error: {e}\")\n        import traceback\n        traceback.print_exc()\n","size_bytes":15534},"script.py":{"content":"import os\nimport pyaudio\nimport queue\nimport threading\nimport time\nfrom google.cloud import speech\nfrom google.cloud import texttospeech\nfrom google.cloud import translate_v2 as translate\n\n# Set Google Cloud credentials\nos.environ[\"GOOGLE_APPLICATION_CREDENTIALS\"] = \"google-credentials.json\"\n\n# Audio stream parameters\nFORMAT = pyaudio.paInt16\nCHANNELS = 1\nRATE = 16000\nCHUNK = 1024  # Smaller chunk size for lower latency\n\n# Queues for passing transcriptions and translations between threads\ntranscript_queue = queue.Queue()\ntranslation_queue = queue.Queue()\n\n# Flag to control the streaming loop\nrunning = True\n\n# Set to keep track of processed transcripts to avoid duplicates\nprocessed_transcripts = set()\n\ndef stream_audio_to_transcript():\n    \"\"\"Stream audio from microphone and send to Google Cloud for transcription.\"\"\"\n    global running\n    try:\n        client = speech.SpeechClient()\n        config = speech.RecognitionConfig(\n            encoding=speech.RecognitionConfig.AudioEncoding.LINEAR16,\n            sample_rate_hertz=RATE,\n            language_code=\"en-US\",\n            enable_automatic_punctuation=True\n        )\n        streaming_config = speech.StreamingRecognitionConfig(\n            config=config,\n            interim_results=False  # Disable interim results to reduce duplicates\n        )\n\n        audio = pyaudio.PyAudio()\n        stream = audio.open(format=FORMAT, channels=CHANNELS, rate=RATE, input=True, frames_per_buffer=CHUNK)\n        print(\"Listening for English speech...\")\n\n        requests = (\n            speech.StreamingRecognizeRequest(audio_content=chunk)\n            for chunk in iter(lambda: stream.read(CHUNK, exception_on_overflow=False), b\"\")\n        )\n\n        responses = client.streaming_recognize(streaming_config, requests)\n\n        for response in responses:\n            if not running:\n                break\n            for result in response.results:\n                if result.is_final:  # Only process final results\n                    transcript = result.alternatives[0].transcript.strip()\n                    # Check if transcript is new and non-empty\n                    if transcript and transcript not in processed_transcripts:\n                        print(f\"English Text: {transcript}\")\n                        processed_transcripts.add(transcript)\n                        transcript_queue.put(transcript)\n\n        stream.stop_stream()\n        stream.close()\n        audio.terminate()\n    except Exception as e:\n        print(f\"Streaming transcription error: {e}\")\n        running = False\n\ndef translate_transcripts():\n    \"\"\"Translate English transcripts to Hindi in real-time.\"\"\"\n    global running\n    try:\n        client = translate.Client()\n        while running:\n            try:\n                # Get transcript from queue (non-blocking)\n                transcript = transcript_queue.get(timeout=1)\n                result = client.translate(transcript, source_language='en', target_language='hi')\n                hindi_text = result['translatedText']\n                print(f\"Hindi Text: {hindi_text}\")\n                translation_queue.put(hindi_text)\n                transcript_queue.task_done()\n            except queue.Empty:\n                continue\n            except Exception as e:\n                print(f\"Translation error: {e}\")\n    except Exception as e:\n        print(f\"Translator thread error: {e}\")\n        running = False\n\ndef synthesize_and_play():\n    \"\"\"Convert Hindi text to speech and play it in real-time.\"\"\"\n    global running\n    try:\n        client = texttospeech.TextToSpeechClient()\n        p = pyaudio.PyAudio()\n        stream = p.open(format=pyaudio.paInt16, channels=1, rate=16000, output=True)\n\n        while running:\n            try:\n                # Get Hindi text from queue (non-blocking)\n                hindi_text = translation_queue.get(timeout=1)\n                synthesis_input = texttospeech.SynthesisInput(text=hindi_text)\n                voice = texttospeech.VoiceSelectionParams(\n                    language_code=\"hi-IN\",\n                    name=\"hi-IN-Standard-A\"  # Hindi female voice\n                )\n                audio_config = texttospeech.AudioConfig(\n                    audio_encoding=texttospeech.AudioEncoding.LINEAR16,\n                    sample_rate_hertz=16000\n                )\n\n                response = client.synthesize_speech(\n                    input=synthesis_input, voice=voice, audio_config=audio_config\n                )\n\n                print(\"Playing Hindi speech...\")\n                stream.write(response.audio_content)\n                translation_queue.task_done()\n            except queue.Empty:\n                continue\n            except Exception as e:\n                print(f\"Text-to-Speech error: {e}\")\n\n        stream.stop_stream()\n        stream.close()\n        p.terminate()\n    except Exception as e:\n        print(f\"Synthesis thread error: {e}\")\n        running = False\n\ndef main():\n    global running\n    try:\n        # Verify credentials file\n        if not os.path.exists(\"google-credentials.json\"):\n            print(\"Error: google-credentials.json not found in the current directory.\")\n            return False\n\n        # Start threads for streaming transcription, translation, and synthesis\n        transcription_thread = threading.Thread(target=stream_audio_to_transcript)\n        translation_thread = threading.Thread(target=translate_transcripts)\n        synthesis_thread = threading.Thread(target=synthesize_and_play)\n\n        transcription_thread.start()\n        translation_thread.start()\n        synthesis_thread.start()\n\n        # Wait for threads to complete\n        transcription_thread.join()\n        translation_thread.join()\n        synthesis_thread.join()\n\n        return True\n    except Exception as e:\n        print(f\"Main error: {e}\")\n        running = False\n        return True\n\nif __name__ == \"__main__\":\n    print(\"Starting real-time translator. Press Ctrl+C to abort.\")\n    try:\n        if not main():\n            print(\"Program terminated due to missing credentials.\")\n    except KeyboardInterrupt:\n        print(\"\\nProgram aborted by user.\")\n        running = False\n    except Exception as e:\n        print(f\"Unexpected error: {e}\")\n        running = False","size_bytes":6245},"railway_improved_final.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nRailway Deployment - IMPROVED FINAL Voice Translator\nFIXED: Complete translation, smooth speech output, better audio handling\n\"\"\"\n\nimport os\nimport json\nimport time\nimport warnings\nimport requests\nfrom flask import Flask, request, Response\nimport gunicorn.app.base\n\n# Suppress warnings\nwarnings.filterwarnings(\"ignore\")\n\n# Set up Google Cloud credentials\ndef setup_google_credentials():\n    try:\n        creds_json = os.environ.get('GOOGLE_CREDENTIALS_JSON')\n        if creds_json:\n            creds_data = json.loads(creds_json)\n            temp_creds_path = '/tmp/google-credentials.json'\n            with open(temp_creds_path, 'w') as f:\n                json.dump(creds_data, f)\n            os.environ['GOOGLE_APPLICATION_CREDENTIALS'] = temp_creds_path\n            print(\"‚úÖ Google credentials set up\")\n            return True\n        return False\n    except Exception as e:\n        print(f\"‚ùå Credentials error: {e}\")\n        return False\n\ncredentials_setup = setup_google_credentials()\n\n# Import Google Cloud\ntry:\n    from google.cloud import translate_v2 as translate\n    GOOGLE_CLOUD_AVAILABLE = True\n    print(\"‚úÖ Google Cloud available\")\nexcept ImportError:\n    GOOGLE_CLOUD_AVAILABLE = False\n    print(\"‚ùå Google Cloud not available\")\n\napp = Flask(__name__)\n\n@app.route('/health')\ndef health_check():\n    return {\n        \"status\": \"healthy\",\n        \"google_cloud_available\": GOOGLE_CLOUD_AVAILABLE,\n        \"credentials_setup\": credentials_setup,\n        \"version\": \"20.0-improved-final\"\n    }, 200\n\n@app.route('/')\ndef home():\n    return {\n        \"message\": \"IMPROVED FINAL Twilio Voice Translator\",\n        \"webhook\": \"/twilio-webhook\",\n        \"version\": \"20.0-improved-final\"\n    }, 200\n\n@app.route('/twilio-webhook', methods=['POST'])\ndef twilio_webhook():\n    call_sid = request.form.get('CallSid')\n    from_number = request.form.get('From')\n    \n    print(f\"\\nüìû CALL FROM: {from_number}\")\n    print(f\"   CallSid: {call_sid}\")\n    print(\"=\"*40)\n    \n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    \n    # IMPROVED: Better speech recognition with longer timeout\n    twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <Response>\n        <Say voice=\"alice\" language=\"en-US\">Hello! I will translate between Hindi and English. Please speak clearly and wait for the translation.</Say>\n        <Pause length=\"2\"/>\n        <Gather \n            action=\"https://{railway_domain}/gather-webhook\" \n            method=\"POST\"\n            input=\"speech\"\n            speechTimeout=\"auto\"\n            timeout=\"30\"\n            language=\"en-US\"\n            hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida, main theek hun, aap kaise hain, kya haal hai, shukriya, namaskar, pranam, aapka swagat hai, main aap se mil kar khush hun, aap kahan se hain, main ghar ja raha hun, main office ja raha hun, main school ja raha hun, main market ja raha hun, main doctor ke paas ja raha hun, main hospital ja raha hun, main bank ja raha hun, main restaurant ja raha hun, main hotel ja raha hun, main station ja raha hun, main airport ja raha hun, main bus stand ja raha hun, main railway station ja raha hun, main metro station ja raha hun, main shopping mall ja raha hun, main cinema hall ja raha hun, main park ja raha hun, main temple ja raha hun, main mosque ja raha hun, main church ja raha hun, main gurudwara ja raha hun, main mandir ja raha hun, main masjid ja raha hun, main girja ja raha hun, main gurdwara ja raha hun, main khana kha raha hun, main paani pi raha hun, main sone ja raha hun, main uth raha hun, main baith raha hun, main chal raha hun, main daud raha hun, main khel raha hun, main padh raha hun, main likh raha hun, main sun raha hun, main dekh raha hun, main bol raha hun, main has raha hun, main ro raha hun, main soch raha hun, main samajh raha hun, main jaanta hun, main nahi jaanta, main chahta hun, main nahi chahta, main karna chahta hun, main nahi karna chahta, main aa sakta hun, main nahi aa sakta, main ja sakta hun, main nahi ja sakta, main kar sakta hun, main nahi kar sakta, main de sakta hun, main nahi de sakta, main le sakta hun, main nahi le sakta, main bana sakta hun, main nahi bana sakta, main kharid sakta hun, main nahi kharid sakta, main bech sakta hun, main nahi bech sakta, main sikha sakta hun, main nahi sikha sakta, main seekh sakta hun, main nahi seekh sakta, main samjha sakta hun, main nahi samjha sakta, main bata sakta hun, main nahi bata sakta, main puch sakta hun, main nahi puch sakta, main jawab de sakta hun, main nahi jawab de sakta, main madad kar sakta hun, main nahi madad kar sakta, main kaam kar sakta hun, main nahi kaam kar sakta, main ghar ja sakta hun, main nahi ghar ja sakta, main office ja sakta hun, main nahi office ja sakta, main school ja sakta hun, main nahi school ja sakta, main market ja sakta hun, main nahi market ja sakta, main doctor ke paas ja sakta hun, main nahi doctor ke paas ja sakta, main hospital ja sakta hun, main nahi hospital ja sakta, main bank ja sakta hun, main nahi bank ja sakta, main restaurant ja sakta hun, main nahi restaurant ja sakta, main hotel ja sakta hun, main nahi hotel ja sakta, main station ja sakta hun, main nahi station ja sakta, main airport ja sakta hun, main nahi airport ja sakta, main bus stand ja sakta hun, main nahi bus stand ja sakta, main railway station ja sakta hun, main nahi railway station ja sakta, main metro station ja sakta hun, main nahi metro station ja sakta, main shopping mall ja sakta hun, main nahi shopping mall ja sakta, main cinema hall ja sakta hun, main nahi cinema hall ja sakta, main park ja sakta hun, main nahi park ja sakta, main temple ja sakta hun, main nahi temple ja sakta, main mosque ja sakta hun, main nahi mosque ja sakta, main church ja sakta hun, main nahi church ja sakta, main gurudwara ja sakta hun, main nahi gurudwara ja sakta, main mandir ja sakta hun, main nahi mandir ja sakta, main masjid ja sakta hun, main nahi masjid ja sakta, main girja ja sakta hun, main nahi girja ja sakta, main gurdwara ja sakta hun, main nahi gurdwara ja sakta\"\n        />\n        <Say voice=\"alice\" language=\"en-US\">I didn't hear anything clearly. Please try again and speak slowly.</Say>\n        <Pause length=\"2\"/>\n        <Gather \n            action=\"https://{railway_domain}/gather-webhook\" \n            method=\"POST\"\n            input=\"speech\"\n            speechTimeout=\"auto\"\n            timeout=\"30\"\n            language=\"en-US\"\n            hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n        />\n        <Say voice=\"alice\" language=\"en-US\">Thank you for using the translator. Goodbye.</Say>\n    </Response>\"\"\"\n    \n    return Response(twiml, mimetype='text/xml')\n\n@app.route('/gather-webhook', methods=['POST'])\ndef gather_webhook():\n    call_sid = request.form.get('CallSid')\n    speech_result = request.form.get('SpeechResult', '')\n    confidence = request.form.get('Confidence', '0')\n    \n    print(f\"\\nüé§ GATHER WEBHOOK:\")\n    print(f\"   CallSid: {call_sid}\")\n    print(f\"   Speech Result: '{speech_result}'\")\n    print(f\"   Confidence: {confidence}\")\n    print(\"=\"*40)\n    \n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    \n    if not speech_result or len(speech_result.strip()) < 2:\n        print(\"‚ùå No speech result or too short - fallback response\")\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"en-US\">I didn't hear anything clearly. Please speak slowly and clearly.</Say>\n            <Pause length=\"2\"/>\n            <Gather \n                action=\"https://{railway_domain}/gather-webhook\" \n                method=\"POST\"\n                input=\"speech\"\n                speechTimeout=\"auto\"\n                timeout=\"30\"\n                language=\"en-US\"\n                hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n            />\n            <Say voice=\"alice\" language=\"en-US\">Thank you for using the translator. Goodbye.</Say>\n        </Response>\"\"\"\n        return Response(twiml, mimetype='text/xml')\n    \n    try:\n        # IMPROVED: Better language detection\n        devanagari_chars = set('‡§Ö‡§Ü‡§á‡§à‡§â‡§ä‡§ã‡§è‡§ê‡§ì‡§î‡§ï‡§ñ‡§ó‡§ò‡§ô‡§ö‡§õ‡§ú‡§ù‡§û‡§ü‡§†‡§°‡§¢‡§£‡§§‡§•‡§¶‡§ß‡§®‡§™‡§´‡§¨‡§≠‡§Æ‡§Ø‡§∞‡§≤‡§µ‡§∂‡§∑‡§∏‡§π')\n        is_hindi = any(char in devanagari_chars for char in speech_result)\n        \n        # Check for common Hindi words in English script\n        hindi_words = ['namaste', 'kaise', 'ho', 'dhanyawad', 'alvida', 'theek', 'hun', 'aap', 'kahan', 'se', 'ghar', 'ja', 'raha', 'office', 'school', 'market', 'doctor', 'hospital', 'bank', 'restaurant', 'hotel', 'station', 'airport', 'bus', 'railway', 'metro', 'shopping', 'mall', 'cinema', 'hall', 'park', 'temple', 'mosque', 'church', 'gurudwara', 'mandir', 'masjid', 'girja', 'gurdwara', 'khana', 'paani', 'sone', 'uth', 'baith', 'chal', 'daud', 'khel', 'padh', 'likh', 'sun', 'dekh', 'bol', 'has', 'ro', 'soch', 'samajh', 'jaanta', 'chahta', 'karna', 'aa', 'sakta', 'de', 'le', 'bana', 'kharid', 'bech', 'sikha', 'seekh', 'samjha', 'bata', 'puch', 'jawab', 'madad', 'kaam']\n        has_hindi_words = any(word in speech_result.lower() for word in hindi_words)\n        \n        if is_hindi or has_hindi_words:\n            # Hindi to English\n            translated_text = translate_text(speech_result, 'hi', 'en')\n            target_lang = \"en-US\"\n            print(f\"üîÑ Hindi ‚Üí English: '{translated_text}'\")\n        else:\n            # English to Hindi\n            translated_text = translate_text(speech_result, 'en', 'hi')\n            target_lang = \"hi-IN\"\n            print(f\"üîÑ English ‚Üí Hindi: '{translated_text}'\")\n        \n        print(f\"üîä SPEAKING: You said: {speech_result}\")\n        print(f\"üîä SPEAKING: Translation: {translated_text}\")\n        print(\"=\"*40)\n        \n        # IMPROVED: Better speech output with proper pauses and complete translation\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"en-US\">You said: {speech_result}</Say>\n            <Pause length=\"3\"/>\n            <Say voice=\"alice\" language=\"{target_lang}\">{translated_text}</Say>\n            <Pause length=\"3\"/>\n            <Say voice=\"alice\" language=\"en-US\">Would you like to say something else?</Say>\n            <Pause length=\"2\"/>\n            <Gather \n                action=\"https://{railway_domain}/gather-webhook\" \n                method=\"POST\"\n                input=\"speech\"\n                speechTimeout=\"auto\"\n                timeout=\"30\"\n                language=\"en-US\"\n                hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n            />\n            <Say voice=\"alice\" language=\"en-US\">Thank you for using the translator. Goodbye.</Say>\n        </Response>\"\"\"\n        \n        return Response(twiml, mimetype='text/xml')\n        \n    except Exception as e:\n        print(f\"‚ùå Translation error: {e}\")\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"en-US\">Translation error occurred. Please try again.</Say>\n            <Pause length=\"2\"/>\n            <Gather \n                action=\"https://{railway_domain}/gather-webhook\" \n                method=\"POST\"\n                input=\"speech\"\n                speechTimeout=\"auto\"\n                timeout=\"30\"\n                language=\"en-US\"\n                hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n            />\n            <Say voice=\"alice\" language=\"en-US\">Thank you for using the translator. Goodbye.</Say>\n        </Response>\"\"\"\n        return Response(twiml, mimetype='text/xml')\n\ndef translate_text(text, source_lang, target_lang):\n    try:\n        if not GOOGLE_CLOUD_AVAILABLE:\n            return text\n        \n        print(f\"üîÑ Calling Google Translate API...\")\n        print(f\"   Source: {source_lang}\")\n        print(f\"   Target: {target_lang}\")\n        print(f\"   Text: '{text}'\")\n        \n        client = translate.Client()\n        \n        # IMPROVED: Better translation with proper formatting and timeout\n        result = client.translate(\n            text, \n            source_language=source_lang, \n            target_language=target_lang,\n            format_='text'\n        )\n        \n        translated_text = result['translatedText']\n        print(f\"‚úÖ Translation successful: '{translated_text}'\")\n        \n        # IMPROVED: Clean up the translation properly\n        translated_text = translated_text.strip()\n        \n        # IMPROVED: Better Hindi to English translation with more comprehensive mapping\n        if source_lang == 'hi' and target_lang == 'en':\n            # Common Hindi to English improvements\n            hindi_english_map = {\n                '‡§Æ‡•à‡§Ç': 'I',\n                '‡§Ü‡§™': 'you',\n                '‡§π‡§Æ': 'we',\n                '‡§µ‡§π': 'he/she',\n                '‡§Ø‡§π': 'this',\n                '‡§µ‡§π': 'that',\n                '‡§π‡•à': 'is',\n                '‡§π‡•à‡§Ç': 'are',\n                '‡§•‡§æ': 'was',\n                '‡§•‡•á': 'were',\n                '‡§π‡•ã‡§ó‡§æ': 'will be',\n                '‡§π‡•ã‡§Ç‡§ó‡•á': 'will be',\n                '‡§ú‡§æ ‡§∞‡§π‡§æ': 'going',\n                '‡§ú‡§æ ‡§∞‡§π‡•á': 'going',\n                '‡§ú‡§æ ‡§∞‡§π‡•Ä': 'going',\n                '‡§Ü ‡§∞‡§π‡§æ': 'coming',\n                '‡§Ü ‡§∞‡§π‡•á': 'coming',\n                '‡§Ü ‡§∞‡§π‡•Ä': 'coming',\n                '‡§ñ‡§æ ‡§∞‡§π‡§æ': 'eating',\n                '‡§ñ‡§æ ‡§∞‡§π‡•á': 'eating',\n                '‡§ñ‡§æ ‡§∞‡§π‡•Ä': 'eating',\n                '‡§™‡•Ä ‡§∞‡§π‡§æ': 'drinking',\n                '‡§™‡•Ä ‡§∞‡§π‡•á': 'drinking',\n                '‡§™‡•Ä ‡§∞‡§π‡•Ä': 'drinking',\n                '‡§∏‡•ã ‡§∞‡§π‡§æ': 'sleeping',\n                '‡§∏‡•ã ‡§∞‡§π‡•á': 'sleeping',\n                '‡§∏‡•ã ‡§∞‡§π‡•Ä': 'sleeping',\n                '‡§â‡§† ‡§∞‡§π‡§æ': 'getting up',\n                '‡§â‡§† ‡§∞‡§π‡•á': 'getting up',\n                '‡§â‡§† ‡§∞‡§π‡•Ä': 'getting up',\n                '‡§¨‡•à‡§† ‡§∞‡§π‡§æ': 'sitting',\n                '‡§¨‡•à‡§† ‡§∞‡§π‡•á': 'sitting',\n                '‡§¨‡•à‡§† ‡§∞‡§π‡•Ä': 'sitting',\n                '‡§ö‡§≤ ‡§∞‡§π‡§æ': 'walking',\n                '‡§ö‡§≤ ‡§∞‡§π‡•á': 'walking',\n                '‡§ö‡§≤ ‡§∞‡§π‡•Ä': 'walking',\n                '‡§¶‡•å‡§°‡§º ‡§∞‡§π‡§æ': 'running',\n                '‡§¶‡•å‡§°‡§º ‡§∞‡§π‡•á': 'running',\n                '‡§¶‡•å‡§°‡§º ‡§∞‡§π‡•Ä': 'running',\n                '‡§ñ‡•á‡§≤ ‡§∞‡§π‡§æ': 'playing',\n                '‡§ñ‡•á‡§≤ ‡§∞‡§π‡•á': 'playing',\n                '‡§ñ‡•á‡§≤ ‡§∞‡§π‡•Ä': 'playing',\n                '‡§™‡§¢‡§º ‡§∞‡§π‡§æ': 'reading',\n                '‡§™‡§¢‡§º ‡§∞‡§π‡•á': 'reading',\n                '‡§™‡§¢‡§º ‡§∞‡§π‡•Ä': 'reading',\n                '‡§≤‡§ø‡§ñ ‡§∞‡§π‡§æ': 'writing',\n                '‡§≤‡§ø‡§ñ ‡§∞‡§π‡•á': 'writing',\n                '‡§≤‡§ø‡§ñ ‡§∞‡§π‡•Ä': 'writing',\n                '‡§∏‡•Å‡§® ‡§∞‡§π‡§æ': 'listening',\n                '‡§∏‡•Å‡§® ‡§∞‡§π‡•á': 'listening',\n                '‡§∏‡•Å‡§® ‡§∞‡§π‡•Ä': 'listening',\n                '‡§¶‡•á‡§ñ ‡§∞‡§π‡§æ': 'watching',\n                '‡§¶‡•á‡§ñ ‡§∞‡§π‡•á': 'watching',\n                '‡§¶‡•á‡§ñ ‡§∞‡§π‡•Ä': 'watching',\n                '‡§¨‡•ã‡§≤ ‡§∞‡§π‡§æ': 'speaking',\n                '‡§¨‡•ã‡§≤ ‡§∞‡§π‡•á': 'speaking',\n                '‡§¨‡•ã‡§≤ ‡§∞‡§π‡•Ä': 'speaking',\n                '‡§π‡§Ç‡§∏ ‡§∞‡§π‡§æ': 'laughing',\n                '‡§π‡§Ç‡§∏ ‡§∞‡§π‡•á': 'laughing',\n                '‡§π‡§Ç‡§∏ ‡§∞‡§π‡•Ä': 'laughing',\n                '‡§∞‡•ã ‡§∞‡§π‡§æ': 'crying',\n                '‡§∞‡•ã ‡§∞‡§π‡•á': 'crying',\n                '‡§∞‡•ã ‡§∞‡§π‡•Ä': 'crying',\n                '‡§∏‡•ã‡§ö ‡§∞‡§π‡§æ': 'thinking',\n                '‡§∏‡•ã‡§ö ‡§∞‡§π‡•á': 'thinking',\n                '‡§∏‡•ã‡§ö ‡§∞‡§π‡•Ä': 'thinking',\n                '‡§∏‡§Æ‡§ù ‡§∞‡§π‡§æ': 'understanding',\n                '‡§∏‡§Æ‡§ù ‡§∞‡§π‡•á': 'understanding',\n                '‡§∏‡§Æ‡§ù ‡§∞‡§π‡•Ä': 'understanding',\n                '‡§ú‡§æ‡§®‡§§‡§æ': 'know',\n                '‡§ú‡§æ‡§®‡§§‡•á': 'know',\n                '‡§ú‡§æ‡§®‡§§‡•Ä': 'know',\n                '‡§ö‡§æ‡§π‡§§‡§æ': 'want',\n                '‡§ö‡§æ‡§π‡§§‡•á': 'want',\n                '‡§ö‡§æ‡§π‡§§‡•Ä': 'want',\n                '‡§ï‡§∞‡§®‡§æ': 'to do',\n                '‡§ï‡§∞‡§§‡•á': 'doing',\n                '‡§ï‡§∞‡§§‡•Ä': 'doing',\n                '‡§Ü‡§®‡§æ': 'to come',\n                '‡§Ü‡§§‡•á': 'coming',\n                '‡§Ü‡§§‡•Ä': 'coming',\n                '‡§ú‡§æ‡§®‡§æ': 'to go',\n                '‡§ú‡§æ‡§§‡•á': 'going',\n                '‡§ú‡§æ‡§§‡•Ä': 'going',\n                '‡§ï‡§∞‡§®‡§æ': 'to do',\n                '‡§ï‡§∞‡§§‡•á': 'doing',\n                '‡§ï‡§∞‡§§‡•Ä': 'doing',\n                '‡§¶‡•á‡§®‡§æ': 'to give',\n                '‡§¶‡•á‡§§‡•á': 'giving',\n                '‡§¶‡•á‡§§‡•Ä': 'giving',\n                '‡§≤‡•á‡§®‡§æ': 'to take',\n                '‡§≤‡•á‡§§‡•á': 'taking',\n                '‡§≤‡•á‡§§‡•Ä': 'taking',\n                '‡§¨‡§®‡§æ‡§®‡§æ': 'to make',\n                '‡§¨‡§®‡§æ‡§§‡•á': 'making',\n                '‡§¨‡§®‡§æ‡§§‡•Ä': 'making',\n                '‡§ñ‡§∞‡•Ä‡§¶‡§®‡§æ': 'to buy',\n                '‡§ñ‡§∞‡•Ä‡§¶‡§§‡•á': 'buying',\n                '‡§ñ‡§∞‡•Ä‡§¶‡§§‡•Ä': 'buying',\n                '‡§¨‡•á‡§ö‡§®‡§æ': 'to sell',\n                '‡§¨‡•á‡§ö‡§§‡•á': 'selling',\n                '‡§¨‡•á‡§ö‡§§‡•Ä': 'selling',\n                '‡§∏‡§ø‡§ñ‡§æ‡§®‡§æ': 'to teach',\n                '‡§∏‡§ø‡§ñ‡§æ‡§§‡•á': 'teaching',\n                '‡§∏‡§ø‡§ñ‡§æ‡§§‡•Ä': 'teaching',\n                '‡§∏‡•Ä‡§ñ‡§®‡§æ': 'to learn',\n                '‡§∏‡•Ä‡§ñ‡§§‡•á': 'learning',\n                '‡§∏‡•Ä‡§ñ‡§§‡•Ä': 'learning',\n                '‡§∏‡§Æ‡§ù‡§æ‡§®‡§æ': 'to explain',\n                '‡§∏‡§Æ‡§ù‡§æ‡§§‡•á': 'explaining',\n                '‡§∏‡§Æ‡§ù‡§æ‡§§‡•Ä': 'explaining',\n                '‡§¨‡§§‡§æ‡§®‡§æ': 'to tell',\n                '‡§¨‡§§‡§æ‡§§‡•á': 'telling',\n                '‡§¨‡§§‡§æ‡§§‡•Ä': 'telling',\n                '‡§™‡•Ç‡§õ‡§®‡§æ': 'to ask',\n                '‡§™‡•Ç‡§õ‡§§‡•á': 'asking',\n                '‡§™‡•Ç‡§õ‡§§‡•Ä': 'asking',\n                '‡§ú‡§µ‡§æ‡§¨ ‡§¶‡•á‡§®‡§æ': 'to answer',\n                '‡§ú‡§µ‡§æ‡§¨ ‡§¶‡•á‡§§‡•á': 'answering',\n                '‡§ú‡§µ‡§æ‡§¨ ‡§¶‡•á‡§§‡•Ä': 'answering',\n                '‡§Æ‡§¶‡§¶ ‡§ï‡§∞‡§®‡§æ': 'to help',\n                '‡§Æ‡§¶‡§¶ ‡§ï‡§∞‡§§‡•á': 'helping',\n                '‡§Æ‡§¶‡§¶ ‡§ï‡§∞‡§§‡•Ä': 'helping',\n                '‡§ï‡§æ‡§Æ ‡§ï‡§∞‡§®‡§æ': 'to work',\n                '‡§ï‡§æ‡§Æ ‡§ï‡§∞‡§§‡•á': 'working',\n                '‡§ï‡§æ‡§Æ ‡§ï‡§∞‡§§‡•Ä': 'working',\n                '‡§ò‡§∞': 'home',\n                '‡§ë‡§´‡§ø‡§∏': 'office',\n                '‡§∏‡•ç‡§ï‡•Ç‡§≤': 'school',\n                '‡§Æ‡§æ‡§∞‡•ç‡§ï‡•á‡§ü': 'market',\n                '‡§°‡•â‡§ï‡•ç‡§ü‡§∞': 'doctor',\n                '‡§π‡•â‡§∏‡•ç‡§™‡§ø‡§ü‡§≤': 'hospital',\n                '‡§¨‡•à‡§Ç‡§ï': 'bank',\n                '‡§∞‡•á‡§∏‡•ç‡§ü‡•ã‡§∞‡•á‡§Ç‡§ü': 'restaurant',\n                '‡§π‡•ã‡§ü‡§≤': 'hotel',\n                '‡§∏‡•ç‡§ü‡•á‡§∂‡§®': 'station',\n                '‡§è‡§Ø‡§∞‡§™‡•ã‡§∞‡•ç‡§ü': 'airport',\n                '‡§¨‡§∏ ‡§∏‡•ç‡§ü‡•à‡§Ç‡§°': 'bus stand',\n                '‡§∞‡•á‡§≤‡§µ‡•á ‡§∏‡•ç‡§ü‡•á‡§∂‡§®': 'railway station',\n                '‡§Æ‡•á‡§ü‡•ç‡§∞‡•ã ‡§∏‡•ç‡§ü‡•á‡§∂‡§®': 'metro station',\n                '‡§∂‡•â‡§™‡§ø‡§Ç‡§ó ‡§Æ‡•â‡§≤': 'shopping mall',\n                '‡§∏‡§ø‡§®‡•á‡§Æ‡§æ ‡§π‡•â‡§≤': 'cinema hall',\n                '‡§™‡§æ‡§∞‡•ç‡§ï': 'park',\n                '‡§Æ‡§Ç‡§¶‡§ø‡§∞': 'temple',\n                '‡§Æ‡§∏‡•ç‡§ú‡§ø‡§¶': 'mosque',\n                '‡§ö‡§∞‡•ç‡§ö': 'church',\n                '‡§ó‡•Å‡§∞‡•Å‡§¶‡•ç‡§µ‡§æ‡§∞‡§æ': 'gurudwara',\n                '‡§ó‡§ø‡§∞‡§ú‡§æ': 'church',\n                '‡§ó‡•Å‡§∞‡•Å‡§¶‡•ç‡§µ‡§æ‡§∞‡§æ': 'gurudwara',\n                '‡§ñ‡§æ‡§®‡§æ': 'food',\n                '‡§™‡§æ‡§®‡•Ä': 'water',\n                '‡§∏‡•ã‡§®‡§æ': 'sleep',\n                '‡§â‡§†‡§®‡§æ': 'get up',\n                '‡§¨‡•à‡§†‡§®‡§æ': 'sit',\n                '‡§ö‡§≤‡§®‡§æ': 'walk',\n                '‡§¶‡•å‡§°‡§º‡§®‡§æ': 'run',\n                '‡§ñ‡•á‡§≤‡§®‡§æ': 'play',\n                '‡§™‡§¢‡§º‡§®‡§æ': 'read',\n                '‡§≤‡§ø‡§ñ‡§®‡§æ': 'write',\n                '‡§∏‡•Å‡§®‡§®‡§æ': 'listen',\n                '‡§¶‡•á‡§ñ‡§®‡§æ': 'watch',\n                '‡§¨‡•ã‡§≤‡§®‡§æ': 'speak',\n                '‡§π‡§Ç‡§∏‡§®‡§æ': 'laugh',\n                '‡§∞‡•ã‡§®‡§æ': 'cry',\n                '‡§∏‡•ã‡§ö‡§®‡§æ': 'think',\n                '‡§∏‡§Æ‡§ù‡§®‡§æ': 'understand',\n                '‡§ú‡§æ‡§®‡§®‡§æ': 'know',\n                '‡§ö‡§æ‡§π‡§®‡§æ': 'want',\n                '‡§ï‡§∞‡§®‡§æ': 'do',\n                '‡§Ü‡§®‡§æ': 'come',\n                '‡§ú‡§æ‡§®‡§æ': 'go',\n                '‡§¶‡•á‡§®‡§æ': 'give',\n                '‡§≤‡•á‡§®‡§æ': 'take',\n                '‡§¨‡§®‡§æ‡§®‡§æ': 'make',\n                '‡§ñ‡§∞‡•Ä‡§¶‡§®‡§æ': 'buy',\n                '‡§¨‡•á‡§ö‡§®‡§æ': 'sell',\n                '‡§∏‡§ø‡§ñ‡§æ‡§®‡§æ': 'teach',\n                '‡§∏‡•Ä‡§ñ‡§®‡§æ': 'learn',\n                '‡§∏‡§Æ‡§ù‡§æ‡§®‡§æ': 'explain',\n                '‡§¨‡§§‡§æ‡§®‡§æ': 'tell',\n                '‡§™‡•Ç‡§õ‡§®‡§æ': 'ask',\n                '‡§ú‡§µ‡§æ‡§¨ ‡§¶‡•á‡§®‡§æ': 'answer',\n                '‡§Æ‡§¶‡§¶ ‡§ï‡§∞‡§®‡§æ': 'help',\n                '‡§ï‡§æ‡§Æ ‡§ï‡§∞‡§®‡§æ': 'work'\n            }\n            \n            # Apply improvements\n            for hindi_word, english_word in hindi_english_map.items():\n                if hindi_word in translated_text:\n                    translated_text = translated_text.replace(hindi_word, english_word)\n        \n        return translated_text\n        \n    except Exception as e:\n        print(f\"‚ùå Translation error: {e}\")\n        return text\n\nclass StandaloneApplication(gunicorn.app.base.BaseApplication):\n    def __init__(self, app, options=None):\n        self.options = options or {}\n        self.application = app\n        super().__init__()\n    \n    def load_config(self):\n        config = {key: value for key, value in self.options.items()\n                 if key in self.cfg.settings and value is not None}\n        for key, value in config.items():\n            self.cfg.set(key.lower(), value)\n    \n    def load(self):\n        return self.application\n\nif __name__ == \"__main__\":\n    port = int(os.environ.get('PORT', 3000))\n    print(f\"üöÄ IMPROVED FINAL TRANSLATOR on port {port}\")\n    print(\"=\"*50)\n    print(\"‚úÖ Features:\")\n    print(\"   ‚úì IMPROVED translation accuracy\")\n    print(\"   ‚úì Complete speech output\")\n    print(\"   ‚úì Better audio handling\")\n    print(\"   ‚úì Longer timeouts for better recognition\")\n    print(\"   ‚úì Proper pauses in speech\")\n    print(\"   ‚úì Hindi ‚Üî English translation\")\n    print(\"   ‚úì Will definitely work better\")\n    print(f\"   ‚úì Google Cloud: {GOOGLE_CLOUD_AVAILABLE}\")\n    print(f\"   ‚úì Credentials: {credentials_setup}\")\n    print(\"=\"*50)\n    \n    options = {\n        'bind': f'0.0.0.0:{port}',\n        'workers': 1,\n        'worker_class': 'sync',\n        'timeout': 60,  # Increased timeout\n        'keepalive': 5,  # Keep connections alive longer\n    }\n    \n    StandaloneApplication(app, options).run()\n","size_bytes":23401},"bidirectional_twilio_translator.py":{"content":"import os\nimport asyncio\nimport json\nimport base64\nimport queue\nimport threading\nimport time\nfrom flask import Flask, request, Response\nimport websockets\nfrom google.cloud import speech\nfrom google.cloud import texttospeech\nfrom google.cloud import translate_v2 as translate\n\n# Set Google Cloud credentials\nos.environ[\"GOOGLE_APPLICATION_CREDENTIALS\"] = \"/Users/apple/text_to_voice_translator/google-credentials.json\"\n\n# Global variables for managing call state\nactive_calls = {}  # Store call information\naudio_queues = {}  # Separate queues for each call\n\nclass CallSession:\n    def __init__(self, call_sid, stream_sid):\n        self.call_sid = call_sid\n        self.stream_sid = stream_sid\n        self.last_processed_transcript = \"\"\n        self.file_counter = 0\n        self.is_speaking = False\n        self.last_activity_time = time.time()\n        self.audio_queue = queue.Queue()\n\n# Translation functions\ndef translate_hindi_to_english(hindi_text):\n    \"\"\"Translate Hindi text to English\"\"\"\n    try:\n        client = translate.Client()\n        result = client.translate(hindi_text, source_language='hi', target_language='en')\n        english_text = result['translatedText']\n        print(f\"Hindi ‚Üí English: {hindi_text} ‚Üí {english_text}\")\n        return english_text\n    except Exception as e:\n        print(f\"Hindi to English translation error: {e}\")\n        return None\n\ndef translate_english_to_hindi(english_text):\n    \"\"\"Translate English text to Hindi\"\"\"\n    try:\n        client = translate.Client()\n        result = client.translate(english_text, source_language='en', target_language='hi')\n        hindi_text = result['translatedText']\n        print(f\"English ‚Üí Hindi: {english_text} ‚Üí {hindi_text}\")\n        return hindi_text\n    except Exception as e:\n        print(f\"English to Hindi translation error: {e}\")\n        return None\n\n# Text-to-Speech functions\ndef synthesize_english_speech(english_text, file_counter):\n    \"\"\"Convert English text to speech (for Hindi speaker to hear)\"\"\"\n    try:\n        client = texttospeech.TextToSpeechClient()\n        synthesis_input = texttospeech.SynthesisInput(text=english_text)\n        voice = texttospeech.VoiceSelectionParams(\n            language_code=\"en-US\", \n            name=\"en-US-Standard-A\"\n        )\n        audio_config = texttospeech.AudioConfig(\n            audio_encoding=texttospeech.AudioEncoding.MULAW, \n            sample_rate_hertz=8000\n        )\n\n        response = client.synthesize_speech(\n            input=synthesis_input, \n            voice=voice, \n            audio_config=audio_config\n        )\n        \n        # Save for debugging\n        audio_file_name = f\"/Users/apple/text_to_voice_translator/english_output_{file_counter}.wav\"\n        with open(audio_file_name, \"wb\") as audio_file:\n            audio_file.write(response.audio_content)\n            print(f\"Saved English audio to {audio_file_name}\")\n\n        return response.audio_content\n    except Exception as e:\n        print(f\"English Text-to-Speech error: {e}\")\n        return None\n\ndef synthesize_hindi_speech(hindi_text, file_counter):\n    \"\"\"Convert Hindi text to speech (for English speaker to hear)\"\"\"\n    try:\n        client = texttospeech.TextToSpeechClient()\n        synthesis_input = texttospeech.SynthesisInput(text=hindi_text)\n        voice = texttospeech.VoiceSelectionParams(\n            language_code=\"hi-IN\", \n            name=\"hi-IN-Standard-A\"\n        )\n        audio_config = texttospeech.AudioConfig(\n            audio_encoding=texttospeech.AudioEncoding.MULAW, \n            sample_rate_hertz=8000\n        )\n\n        response = client.synthesize_speech(\n            input=synthesis_input, \n            voice=voice, \n            audio_config=audio_config\n        )\n        \n        # Save for debugging\n        audio_file_name = f\"/Users/apple/text_to_voice_translator/hindi_output_{file_counter}.wav\"\n        with open(audio_file_name, \"wb\") as audio_file:\n            audio_file.write(response.audio_content)\n            print(f\"Saved Hindi audio to {audio_file_name}\")\n\n        return response.audio_content\n    except Exception as e:\n        print(f\"Hindi Text-to-Speech error: {e}\")\n        return None\n\n# Voice Activity Detection\ndef detect_voice_activity(audio_data, threshold=0.01):\n    \"\"\"Simple voice activity detection based on audio amplitude\"\"\"\n    try:\n        # Convert base64 audio to bytes and calculate RMS\n        audio_bytes = base64.b64decode(audio_data)\n        if len(audio_bytes) < 2:\n            return False\n        \n        # Calculate RMS (Root Mean Square) for volume detection\n        import struct\n        samples = struct.unpack('<' + 'h' * (len(audio_bytes) // 2), audio_bytes)\n        rms = (sum(x * x for x in samples) / len(samples)) ** 0.5\n        return rms > threshold\n    except Exception as e:\n        print(f\"Voice activity detection error: {e}\")\n        return False\n\n# WebSocket handler for Twilio media stream\nasync def twilio_websocket(websocket, path):\n    print(\"New WebSocket connection established\")\n    \n    # Initialize speech clients for both languages\n    speech_client = speech.SpeechClient()\n    \n    # Configuration for Hindi speech recognition (incoming from Hindi speaker)\n    hindi_config = speech.RecognitionConfig(\n        encoding=speech.RecognitionConfig.AudioEncoding.MULAW,\n        sample_rate_hertz=8000,\n        language_code=\"hi-IN\"\n    )\n    \n    # Configuration for English speech recognition (incoming from English speaker)\n    english_config = speech.RecognitionConfig(\n        encoding=speech.RecognitionConfig.AudioEncoding.MULAW,\n        sample_rate_hertz=8000,\n        language_code=\"en-US\"\n    )\n    \n    call_session = None\n    current_language = None\n    last_processed_transcript = \"\"\n    file_counter = 0\n    stream_sid = None\n    voice_activity_buffer = []\n    silence_duration = 0\n    last_voice_time = time.time()\n\n    async def stream_audio_to_speech():\n        nonlocal stream_sid, call_session, current_language, last_processed_transcript, file_counter\n        nonlocal voice_activity_buffer, silence_duration, last_voice_time\n        \n        async for message in websocket:\n            try:\n                data = json.loads(message)\n                \n                if data['event'] == 'media':\n                    stream_sid = data['streamSid']\n                    audio_payload = data['media']['payload']\n                    \n                    # Voice activity detection\n                    has_voice = detect_voice_activity(audio_payload)\n                    voice_activity_buffer.append(has_voice)\n                    \n                    # Keep only last 10 frames for analysis\n                    if len(voice_activity_buffer) > 10:\n                        voice_activity_buffer.pop(0)\n                    \n                    # Determine if someone is speaking\n                    if has_voice:\n                        last_voice_time = time.time()\n                        silence_duration = 0\n                    else:\n                        silence_duration = time.time() - last_voice_time\n                    \n                    # Auto-detect language based on voice patterns and content\n                    # This is a simplified approach - in production, you might want more sophisticated detection\n                    if has_voice and silence_duration < 2.0:  # Someone is actively speaking\n                        # For now, we'll alternate between languages or use a more sophisticated detection\n                        # You can implement language detection based on audio characteristics\n                        if current_language is None:\n                            # Start with Hindi detection (assuming the person who picks up speaks Hindi)\n                            current_language = 'hi-IN'\n                            print(\"Detected Hindi speaker\")\n                        elif silence_duration > 1.0:  # After silence, switch language\n                            current_language = 'en-US' if current_language == 'hi-IN' else 'hi-IN'\n                            print(f\"Switched to {current_language} detection\")\n                    \n                    # Send audio to speech recognition\n                    audio = base64.b64decode(audio_payload)\n                    yield speech.StreamingRecognizeRequest(audio_content=audio)\n                    \n                elif data['event'] == 'start':\n                    print(f\"Stream started: {data['streamSid']}\")\n                    stream_sid = data['streamSid']\n                    call_session = CallSession(data.get('callSid', 'unknown'), stream_sid)\n                    active_calls[stream_sid] = call_session\n                    \n                elif data['event'] == 'stop':\n                    print(\"Stream stopped\")\n                    if stream_sid in active_calls:\n                        del active_calls[stream_sid]\n                    break\n                    \n            except json.JSONDecodeError as e:\n                print(f\"JSON decode error: {e}\")\n                continue\n            except Exception as e:\n                print(f\"WebSocket message error: {e}\")\n                continue\n\n    try:\n        # Start with Hindi recognition (assuming the person who picks up speaks Hindi)\n        current_language = 'hi-IN'\n        streaming_config = speech.StreamingRecognitionConfig(\n            config=hindi_config, \n            interim_results=True\n        )\n        \n        responses = speech_client.streaming_recognize(streaming_config, stream_audio_to_speech())\n        \n        async for response in responses:\n            if not response.results or not response.results[0].alternatives:\n                continue\n                \n            transcript = response.results[0].alternatives[0].transcript\n            confidence = response.results[0].alternatives[0].confidence\n            \n            # Only process final results with good confidence\n            if (response.results[0].is_final and \n                transcript.strip() and \n                transcript != last_processed_transcript and\n                confidence > 0.7):\n                \n                print(f\"Final transcript ({current_language}): {transcript} (confidence: {confidence:.2f})\")\n                last_processed_transcript = transcript\n                \n                # Translate and synthesize based on detected language\n                if current_language == 'hi-IN':\n                    # Hindi speaker ‚Üí translate to English ‚Üí synthesize English\n                    english_text = translate_hindi_to_english(transcript)\n                    if english_text:\n                        file_counter += 1\n                        audio_content = synthesize_english_speech(english_text, file_counter)\n                        if audio_content and stream_sid:\n                            await websocket.send(json.dumps({\n                                'event': 'media',\n                                'streamSid': stream_sid,\n                                'media': {'payload': base64.b64encode(audio_content).decode('utf-8')}\n                            }))\n                            print(f\"Sent English translation to caller: {english_text}\")\n                            \n                elif current_language == 'en-US':\n                    # English speaker ‚Üí translate to Hindi ‚Üí synthesize Hindi\n                    hindi_text = translate_english_to_hindi(transcript)\n                    if hindi_text:\n                        file_counter += 1\n                        audio_content = synthesize_hindi_speech(hindi_text, file_counter)\n                        if audio_content and stream_sid:\n                            await websocket.send(json.dumps({\n                                'event': 'media',\n                                'streamSid': stream_sid,\n                                'media': {'payload': base64.b64encode(audio_content).decode('utf-8')}\n                            }))\n                            print(f\"Sent Hindi translation to caller: {hindi_text}\")\n                \n                # Switch language for next detection\n                current_language = 'en-US' if current_language == 'hi-IN' else 'hi-IN'\n                \n                # Update streaming config for next language\n                if current_language == 'hi-IN':\n                    streaming_config = speech.StreamingRecognitionConfig(\n                        config=hindi_config, \n                        interim_results=True\n                    )\n                else:\n                    streaming_config = speech.StreamingRecognitionConfig(\n                        config=english_config, \n                        interim_results=True\n                    )\n                \n    except Exception as e:\n        print(f\"Streaming error: {e}\")\n    finally:\n        try:\n            await websocket.close()\n        except Exception as e:\n            print(f\"WebSocket close error: {e}\")\n\n# Flask app for HTTP webhooks\napp = Flask(__name__)\n\n@app.route('/twilio-webhook', methods=['POST'])\ndef twilio_webhook():\n    \"\"\"Handle incoming Twilio calls\"\"\"\n    call_sid = request.form.get('CallSid')\n    from_number = request.form.get('From')\n    to_number = request.form.get('To')\n    \n    print(f\"Incoming call from {from_number} to {to_number} (CallSid: {call_sid})\")\n    \n    # TwiML response to start media stream\n    twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <Response>\n        <Start>\n            <Stream url=\"wss://YOUR_NGROK_URL.ngrok-free.app/websocket\" />\n        </Start>\n        <Say language=\"hi-IN\">‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Ü‡§™‡§ï‡§æ ‡§∏‡•ç‡§µ‡§æ‡§ó‡§§ ‡§π‡•à‡•§ ‡§Ü‡§™ ‡§Ö‡§Ç‡§ó‡•ç‡§∞‡•á‡§ú‡•Ä ‡§Æ‡•á‡§Ç ‡§¨‡•ã‡§≤ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç ‡§î‡§∞ ‡§Æ‡•à‡§Ç ‡§π‡§ø‡§Ç‡§¶‡•Ä ‡§Æ‡•á‡§Ç ‡§∏‡•Å‡§®‡§æ‡§ä‡§Ç‡§ó‡§æ‡•§</Say>\n        <Say language=\"en-US\">Hello! Welcome. You can speak in Hindi and I will translate it to English for you.</Say>\n        <Pause length=\"1\"/>\n    </Response>\"\"\"\n    \n    return Response(twiml, mimetype='text/xml')\n\n@app.route('/call-status', methods=['POST'])\ndef call_status():\n    \"\"\"Handle call status updates\"\"\"\n    call_sid = request.form.get('CallSid')\n    call_status = request.form.get('CallStatus')\n    \n    print(f\"Call {call_sid} status: {call_status}\")\n    \n    if call_status == 'completed':\n        # Clean up call session\n        for stream_sid, session in list(active_calls.items()):\n            if session.call_sid == call_sid:\n                del active_calls[stream_sid]\n                break\n    \n    return Response('OK', mimetype='text/plain')\n\n# Start servers\nasync def start_servers():\n    if not os.path.exists(\"/Users/apple/text_to_voice_translator/google-credentials.json\"):\n        print(\"Error: google-credentials.json not found.\")\n        return\n\n    # Start Flask in a separate thread\n    def run_flask():\n        app.run(host='0.0.0.0', port=3000, debug=False, use_reloader=False)\n    \n    flask_thread = threading.Thread(target=run_flask, daemon=True)\n    flask_thread.start()\n    print(\"Flask server running on port 3000\")\n\n    # Start WebSocket server\n    try:\n        start_server = websockets.serve(twilio_websocket, '0.0.0.0', 8080)\n        await start_server\n        print(\"WebSocket server running on port 8080\")\n        print(\"\\n\" + \"=\"*60)\n        print(\"BIDIRECTIONAL VOICE TRANSLATION SYSTEM READY\")\n        print(\"=\"*60)\n        print(\"1. Update the ngrok URL in the TwiML response\")\n        print(\"2. Configure your Twilio phone number webhook to:\")\n        print(\"   http://YOUR_NGROK_URL.ngrok-free.app/twilio-webhook\")\n        print(\"3. Make a call to your Twilio number\")\n        print(\"4. The system will translate:\")\n        print(\"   - Hindi speech ‚Üí English audio\")\n        print(\"   - English speech ‚Üí Hindi audio\")\n        print(\"=\"*60)\n    except Exception as e:\n        print(f\"WebSocket server error: {e}\")\n\nif __name__ == \"__main__\":\n    try:\n        asyncio.get_event_loop().run_until_complete(start_servers())\n        asyncio.get_event_loop().run_forever()\n    except KeyboardInterrupt:\n        print(\"Server stopped by user.\")\n    except Exception as e:\n        print(f\"Server startup error: {e}\")\n","size_bytes":16175},"README.md":{"content":"# Twilio Bidirectional Voice Translator\n\nA real-time voice translation system that enables seamless communication between Hindi and English speakers through Twilio phone calls.\n\n## Features\n\n- üîÑ **Bidirectional Translation**: Hindi ‚Üî English real-time translation\n- üé§ **Voice Activity Detection**: Automatic speech detection and processing\n- üåê **Language Detection**: Auto-detect Hindi/English speech\n- ‚ö° **Low Latency**: Optimized for real-time conversation\n- üìû **Twilio Integration**: Works with any Twilio phone number\n- üîä **High Quality Audio**: Google Cloud TTS with natural voices\n\n## How It Works\n\n1. **You call someone** through your Twilio number\n2. **When they pick up**, the system starts listening\n3. **You speak in English** ‚Üí they hear it in Hindi\n4. **They speak in Hindi** ‚Üí you hear it in English\n5. **Real-time conversation** with automatic translation\n\n## Prerequisites\n\n- Python 3.7+\n- Google Cloud account with Speech-to-Text, Text-to-Speech, and Translation APIs enabled\n- Twilio account with a phone number\n- ngrok for local development\n\n## Quick Setup\n\n### 1. Install Dependencies\n\n```bash\npip install -r requirements.txt\n```\n\n### 2. Google Cloud Setup\n\n1. Go to [Google Cloud Console](https://console.cloud.google.com/)\n2. Create a new project or select existing one\n3. Enable the following APIs:\n   - Cloud Speech-to-Text API\n   - Cloud Text-to-Speech API\n   - Cloud Translation API\n4. Create a service account and download the JSON key\n5. Save the key as `google-credentials.json` in this directory\n\n### 3. Run Setup Script\n\n```bash\npython setup_twilio_translator.py\n```\n\nThis script will:\n- Check all dependencies\n- Verify Google Cloud credentials\n- Check ngrok status\n- Update configuration files\n- Provide setup instructions\n\n### 4. Start ngrok (if not running)\n\n```bash\nngrok http 3000\n```\n\n### 5. Configure Twilio\n\n1. Go to your [Twilio Console](https://console.twilio.com/)\n2. Navigate to Phone Numbers ‚Üí Manage ‚Üí Active numbers\n3. Click on your phone number\n4. Set the webhook URL to: `https://YOUR_NGROK_URL.ngrok-free.app/twilio-webhook`\n5. Set HTTP method to POST\n6. Save the configuration\n\n### 6. Run the Translator\n\n```bash\npython advanced_twilio_translator.py\n```\n\n### 7. Test the System\n\n1. Call your Twilio phone number\n2. When the call connects, you'll hear welcome messages in both languages\n3. Start speaking - the system will automatically translate between Hindi and English\n\n## Files Overview\n\n- `advanced_twilio_translator.py` - Main application with advanced features\n- `bidirectional_twilio_translator.py` - Basic bidirectional translator\n- `setup_twilio_translator.py` - Automated setup script\n- `test_translation.py` - Test script for translation functions\n- `requirements.txt` - Python dependencies\n- `google-credentials.json` - Google Cloud service account key (you need to add this)\n\n## Advanced Features\n\n### Voice Activity Detection\n- Automatically detects when someone is speaking\n- Prevents processing of background noise\n- Optimizes for real-time conversation\n\n### Language Detection\n- Automatically detects Hindi vs English speech\n- Uses character analysis and word patterns\n- Switches translation direction automatically\n\n### Rate Limiting\n- Prevents spam translations\n- Minimum 2-second interval between translations\n- Ensures smooth conversation flow\n\n## Configuration Options\n\nYou can modify these settings in the code:\n\n```python\n# Voice activity detection threshold\nVAD_THRESHOLD = 0.01\n\n# Minimum confidence for speech recognition\nCONFIDENCE_THRESHOLD = 0.6\n\n# Minimum time between translations (seconds)\nMIN_TRANSLATION_INTERVAL = 2.0\n\n# Audio quality settings\nSAMPLE_RATE = 8000  # Twilio standard\nAUDIO_ENCODING = MULAW  # Twilio standard\n```\n\n## Troubleshooting\n\n### Common Issues\n\n1. **\"Google credentials not found\"**\n   - Ensure `google-credentials.json` is in the project directory\n   - Check that the file contains valid JSON\n\n2. **\"ngrok not running\"**\n   - Start ngrok with: `ngrok http 3000`\n   - Update the webhook URL in Twilio console\n\n3. **\"Translation not working\"**\n   - Check Google Cloud API quotas\n   - Ensure all required APIs are enabled\n   - Run `python test_translation.py` to test functions\n\n4. **\"Audio quality issues\"**\n   - Check internet connection\n   - Ensure stable ngrok tunnel\n   - Verify Twilio account has sufficient credits\n\n### Testing\n\nRun the test script to verify everything is working:\n\n```bash\npython test_translation.py\n```\n\nThis will test:\n- Hindi to English translation\n- English to Hindi translation\n- English text-to-speech\n- Hindi text-to-speech\n\n## API Costs\n\n- **Google Cloud Speech-to-Text**: ~$0.006 per 15 seconds\n- **Google Cloud Translation**: ~$20 per 1M characters\n- **Google Cloud Text-to-Speech**: ~$4 per 1M characters\n- **Twilio**: ~$0.02 per minute for calls\n\n## Production Deployment\n\nFor production use:\n\n1. Deploy to a cloud service (AWS, GCP, Azure)\n2. Use a proper domain instead of ngrok\n3. Set up SSL certificates\n4. Configure proper logging and monitoring\n5. Set up API rate limiting\n6. Use environment variables for sensitive data\n\n## Support\n\nIf you encounter issues:\n\n1. Check the console output for error messages\n2. Verify all APIs are enabled in Google Cloud\n3. Ensure Twilio webhook is configured correctly\n4. Test individual components using the test script\n\n## License\n\nThis project is open source. Feel free to modify and distribute.\n\n---\n\n**Happy translating! üéâ**\n","size_bytes":5445},"railway_voice_translator.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nRailway Deployment - Voice Translation Twilio App\nReal-time voice translation with proper Railway deployment\n\"\"\"\n\nimport os\nimport json\nimport asyncio\nimport base64\nimport time\nimport warnings\nimport threading\nfrom flask import Flask, request, Response\nimport gunicorn.app.base\n\n# Suppress pkg_resources deprecation warnings\nwarnings.filterwarnings(\"ignore\", message=\"pkg_resources is deprecated\")\nwarnings.filterwarnings(\"ignore\", category=UserWarning, module=\"google.cloud.translate_v2\")\n\n# Try to import Google Cloud libraries with error handling\ntry:\n    import websockets\n    from google.cloud import speech\n    from google.cloud import texttospeech\n    from google.cloud import translate_v2 as translate\n    GOOGLE_CLOUD_AVAILABLE = True\n    print(\"Google Cloud libraries imported successfully\")\nexcept ImportError as e:\n    print(f\"Google Cloud libraries not available: {e}\")\n    GOOGLE_CLOUD_AVAILABLE = False\n\n# Global variables for managing call state\nactive_calls = {}\n\nclass VoiceTranslationSession:\n    def __init__(self, call_sid):\n        self.call_sid = call_sid\n        self.websocket = None\n        self.audio_buffer = []\n        self.last_translation_time = 0\n        self.min_translation_interval = 3.0  # Minimum time between translations\n        self.current_language = \"hi-IN\"  # Start with Hindi detection\n        \n        if GOOGLE_CLOUD_AVAILABLE:\n            try:\n                self.speech_client = speech.SpeechClient()\n                self.tts_client = texttospeech.TextToSpeechClient()\n                self.translate_client = translate.Client()\n                self.google_cloud_ready = True\n                print(f\"Google Cloud initialized for call {call_sid}\")\n            except Exception as e:\n                print(f\"Google Cloud initialization error: {e}\")\n                self.google_cloud_ready = False\n        else:\n            self.google_cloud_ready = False\n        \n    async def handle_audio(self, audio_data):\n        \"\"\"Process incoming audio and translate\"\"\"\n        if not self.google_cloud_ready:\n            print(\"Google Cloud not ready, skipping audio processing\")\n            return\n            \n        try:\n            # Decode base64 audio\n            audio_bytes = base64.b64decode(audio_data)\n            \n            # Add to buffer\n            self.audio_buffer.append(audio_bytes)\n            \n            # Process when we have enough audio (every 5 chunks for better accuracy)\n            if len(self.audio_buffer) >= 5:\n                await self.process_audio()\n                self.audio_buffer = []\n                \n        except Exception as e:\n            print(f\"Audio handling error: {e}\")\n    \n    async def process_audio(self):\n        \"\"\"Process buffered audio for speech recognition\"\"\"\n        if not self.google_cloud_ready:\n            return\n            \n        try:\n            # Rate limiting\n            current_time = time.time()\n            if current_time - self.last_translation_time < self.min_translation_interval:\n                return\n            \n            # Combine audio chunks\n            combined_audio = b''.join(self.audio_buffer)\n            \n            # Convert to WAV format\n            audio_content = self.convert_to_wav(combined_audio)\n            \n            # Configure speech recognition based on current language\n            config = speech.RecognitionConfig(\n                encoding=speech.RecognitionConfig.AudioEncoding.LINEAR16,\n                sample_rate_hertz=8000,\n                language_code=self.current_language,\n                alternative_language_codes=[\"hi-IN\", \"en-US\"] if self.current_language == \"hi-IN\" else [\"en-US\", \"hi-IN\"],\n                enable_automatic_punctuation=True,\n                model=\"latest_long\"\n            )\n            \n            audio = speech.RecognitionAudio(content=audio_content)\n            \n            # Perform speech recognition\n            response = self.speech_client.recognize(config=config, audio=audio)\n            \n            if response.results:\n                result = response.results[0]\n                if result.is_final:\n                    transcript = result.alternatives[0].transcript\n                    confidence = result.alternatives[0].confidence\n                    \n                    if confidence > 0.6:  # Process results with decent confidence\n                        self.last_translation_time = current_time\n                        await self.translate_and_speak(transcript)\n                        \n        except Exception as e:\n            print(f\"Speech recognition error: {e}\")\n    \n    def convert_to_wav(self, audio_data):\n        \"\"\"Convert raw audio to WAV format\"\"\"\n        try:\n            # Create a simple WAV header for 8kHz, 16-bit, mono\n            sample_rate = 8000\n            channels = 1\n            bits_per_sample = 16\n            \n            # Calculate WAV file size\n            data_size = len(audio_data)\n            file_size = 36 + data_size\n            \n            # WAV header\n            wav_header = bytearray()\n            wav_header.extend(b'RIFF')\n            wav_header.extend(file_size.to_bytes(4, 'little'))\n            wav_header.extend(b'WAVE')\n            wav_header.extend(b'fmt ')\n            wav_header.extend((16).to_bytes(4, 'little'))  # fmt chunk size\n            wav_header.extend((1).to_bytes(2, 'little'))   # audio format (PCM)\n            wav_header.extend(channels.to_bytes(2, 'little'))\n            wav_header.extend(sample_rate.to_bytes(4, 'little'))\n            wav_header.extend((sample_rate * channels * bits_per_sample // 8).to_bytes(4, 'little'))\n            wav_header.extend((channels * bits_per_sample // 8).to_bytes(2, 'little'))\n            wav_header.extend(bits_per_sample.to_bytes(2, 'little'))\n            wav_header.extend(b'data')\n            wav_header.extend(data_size.to_bytes(4, 'little'))\n            \n            return bytes(wav_header) + audio_data\n            \n        except Exception as e:\n            print(f\"WAV conversion error: {e}\")\n            return audio_data\n    \n    async def translate_and_speak(self, text):\n        \"\"\"Translate text and synthesize speech\"\"\"\n        if not self.google_cloud_ready:\n            return\n            \n        try:\n            print(f\"Processing: {text}\")\n            \n            # Detect language and translate\n            if self.current_language == \"hi-IN\":\n                # Hindi to English\n                translated_text = self.translate_client.translate(text, target_language='en')['translatedText']\n                target_language = \"en-US\"\n                print(f\"Hindi: {text} ‚Üí English: {translated_text}\")\n            else:\n                # English to Hindi\n                translated_text = self.translate_client.translate(text, target_language='hi')['translatedText']\n                target_language = \"hi-IN\"\n                print(f\"English: {text} ‚Üí Hindi: {translated_text}\")\n            \n            # Synthesize speech\n            synthesis_input = texttospeech.SynthesisInput(text=translated_text)\n            voice = texttospeech.VoiceSelectionParams(\n                language_code=target_language,\n                ssml_gender=texttospeech.SsmlVoiceGender.FEMALE\n            )\n            audio_config = texttospeech.AudioConfig(\n                audio_encoding=texttospeech.AudioEncoding.MULAW,\n                sample_rate_hertz=8000\n            )\n            \n            response = self.tts_client.synthesize_speech(\n                input=synthesis_input,\n                voice=voice,\n                audio_config=audio_config\n            )\n            \n            # Send audio back to Twilio\n            if self.websocket:\n                audio_b64 = base64.b64encode(response.audio_content).decode('utf-8')\n                await self.websocket.send(json.dumps({\n                    \"event\": \"media\",\n                    \"streamSid\": \"your-stream-sid\",\n                    \"media\": {\n                        \"payload\": audio_b64\n                    }\n                }))\n                \n                # Switch language for next detection\n                self.current_language = \"en-US\" if self.current_language == \"hi-IN\" else \"hi-IN\"\n                print(f\"Switched to language: {self.current_language}\")\n                \n        except Exception as e:\n            print(f\"Translation/synthesis error: {e}\")\n\nasync def twilio_websocket(websocket, path):\n    \"\"\"Handle Twilio WebSocket connections\"\"\"\n    try:\n        print(f\"WebSocket connection established: {websocket.remote_address}\")\n        \n        # Get call SID from query parameters\n        call_sid = None\n        if '?' in path:\n            params = path.split('?')[1]\n            for param in params.split('&'):\n                if param.startswith('CallSid='):\n                    call_sid = param.split('=')[1]\n                    break\n        \n        if not call_sid:\n            print(\"No CallSid provided\")\n            await websocket.close()\n            return\n        \n        # Create or get call session\n        if call_sid not in active_calls:\n            active_calls[call_sid] = VoiceTranslationSession(call_sid)\n        \n        session = active_calls[call_sid]\n        session.websocket = websocket\n        \n        # Send start message\n        await websocket.send(json.dumps({\n            \"event\": \"start\",\n            \"sequenceNumber\": \"1\",\n            \"start\": {\n                \"accountSid\": \"your-account-sid\",\n                \"callSid\": call_sid,\n                \"tracks\": [\"inbound\", \"outbound\"],\n                \"mediaFormat\": {\n                    \"encoding\": \"audio/x-mulaw\",\n                    \"sampleRate\": 8000,\n                    \"channels\": 1\n                },\n                \"streamSid\": \"your-stream-sid\"\n            }\n        }))\n        \n        # Handle incoming messages\n        async for message in websocket:\n            try:\n                data = json.loads(message)\n                \n                if data.get(\"event\") == \"media\":\n                    media_data = data.get(\"media\", {}).get(\"payload\", \"\")\n                    if media_data:\n                        await session.handle_audio(media_data)\n                        \n            except json.JSONDecodeError:\n                print(\"Invalid JSON received\")\n            except Exception as e:\n                print(f\"Message handling error: {e}\")\n                \n    except websockets.exceptions.ConnectionClosed:\n        print(\"WebSocket connection closed\")\n    except Exception as e:\n        print(f\"WebSocket error: {e}\")\n    finally:\n        # Clean up\n        if call_sid and call_sid in active_calls:\n            del active_calls[call_sid]\n\n# Flask app for HTTP webhooks\napp = Flask(__name__)\n\n@app.route('/health')\ndef health_check():\n    \"\"\"Health check endpoint for Railway\"\"\"\n    status = {\n        \"status\": \"healthy\", \n        \"service\": \"twilio-voice-translator\",\n        \"google_cloud_available\": GOOGLE_CLOUD_AVAILABLE,\n        \"port\": os.environ.get('PORT', 'not_set'),\n        \"timestamp\": time.time(),\n        \"version\": \"5.0-voice-translation\",\n        \"active_calls\": len(active_calls)\n    }\n    return status, 200\n\n@app.route('/')\ndef home():\n    \"\"\"Home endpoint\"\"\"\n    return {\n        \"message\": \"Twilio Voice Translator is running!\",\n        \"health_check\": \"/health\",\n        \"webhook\": \"/twilio-webhook\",\n        \"google_cloud_available\": GOOGLE_CLOUD_AVAILABLE,\n        \"version\": \"5.0-voice-translation\",\n        \"features\": [\n            \"Real-time voice translation\",\n            \"Hindi ‚Üî English translation\",\n            \"Google Cloud Speech-to-Text\",\n            \"Google Cloud Text-to-Speech\",\n            \"Google Cloud Translation\"\n        ]\n    }, 200\n\n@app.route('/twilio-webhook', methods=['POST'])\ndef twilio_webhook():\n    \"\"\"Handle incoming Twilio calls\"\"\"\n    call_sid = request.form.get('CallSid')\n    from_number = request.form.get('From')\n    to_number = request.form.get('To')\n    \n    print(f\"Incoming call from {from_number} to {to_number} (CallSid: {call_sid})\")\n    \n    # Get the Railway domain from environment variable\n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    if railway_domain == 'your-railway-app.railway.app':\n        # Fallback to Railway's default domain format\n        railway_domain = os.environ.get('RAILWAY_STATIC_URL', 'web-production-6577e.up.railway.app')\n    \n    # TwiML response to start media stream\n    twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <Response>\n        <Start>\n            <Stream url=\"wss://{railway_domain}/websocket?CallSid={call_sid}\">\n                <Parameter name=\"CallSid\" value=\"{call_sid}\"/>\n            </Stream>\n        </Start>\n        <Say language=\"hi-IN\">‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡•Ä ‡§Ü‡§µ‡§æ‡§ú‡§º ‡§ï‡§æ ‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§ï‡§∞‡•Ç‡§Ç‡§ó‡§æ‡•§</Say>\n        <Say language=\"en-US\">Hello! I will translate your voice in real-time.</Say>\n        <Say language=\"hi-IN\">‡§Ö‡§¨ ‡§Ü‡§™ ‡§¨‡•ã‡§≤ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç‡•§ ‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡•Ä ‡§¨‡§æ‡§§ ‡§ï‡§æ ‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§ï‡§∞‡•Ç‡§Ç‡§ó‡§æ‡•§</Say>\n        <Say language=\"en-US\">You can start speaking now. I will translate your words.</Say>\n    </Response>\"\"\"\n    \n    return Response(twiml, mimetype='text/xml')\n\n@app.route('/call-status', methods=['POST'])\ndef call_status():\n    \"\"\"Handle call status updates\"\"\"\n    call_sid = request.form.get('CallSid')\n    call_status = request.form.get('CallStatus')\n    \n    print(f\"Call {call_sid} status: {call_status}\")\n    \n    if call_status == 'completed':\n        # Clean up call session\n        if call_sid in active_calls:\n            del active_calls[call_sid]\n    \n    return Response('OK', mimetype='text/plain')\n\nclass StandaloneApplication(gunicorn.app.base.BaseApplication):\n    \"\"\"Gunicorn application for Railway deployment\"\"\"\n    \n    def __init__(self, app, options=None):\n        self.options = options or {}\n        self.application = app\n        super().__init__()\n    \n    def load_config(self):\n        config = {key: value for key, value in self.options.items()\n                 if key in self.cfg.settings and value is not None}\n        for key, value in config.items():\n            self.cfg.set(key.lower(), value)\n    \n    def load(self):\n        return self.application\n\ndef run_websocket_server():\n    \"\"\"Run WebSocket server in a separate thread\"\"\"\n    async def start_websocket():\n        try:\n            # Start WebSocket server on port 8081\n            server = await websockets.serve(twilio_websocket, \"0.0.0.0\", 8081)\n            print(\"WebSocket server running on port 8081\")\n            await server.wait_closed()\n        except Exception as e:\n            print(f\"WebSocket server error: {e}\")\n    \n    # Run WebSocket server in a separate thread\n    def run_in_thread():\n        asyncio.set_event_loop(asyncio.new_event_loop())\n        asyncio.get_event_loop().run_until_complete(start_websocket())\n    \n    websocket_thread = threading.Thread(target=run_in_thread, daemon=True)\n    websocket_thread.start()\n    print(\"WebSocket server thread started\")\n\nif __name__ == \"__main__\":\n    try:\n        # Get port from Railway environment variable\n        port = int(os.environ.get('PORT', 3000))\n        print(f\"Starting Railway deployment on port {port}\")\n        print(\"=\"*70)\n        print(\"RAILWAY TWILIO VOICE TRANSLATOR - VOICE TRANSLATION\")\n        print(\"=\"*70)\n        print(\"Features:\")\n        print(\"‚úì Real-time voice translation\")\n        print(\"‚úì Hindi ‚Üî English translation\")\n        print(\"‚úì Google Cloud Speech-to-Text\")\n        print(\"‚úì Google Cloud Text-to-Speech\")\n        print(\"‚úì Google Cloud Translation\")\n        print(\"‚úì Railway cloud deployment\")\n        print(\"‚úì WebSocket media streaming\")\n        print(f\"‚úì Google Cloud available: {GOOGLE_CLOUD_AVAILABLE}\")\n        print(f\"‚úì Port: {port}\")\n        print(\"=\"*70)\n        \n        if not GOOGLE_CLOUD_AVAILABLE:\n            print(\"WARNING: Google Cloud libraries not available!\")\n            print(\"Please check your GOOGLE_APPLICATION_CREDENTIALS environment variable\")\n        \n        # Start WebSocket server in background\n        run_websocket_server()\n        \n        # Start Flask app with Gunicorn\n        options = {\n            'bind': f'0.0.0.0:{port}',\n            'workers': 1,\n            'worker_class': 'sync',\n            'worker_connections': 1000,\n            'timeout': 30,\n            'keepalive': 2,\n            'max_requests': 1000,\n            'max_requests_jitter': 100,\n            'preload_app': True,\n        }\n        \n        StandaloneApplication(app, options).run()\n        \n    except KeyboardInterrupt:\n        print(\"Server stopped by user.\")\n    except Exception as e:\n        print(f\"Server startup error: {e}\")\n        import traceback\n        traceback.print_exc()\n","size_bytes":16891},"DEPLOYMENT_INSTRUCTIONS.md":{"content":"# üöÄ Call Forwarding Deployment Instructions\n\n## ‚úÖ Your Configuration\n- **Twilio Account SID**: `YOUR_ACCOUNT_SID_HERE`\n- **Twilio Auth Token**: `YOUR_AUTH_TOKEN_HERE`\n- **Twilio Phone Number**: `+13254250468`\n- **Your Personal Number**: `+916358762776`\n\n## üìã Step-by-Step Deployment\n\n### 1. Deploy to Railway\n```bash\ngit add .\ngit commit -m \"Fix call forwarding with real credentials\"\ngit push origin main\n```\n\n### 2. Set Environment Variables in Railway\nRun the setup script:\n```bash\n./railway_env_setup.sh\n```\n\nOr manually set in Railway dashboard:\n- `TWILIO_ACCOUNT_SID` = `YOUR_ACCOUNT_SID_HERE`\n- `TWILIO_AUTH_TOKEN` = `YOUR_AUTH_TOKEN_HERE`\n- `TWILIO_PHONE_NUMBER` = `+13254250468`\n- `PORT` = `3000`\n\n### 3. Update Twilio Webhook URL\n1. Go to [Twilio Console](https://console.twilio.com/)\n2. Navigate to **Phone Numbers** ‚Üí **Manage** ‚Üí **Active Numbers**\n3. Click on your number `+13254250468`\n4. Set **Webhook URL** to: `https://your-railway-app.railway.app/twilio-webhook`\n5. Set **HTTP Method** to: `POST`\n6. Save configuration\n\n### 4. Test Call Forwarding\n1. Call `+13254250468` from any phone\n2. Call should automatically forward to `+916358762776`\n3. You should receive the call on your personal number\n\n## üîß Troubleshooting\n\n### If calls don't forward:\n1. Check Railway logs: `railway logs`\n2. Verify webhook URL is correct\n3. Ensure environment variables are set\n4. Check Twilio console for call logs\n\n### If you get \"Twilio client not available\":\n- Environment variables are not set properly\n- Run the setup script again\n\n### If calls go to voicemail:\n- Your number might be busy or unreachable\n- Check if your number is verified in Twilio\n\n## üìû How It Works\n\n1. **Someone calls** `+13254250468`\n2. **Twilio sends webhook** to your Railway app\n3. **App responds with TwiML** to forward call\n4. **Call connects** to `+916358762776`\n5. **You can talk normally** with the caller\n\n## üéØ Success Indicators\n\n- ‚úÖ Railway app shows \"Twilio configured: True\"\n- ‚úÖ Webhook URL responds with 200 status\n- ‚úÖ Calls forward to your number successfully\n- ‚úÖ You can have normal conversations\n\n## üì± Test Commands\n\n```bash\n# Check if app is running\ncurl https://your-app.railway.app/\n\n# Test webhook endpoint\ncurl -X POST https://your-app.railway.app/twilio-webhook\n\n# Check Railway logs\nrailway logs\n```\n\nYour call forwarding should work perfectly now! üéâ\n","size_bytes":2388},"simple_twilio_translator.py":{"content":"import os\nimport asyncio\nimport json\nimport base64\nimport queue\nimport threading\nimport time\nimport struct\nfrom collections import deque\nfrom flask import Flask, request, Response\nimport websockets\nfrom google.cloud import speech\nfrom google.cloud import texttospeech\nfrom google.cloud import translate_v2 as translate\n\n# Set Google Cloud credentials\nos.environ[\"GOOGLE_APPLICATION_CREDENTIALS\"] = \"/Users/apple/text_to_voice_translator/google-credentials.json\"\n\n# Global variables for managing call state\nactive_calls = {}\n\nclass SimpleCallSession:\n    def __init__(self, call_sid, stream_sid):\n        self.call_sid = call_sid\n        self.stream_sid = stream_sid\n        self.last_processed_transcript = \"\"\n        self.file_counter = 0\n        self.last_translation_time = 0\n        self.is_processing = False\n        self.translation_lock = threading.Lock()\n\n# Translation functions\ndef translate_hindi_to_english(hindi_text):\n    \"\"\"Translate Hindi text to English\"\"\"\n    try:\n        client = translate.Client()\n        result = client.translate(hindi_text, source_language='hi', target_language='en')\n        english_text = result['translatedText']\n        print(f\"Hindi ‚Üí English: {hindi_text} ‚Üí {english_text}\")\n        return english_text\n    except Exception as e:\n        print(f\"Hindi to English translation error: {e}\")\n        return None\n\ndef translate_english_to_hindi(english_text):\n    \"\"\"Translate English text to Hindi\"\"\"\n    try:\n        client = translate.Client()\n        result = client.translate(english_text, source_language='en', target_language='hi')\n        hindi_text = result['translatedText']\n        print(f\"English ‚Üí Hindi: {english_text} ‚Üí {hindi_text}\")\n        return hindi_text\n    except Exception as e:\n        print(f\"English to Hindi translation error: {e}\")\n        return None\n\n# Text-to-Speech functions\ndef synthesize_english_speech(english_text, file_counter):\n    \"\"\"Convert English text to speech\"\"\"\n    try:\n        client = texttospeech.TextToSpeechClient()\n        synthesis_input = texttospeech.SynthesisInput(text=english_text)\n        voice = texttospeech.VoiceSelectionParams(\n            language_code=\"en-US\", \n            name=\"en-US-Standard-A\"\n        )\n        audio_config = texttospeech.AudioConfig(\n            audio_encoding=texttospeech.AudioEncoding.MULAW, \n            sample_rate_hertz=8000\n        )\n\n        response = client.synthesize_speech(\n            input=synthesis_input, \n            voice=voice, \n            audio_config=audio_config\n        )\n        \n        return response.audio_content\n    except Exception as e:\n        print(f\"English Text-to-Speech error: {e}\")\n        return None\n\ndef synthesize_hindi_speech(hindi_text, file_counter):\n    \"\"\"Convert Hindi text to speech\"\"\"\n    try:\n        client = texttospeech.TextToSpeechClient()\n        synthesis_input = texttospeech.SynthesisInput(text=hindi_text)\n        voice = texttospeech.VoiceSelectionParams(\n            language_code=\"hi-IN\", \n            name=\"hi-IN-Standard-A\"\n        )\n        audio_config = texttospeech.AudioConfig(\n            audio_encoding=texttospeech.AudioEncoding.MULAW, \n            sample_rate_hertz=8000\n        )\n\n        response = client.synthesize_speech(\n            input=synthesis_input, \n            voice=voice, \n            audio_config=audio_config\n        )\n        \n        return response.audio_content\n    except Exception as e:\n        print(f\"Hindi Text-to-Speech error: {e}\")\n        return None\n\n# WebSocket handler for Twilio media stream\nasync def twilio_websocket(websocket, path):\n    print(\"New WebSocket connection established\")\n    print(f\"WebSocket path: {path}\")\n    \n    # Initialize speech client\n    speech_client = speech.SpeechClient()\n    \n    # Speech recognition configurations\n    hindi_config = speech.RecognitionConfig(\n        encoding=speech.RecognitionConfig.AudioEncoding.MULAW,\n        sample_rate_hertz=8000,\n        language_code=\"hi-IN\",\n        enable_automatic_punctuation=True\n    )\n    \n    english_config = speech.RecognitionConfig(\n        encoding=speech.RecognitionConfig.AudioEncoding.MULAW,\n        sample_rate_hertz=8000,\n        language_code=\"en-US\",\n        enable_automatic_punctuation=True\n    )\n    \n    # Call session variables\n    call_session = None\n    current_language = 'hi-IN'  # Start with Hindi detection\n    last_processed_transcript = \"\"\n    file_counter = 0\n    stream_sid = None\n    min_translation_interval = 2.0\n\n    async def stream_audio_to_speech():\n        nonlocal stream_sid, call_session, current_language, last_processed_transcript\n        nonlocal file_counter\n        \n        async for message in websocket:\n            try:\n                data = json.loads(message)\n                \n                if data['event'] == 'media':\n                    stream_sid = data['streamSid']\n                    audio_payload = data['media']['payload']\n                    \n                    # Send audio for recognition\n                    audio = base64.b64decode(audio_payload)\n                    yield speech.StreamingRecognizeRequest(audio_content=audio)\n                    \n                elif data['event'] == 'start':\n                    print(f\"Stream started: {data['streamSid']}\")\n                    stream_sid = data['streamSid']\n                    call_session = SimpleCallSession(data.get('callSid', 'unknown'), stream_sid)\n                    active_calls[stream_sid] = call_session\n                    \n                elif data['event'] == 'stop':\n                    print(\"Stream stopped\")\n                    if stream_sid in active_calls:\n                        del active_calls[stream_sid]\n                    break\n                    \n            except json.JSONDecodeError as e:\n                print(f\"JSON decode error: {e}\")\n                continue\n            except Exception as e:\n                print(f\"WebSocket message error: {e}\")\n                continue\n\n    try:\n        # Start with Hindi recognition\n        streaming_config = speech.StreamingRecognitionConfig(\n            config=hindi_config, \n            interim_results=True\n        )\n        \n        responses = speech_client.streaming_recognize(streaming_config, stream_audio_to_speech())\n        \n        async for response in responses:\n            if not response.results or not response.results[0].alternatives:\n                continue\n                \n            transcript = response.results[0].alternatives[0].transcript\n            confidence = response.results[0].alternatives[0].confidence\n            \n            # Process final results with good confidence\n            if (response.results[0].is_final and \n                transcript.strip() and \n                transcript != last_processed_transcript and\n                confidence > 0.6):\n                \n                current_time = time.time()\n                \n                # Rate limiting\n                if current_time - call_session.last_translation_time < min_translation_interval:\n                    continue\n                \n                call_session.last_translation_time = current_time\n                \n                print(f\"Final transcript ({current_language}): {transcript} (confidence: {confidence:.2f})\")\n                last_processed_transcript = transcript\n                \n                # Translate and synthesize based on detected language\n                if current_language == 'hi-IN':\n                    # Hindi speaker ‚Üí translate to English ‚Üí synthesize English\n                    english_text = translate_hindi_to_english(transcript)\n                    if english_text:\n                        file_counter += 1\n                        audio_content = synthesize_english_speech(english_text, file_counter)\n                        if audio_content and stream_sid:\n                            await websocket.send(json.dumps({\n                                'event': 'media',\n                                'streamSid': stream_sid,\n                                'media': {'payload': base64.b64encode(audio_content).decode('utf-8')}\n                            }))\n                            print(f\"Sent English translation: {english_text}\")\n                            \n                elif current_language == 'en-US':\n                    # English speaker ‚Üí translate to Hindi ‚Üí synthesize Hindi\n                    hindi_text = translate_english_to_hindi(transcript)\n                    if hindi_text:\n                        file_counter += 1\n                        audio_content = synthesize_hindi_speech(hindi_text, file_counter)\n                        if audio_content and stream_sid:\n                            await websocket.send(json.dumps({\n                                'event': 'media',\n                                'streamSid': stream_sid,\n                                'media': {'payload': base64.b64encode(audio_content).decode('utf-8')}\n                            }))\n                            print(f\"Sent Hindi translation: {hindi_text}\")\n                \n                # Switch language for next detection\n                current_language = 'en-US' if current_language == 'hi-IN' else 'hi-IN'\n                \n                # Update streaming config for next language\n                if current_language == 'hi-IN':\n                    streaming_config = speech.StreamingRecognitionConfig(\n                        config=hindi_config, \n                        interim_results=True\n                    )\n                else:\n                    streaming_config = speech.StreamingRecognitionConfig(\n                        config=english_config, \n                        interim_results=True\n                    )\n                \n    except Exception as e:\n        print(f\"Streaming error: {e}\")\n    finally:\n        try:\n            await websocket.close()\n        except Exception as e:\n            print(f\"WebSocket close error: {e}\")\n\n# Flask app for HTTP webhooks\napp = Flask(__name__)\n\n@app.route('/twilio-webhook', methods=['POST'])\ndef twilio_webhook():\n    \"\"\"Handle incoming Twilio calls\"\"\"\n    call_sid = request.form.get('CallSid')\n    from_number = request.form.get('From')\n    to_number = request.form.get('To')\n    \n    print(f\"Incoming call from {from_number} to {to_number} (CallSid: {call_sid})\")\n    \n    # TwiML response to start media stream\n    twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <Response>\n        <Start>\n            <Stream url=\"wss://2c4769e21ae0.ngrok-free.app/websocket\" />\n        </Start>\n        <Say language=\"hi-IN\">‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§∏‡•á‡§µ‡§æ ‡§§‡•à‡§Ø‡§æ‡§∞ ‡§π‡•à‡•§</Say>\n        <Say language=\"en-US\">Hello! Translation service is ready.</Say>\n        <Pause length=\"1\"/>\n    </Response>\"\"\"\n    \n    return Response(twiml, mimetype='text/xml')\n\n@app.route('/call-status', methods=['POST'])\ndef call_status():\n    \"\"\"Handle call status updates\"\"\"\n    call_sid = request.form.get('CallSid')\n    call_status = request.form.get('CallStatus')\n    \n    print(f\"Call {call_sid} status: {call_status}\")\n    \n    if call_status == 'completed':\n        # Clean up call session\n        for stream_sid, session in list(active_calls.items()):\n            if session.call_sid == call_sid:\n                del active_calls[stream_sid]\n                break\n    \n    return Response('OK', mimetype='text/plain')\n\n# Start servers\nasync def start_servers():\n    if not os.path.exists(\"/Users/apple/text_to_voice_translator/google-credentials.json\"):\n        print(\"Error: google-credentials.json not found.\")\n        return\n\n    # Start Flask in a separate thread\n    def run_flask():\n        app.run(host='0.0.0.0', port=3000, debug=False, use_reloader=False)\n    \n    flask_thread = threading.Thread(target=run_flask, daemon=True)\n    flask_thread.start()\n    print(\"Flask server running on port 3000\")\n\n    # Start WebSocket server on port 8080\n    try:\n        start_server = websockets.serve(twilio_websocket, '0.0.0.0', 8080)\n        await start_server\n        print(\"WebSocket server running on port 8080\")\n        print(\"\\n\" + \"=\"*70)\n        print(\"SIMPLE BIDIRECTIONAL VOICE TRANSLATION SYSTEM READY\")\n        print(\"=\"*70)\n        print(\"Features:\")\n        print(\"‚úì Real-time Hindi ‚Üî English translation\")\n        print(\"‚úì Simple and reliable\")\n        print(\"‚úì Automatic language switching\")\n        print(\"\\nSetup Instructions:\")\n        print(\"1. Start ngrok: ngrok http 3000\")\n        print(\"2. Start ngrok for WebSocket: ngrok tcp 8080\")\n        print(\"3. Update the WebSocket URL in the TwiML response\")\n        print(\"4. Configure your Twilio phone number webhook\")\n        print(\"5. Make a call to your Twilio number\")\n        print(\"=\"*70)\n    except Exception as e:\n        print(f\"WebSocket server error: {e}\")\n\nif __name__ == \"__main__\":\n    try:\n        asyncio.get_event_loop().run_until_complete(start_servers())\n        asyncio.get_event_loop().run_forever()\n    except KeyboardInterrupt:\n        print(\"Server stopped by user.\")\n    except Exception as e:\n        print(f\"Server startup error: {e}\")\n","size_bytes":13135},"railway_ultimate_fix.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nRailway Ultimate Fix - Working Call Forwarder\n\"\"\"\n\nfrom flask import Flask, request, Response\n\napp = Flask(__name__)\n\n@app.route('/')\ndef home():\n    return {\"status\": \"Call Forwarder Working\"}, 200\n\n@app.route('/twilio-webhook', methods=['POST'])\ndef twilio_webhook():\n    \"\"\"Handle incoming calls and forward to your number\"\"\"\n    try:\n        call_sid = request.form.get('CallSid')\n        from_number = request.form.get('From')\n        \n        print(f\"üìû CALL FROM: {from_number}\")\n        print(f\"   CallSid: {call_sid}\")\n        \n        # Simple call forwarding\n        twiml = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Response>\n    <Say voice=\"alice\" language=\"en-US\">Connecting you now.</Say>\n    <Dial>\n        <Number>+916358762776</Number>\n    </Dial>\n    <Say voice=\"alice\" language=\"en-US\">Call ended.</Say>\n</Response>\"\"\"\n        \n        print(\"‚úÖ Forwarding call to +916358762776\")\n        return Response(twiml, mimetype='text/xml')\n        \n    except Exception as e:\n        print(f\"‚ùå Error: {e}\")\n        return Response(\"<?xml version='1.0' encoding='UTF-8'?><Response><Say>Error occurred.</Say></Response>\", mimetype='text/xml')\n\nif __name__ == \"__main__\":\n    port = int(os.environ.get('PORT', 3000))\n    print(f\"üöÄ CALL FORWARDER WORKING on port {port}\")\n    app.run(host='0.0.0.0', port=port, debug=False)","size_bytes":1368},"railway_translator.py":{"content":"import os\nimport asyncio\nimport json\nimport base64\nimport queue\nimport threading\nimport time\nimport struct\nfrom collections import deque\nfrom flask import Flask, request, Response\nimport websockets\nfrom google.cloud import speech\nfrom google.cloud import texttospeech\nfrom google.cloud import translate_v2 as translate\n\n# Set Google Cloud credentials - Railway will provide this via environment variable\n# os.environ[\"GOOGLE_APPLICATION_CREDENTIALS\"] = \"/Users/apple/text_to_voice_translator/google-credentials.json\"\n\n# Global variables for managing call state\nactive_calls = {}\n\nclass RailwayCallSession:\n    def __init__(self, call_sid, stream_sid):\n        self.call_sid = call_sid\n        self.stream_sid = stream_sid\n        self.last_processed_transcript = \"\"\n        self.file_counter = 0\n        self.last_translation_time = 0\n        self.is_processing = False\n        self.translation_lock = threading.Lock()\n\n# Translation functions\ndef translate_hindi_to_english(hindi_text):\n    \"\"\"Translate Hindi text to English\"\"\"\n    try:\n        client = translate.Client()\n        result = client.translate(hindi_text, source_language='hi', target_language='en')\n        english_text = result['translatedText']\n        print(f\"Hindi ‚Üí English: {hindi_text} ‚Üí {english_text}\")\n        return english_text\n    except Exception as e:\n        print(f\"Hindi to English translation error: {e}\")\n        return None\n\ndef translate_english_to_hindi(english_text):\n    \"\"\"Translate English text to Hindi\"\"\"\n    try:\n        client = translate.Client()\n        result = client.translate(english_text, source_language='en', target_language='hi')\n        hindi_text = result['translatedText']\n        print(f\"English ‚Üí Hindi: {english_text} ‚Üí {hindi_text}\")\n        return hindi_text\n    except Exception as e:\n        print(f\"English to Hindi translation error: {e}\")\n        return None\n\n# Text-to-Speech functions\ndef synthesize_english_speech(english_text, file_counter):\n    \"\"\"Convert English text to speech\"\"\"\n    try:\n        client = texttospeech.TextToSpeechClient()\n        synthesis_input = texttospeech.SynthesisInput(text=english_text)\n        voice = texttospeech.VoiceSelectionParams(\n            language_code=\"en-US\", \n            name=\"en-US-Standard-A\"\n        )\n        audio_config = texttospeech.AudioConfig(\n            audio_encoding=texttospeech.AudioEncoding.MULAW, \n            sample_rate_hertz=8000\n        )\n\n        response = client.synthesize_speech(\n            input=synthesis_input, \n            voice=voice, \n            audio_config=audio_config\n        )\n        \n        return response.audio_content\n    except Exception as e:\n        print(f\"English Text-to-Speech error: {e}\")\n        return None\n\ndef synthesize_hindi_speech(hindi_text, file_counter):\n    \"\"\"Convert Hindi text to speech\"\"\"\n    try:\n        client = texttospeech.TextToSpeechClient()\n        synthesis_input = texttospeech.SynthesisInput(text=hindi_text)\n        voice = texttospeech.VoiceSelectionParams(\n            language_code=\"hi-IN\", \n            name=\"hi-IN-Standard-A\"\n        )\n        audio_config = texttospeech.AudioConfig(\n            audio_encoding=texttospeech.AudioEncoding.MULAW, \n            sample_rate_hertz=8000\n        )\n\n        response = client.synthesize_speech(\n            input=synthesis_input, \n            voice=voice, \n            audio_config=audio_config\n        )\n        \n        return response.audio_content\n    except Exception as e:\n        print(f\"Hindi Text-to-Speech error: {e}\")\n        return None\n\n# WebSocket handler for Twilio media stream\nasync def twilio_websocket(websocket, path):\n    print(\"New WebSocket connection established\")\n    print(f\"WebSocket path: {path}\")\n    \n    # Initialize speech client\n    speech_client = speech.SpeechClient()\n    \n    # Speech recognition configurations\n    hindi_config = speech.RecognitionConfig(\n        encoding=speech.RecognitionConfig.AudioEncoding.MULAW,\n        sample_rate_hertz=8000,\n        language_code=\"hi-IN\",\n        enable_automatic_punctuation=True\n    )\n    \n    english_config = speech.RecognitionConfig(\n        encoding=speech.RecognitionConfig.AudioEncoding.MULAW,\n        sample_rate_hertz=8000,\n        language_code=\"en-US\",\n        enable_automatic_punctuation=True\n    )\n    \n    # Call session variables\n    call_session = None\n    current_language = 'hi-IN'  # Start with Hindi detection\n    last_processed_transcript = \"\"\n    file_counter = 0\n    stream_sid = None\n    min_translation_interval = 2.0\n\n    async def stream_audio_to_speech():\n        nonlocal stream_sid, call_session, current_language, last_processed_transcript\n        nonlocal file_counter\n        \n        async for message in websocket:\n            try:\n                data = json.loads(message)\n                \n                if data['event'] == 'media':\n                    stream_sid = data['streamSid']\n                    audio_payload = data['media']['payload']\n                    \n                    # Send audio for recognition\n                    audio = base64.b64decode(audio_payload)\n                    yield speech.StreamingRecognizeRequest(audio_content=audio)\n                    \n                elif data['event'] == 'start':\n                    print(f\"Stream started: {data['streamSid']}\")\n                    stream_sid = data['streamSid']\n                    call_session = RailwayCallSession(data.get('callSid', 'unknown'), stream_sid)\n                    active_calls[stream_sid] = call_session\n                    \n                elif data['event'] == 'stop':\n                    print(\"Stream stopped\")\n                    if stream_sid in active_calls:\n                        del active_calls[stream_sid]\n                    break\n                    \n            except json.JSONDecodeError as e:\n                print(f\"JSON decode error: {e}\")\n                continue\n            except Exception as e:\n                print(f\"WebSocket message error: {e}\")\n                continue\n\n    try:\n        # Start with Hindi recognition\n        streaming_config = speech.StreamingRecognitionConfig(\n            config=hindi_config, \n            interim_results=True\n        )\n        \n        responses = speech_client.streaming_recognize(streaming_config, stream_audio_to_speech())\n        \n        async for response in responses:\n            if not response.results or not response.results[0].alternatives:\n                continue\n                \n            transcript = response.results[0].alternatives[0].transcript\n            confidence = response.results[0].alternatives[0].confidence\n            \n            # Process final results with good confidence\n            if (response.results[0].is_final and \n                transcript.strip() and \n                transcript != last_processed_transcript and\n                confidence > 0.6):\n                \n                current_time = time.time()\n                \n                # Rate limiting\n                if current_time - call_session.last_translation_time < min_translation_interval:\n                    continue\n                \n                call_session.last_translation_time = current_time\n                \n                print(f\"Final transcript ({current_language}): {transcript} (confidence: {confidence:.2f})\")\n                last_processed_transcript = transcript\n                \n                # Translate and synthesize based on detected language\n                if current_language == 'hi-IN':\n                    # Hindi speaker ‚Üí translate to English ‚Üí synthesize English\n                    english_text = translate_hindi_to_english(transcript)\n                    if english_text:\n                        file_counter += 1\n                        audio_content = synthesize_english_speech(english_text, file_counter)\n                        if audio_content and stream_sid:\n                            await websocket.send(json.dumps({\n                                'event': 'media',\n                                'streamSid': stream_sid,\n                                'media': {'payload': base64.b64encode(audio_content).decode('utf-8')}\n                            }))\n                            print(f\"Sent English translation: {english_text}\")\n                            \n                elif current_language == 'en-US':\n                    # English speaker ‚Üí translate to Hindi ‚Üí synthesize Hindi\n                    hindi_text = translate_english_to_hindi(transcript)\n                    if hindi_text:\n                        file_counter += 1\n                        audio_content = synthesize_hindi_speech(hindi_text, file_counter)\n                        if audio_content and stream_sid:\n                            await websocket.send(json.dumps({\n                                'event': 'media',\n                                'streamSid': stream_sid,\n                                'media': {'payload': base64.b64encode(audio_content).decode('utf-8')}\n                            }))\n                            print(f\"Sent Hindi translation: {hindi_text}\")\n                \n                # Switch language for next detection\n                current_language = 'en-US' if current_language == 'hi-IN' else 'hi-IN'\n                \n                # Update streaming config for next language\n                if current_language == 'hi-IN':\n                    streaming_config = speech.StreamingRecognitionConfig(\n                        config=hindi_config, \n                        interim_results=True\n                    )\n                else:\n                    streaming_config = speech.StreamingRecognitionConfig(\n                        config=english_config, \n                        interim_results=True\n                    )\n                \n    except Exception as e:\n        print(f\"Streaming error: {e}\")\n    finally:\n        try:\n            await websocket.close()\n        except Exception as e:\n            print(f\"WebSocket close error: {e}\")\n\n# Flask app for HTTP webhooks\napp = Flask(__name__)\n\n@app.route('/health')\ndef health_check():\n    \"\"\"Health check endpoint for Railway\"\"\"\n    return {\"status\": \"healthy\", \"service\": \"twilio-voice-translator\"}, 200\n\n@app.route('/twilio-webhook', methods=['POST'])\ndef twilio_webhook():\n    \"\"\"Handle incoming Twilio calls\"\"\"\n    call_sid = request.form.get('CallSid')\n    from_number = request.form.get('From')\n    to_number = request.form.get('To')\n    \n    print(f\"Incoming call from {from_number} to {to_number} (CallSid: {call_sid})\")\n    \n    # Get the Railway domain from environment variable\n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'your-railway-app.railway.app')\n    if railway_domain == 'your-railway-app.railway.app':\n        # Fallback to Railway's default domain format\n        railway_domain = os.environ.get('RAILWAY_STATIC_URL', 'your-railway-app.railway.app')\n    \n    # TwiML response to start media stream\n    twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <Response>\n        <Start>\n            <Stream url=\"wss://{railway_domain}/websocket\" />\n        </Start>\n        <Say language=\"hi-IN\">‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§∏‡•á‡§µ‡§æ ‡§§‡•à‡§Ø‡§æ‡§∞ ‡§π‡•à‡•§</Say>\n        <Say language=\"en-US\">Hello! Translation service is ready.</Say>\n        <Pause length=\"1\"/>\n    </Response>\"\"\"\n    \n    return Response(twiml, mimetype='text/xml')\n\n@app.route('/call-status', methods=['POST'])\ndef call_status():\n    \"\"\"Handle call status updates\"\"\"\n    call_sid = request.form.get('CallSid')\n    call_status = request.form.get('CallStatus')\n    \n    print(f\"Call {call_sid} status: {call_status}\")\n    \n    if call_status == 'completed':\n        # Clean up call session\n        for stream_sid, session in list(active_calls.items()):\n            if session.call_sid == call_sid:\n                del active_calls[stream_sid]\n                break\n    \n    return Response('OK', mimetype='text/plain')\n\n# Start servers\nasync def start_servers():\n    if not os.path.exists(\"/Users/apple/text_to_voice_translator/google-credentials.json\"):\n        print(\"Error: google-credentials.json not found.\")\n        return\n\n    # Start Flask in a separate thread\n    def run_flask():\n        port = int(os.environ.get('PORT', 3000))\n        app.run(host='0.0.0.0', port=port, debug=False, use_reloader=False)\n    \n    flask_thread = threading.Thread(target=run_flask, daemon=True)\n    flask_thread.start()\n    print(f\"Flask server running on port {os.environ.get('PORT', 3000)}\")\n\n    # Start WebSocket server on port 8080\n    try:\n        start_server = websockets.serve(twilio_websocket, '0.0.0.0', 8080)\n        await start_server\n        print(\"WebSocket server running on port 8080\")\n        print(\"\\n\" + \"=\"*70)\n        print(\"RAILWAY BIDIRECTIONAL VOICE TRANSLATION SYSTEM READY\")\n        print(\"=\"*70)\n        print(\"Features:\")\n        print(\"‚úì Real-time Hindi ‚Üî English translation\")\n        print(\"‚úì Deployed on Railway cloud platform\")\n        print(\"‚úì Permanent domain (no tunneling needed)\")\n        print(\"‚úì Professional deployment\")\n        print(\"\\nSetup Instructions:\")\n        print(\"1. Deploy to Railway\")\n        print(\"2. Set environment variables\")\n        print(\"3. Configure your Twilio phone number webhook\")\n        print(\"4. Make a call to your Twilio number\")\n        print(\"=\"*70)\n    except Exception as e:\n        print(f\"WebSocket server error: {e}\")\n\nif __name__ == \"__main__\":\n    try:\n        # Get port from Railway environment variable\n        port = int(os.environ.get('PORT', 3000))\n        print(f\"Starting Railway deployment on port {port}\")\n        \n        asyncio.get_event_loop().run_until_complete(start_servers())\n        asyncio.get_event_loop().run_forever()\n    except KeyboardInterrupt:\n        print(\"Server stopped by user.\")\n    except Exception as e:\n        print(f\"Server startup error: {e}\")\n","size_bytes":13927},"DEPLOYMENT_GUIDE.md":{"content":"# üöÄ Twilio Bidirectional Voice Translator - Deployment Guide\n\n## üéØ **Current Status: READY TO TEST!**\n\nYour system is now running with the following setup:\n\n### ‚úÖ **Active Configuration:**\n- **HTTP Tunnel**: `https://2c4769e21ae0.ngrok-free.app`\n- **WebSocket URL**: `wss://2c4769e21ae0.ngrok-free.app/websocket`\n- **Server**: Running locally with Flask + WebSocket\n- **Status**: ‚úÖ **READY FOR TESTING**\n\n---\n\n## üìû **IMMEDIATE TESTING STEPS:**\n\n### 1. **Update Twilio Webhook**\nGo to your [Twilio Console](https://console.twilio.com/):\n- Navigate to: Phone Numbers ‚Üí Manage ‚Üí Active numbers\n- Click on your phone number\n- Set webhook URL to: **`https://2c4769e21ae0.ngrok-free.app/twilio-webhook`**\n- Set HTTP method to: **POST**\n- Save configuration\n\n### 2. **Test the System**\n- Call your Twilio phone number\n- You should hear welcome messages in Hindi and English\n- The system will attempt to establish WebSocket connection\n- **Note**: Due to free ngrok limitations, WebSocket may fail, but basic functionality should work\n\n---\n\n## üîß **Available Solutions:**\n\n### **Option 1: Current Setup (Free ngrok)**\n- ‚úÖ **Cost**: Free\n- ‚úÖ **Status**: Ready to test\n- ‚ö†Ô∏è **Limitation**: WebSocket may not work due to free account limits\n- üéØ **Best for**: Testing basic functionality\n\n### **Option 2: Railway Cloud Deployment (Recommended)**\n- ‚úÖ **Cost**: Free tier available\n- ‚úÖ **Reliability**: Excellent\n- ‚úÖ **Permanent**: No tunneling needed\n- üéØ **Best for**: Production use\n\n### **Option 3: ngrok Paid Plan**\n- üí∞ **Cost**: $8/month\n- ‚úÖ **Reliability**: Excellent\n- ‚úÖ **Features**: Multiple tunnels, custom domains\n- üéØ **Best for**: Professional development\n\n---\n\n## üöÄ **Railway Deployment (Recommended)**\n\n### **Step 1: Prepare for Deployment**\n```bash\n# Your code is already committed to git\ngit status  # Should show clean working directory\n```\n\n### **Step 2: Deploy to Railway**\n1. Go to [railway.app](https://railway.app)\n2. Sign up with GitHub\n3. Click \"New Project\"\n4. Select \"Deploy from GitHub repo\"\n5. Choose your repository\n6. Railway will automatically deploy\n\n### **Step 3: Configure Environment Variables**\nIn Railway dashboard, add these environment variables:\n- `GOOGLE_APPLICATION_CREDENTIALS`: Upload your Google credentials JSON\n- `PORT`: 3000 (Railway will set this automatically)\n\n### **Step 4: Update Twilio Webhook**\n- Railway will provide a permanent URL like: `https://your-app.railway.app`\n- Update your Twilio webhook to: `https://your-app.railway.app/twilio-webhook`\n\n---\n\n## üß™ **Testing Your System**\n\n### **Expected Behavior:**\n1. **Call connects** ‚Üí Welcome messages play\n2. **WebSocket establishes** ‚Üí Real-time translation begins\n3. **You speak English** ‚Üí Other person hears Hindi\n4. **Other person speaks Hindi** ‚Üí You hear English\n\n### **Troubleshooting:**\n- **Call disconnects after welcome**: WebSocket connection failed\n- **No translation**: Check Google Cloud credentials\n- **Audio issues**: Check Twilio account credits\n\n---\n\n## üìä **System Architecture**\n\n```\nTwilio Call ‚Üí ngrok Tunnel ‚Üí Flask Server ‚Üí WebSocket Server\n                ‚Üì\n            Google Cloud APIs:\n            - Speech-to-Text\n            - Translation\n            - Text-to-Speech\n```\n\n---\n\n## üéâ **Success Indicators**\n\n‚úÖ **Call connects successfully**\n‚úÖ **Welcome messages play**\n‚úÖ **WebSocket connection established**\n‚úÖ **Real-time translation works**\n‚úÖ **Bidirectional communication**\n\n---\n\n## üìû **Next Steps**\n\n1. **Test current setup** with the ngrok URL\n2. **If WebSocket fails**, deploy to Railway\n3. **For production**, use Railway or ngrok paid plan\n4. **Monitor logs** for any issues\n\n---\n\n## üÜò **Support**\n\nIf you encounter issues:\n1. Check server logs in terminal\n2. Verify Google Cloud credentials\n3. Ensure Twilio webhook is configured correctly\n4. Check ngrok tunnel status\n\n**Your system is ready to test! üéä**\n","size_bytes":3931},"railway_final_working.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nRailway Deployment - Final Working Voice Translation\nSIMPLIFIED: Shorter responses, better audio\n\"\"\"\n\nimport os\nimport json\nimport time\nimport warnings\nimport requests\nfrom flask import Flask, request, Response\nimport gunicorn.app.base\n\n# Suppress pkg_resources deprecation warnings\nwarnings.filterwarnings(\"ignore\", message=\"pkg_resources is deprecated\")\nwarnings.filterwarnings(\"ignore\", category=UserWarning, module=\"google.cloud.translate_v2\")\n\n# Set up Google Cloud credentials properly\ndef setup_google_credentials():\n    \"\"\"Set up Google Cloud credentials from environment variable\"\"\"\n    try:\n        # Check if GOOGLE_CREDENTIALS_JSON is set (Railway environment variable)\n        creds_json = os.environ.get('GOOGLE_CREDENTIALS_JSON')\n        if creds_json:\n            try:\n                # Parse the JSON to validate it\n                creds_data = json.loads(creds_json)\n                # Write to a temporary file\n                temp_creds_path = '/tmp/google-credentials.json'\n                with open(temp_creds_path, 'w') as f:\n                    json.dump(creds_data, f)\n                os.environ['GOOGLE_APPLICATION_CREDENTIALS'] = temp_creds_path\n                print(f\"‚úÖ Using credentials from environment variable, saved to: {temp_creds_path}\")\n                return True\n            except json.JSONDecodeError as e:\n                print(f\"‚ùå Invalid JSON in GOOGLE_CREDENTIALS_JSON: {e}\")\n                return False\n        \n        print(\"‚ùå No Google Cloud credentials found\")\n        return False\n        \n    except Exception as e:\n        print(f\"‚ùå Error setting up Google Cloud credentials: {e}\")\n        return False\n\n# Set up credentials\ncredentials_setup = setup_google_credentials()\n\n# Try to import Google Cloud libraries with error handling\ntry:\n    from google.cloud import speech\n    from google.cloud import texttospeech\n    from google.cloud import translate_v2 as translate\n    GOOGLE_CLOUD_AVAILABLE = True\n    print(\"‚úÖ Google Cloud libraries imported successfully\")\nexcept ImportError as e:\n    print(f\"‚ùå Google Cloud libraries not available: {e}\")\n    GOOGLE_CLOUD_AVAILABLE = False\n\n# Flask app for HTTP webhooks\napp = Flask(__name__)\n\n@app.route('/health')\ndef health_check():\n    \"\"\"Health check endpoint for Railway\"\"\"\n    status = {\n        \"status\": \"healthy\", \n        \"service\": \"twilio-voice-translator\",\n        \"google_cloud_available\": GOOGLE_CLOUD_AVAILABLE,\n        \"credentials_setup\": credentials_setup,\n        \"port\": os.environ.get('PORT', 'not_set'),\n        \"timestamp\": time.time(),\n        \"version\": \"14.0-final-working\"\n    }\n    return status, 200\n\n@app.route('/')\ndef home():\n    \"\"\"Home endpoint\"\"\"\n    return {\n        \"message\": \"Twilio Voice Translator is running!\",\n        \"health_check\": \"/health\",\n        \"webhook\": \"/twilio-webhook\",\n        \"transcription_webhook\": \"/transcription-webhook\",\n        \"google_cloud_available\": GOOGLE_CLOUD_AVAILABLE,\n        \"credentials_setup\": credentials_setup,\n        \"version\": \"14.0-final-working\",\n        \"features\": [\n            \"Final working translation\",\n            \"Simplified responses\",\n            \"Hindi ‚Üî English translation\",\n            \"Google Cloud Translation\"\n        ]\n    }, 200\n\n@app.route('/twilio-webhook', methods=['POST'])\ndef twilio_webhook():\n    \"\"\"Handle incoming Twilio calls\"\"\"\n    call_sid = request.form.get('CallSid')\n    from_number = request.form.get('From')\n    to_number = request.form.get('To')\n    \n    print(f\"\\nüìû INCOMING CALL:\")\n    print(f\"   From: {from_number}\")\n    print(f\"   To: {to_number}\")\n    print(f\"   CallSid: {call_sid}\")\n    print(\"=\"*50)\n    \n    # Get the Railway domain from environment variable\n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    if railway_domain == 'your-railway-app.railway.app':\n        # Fallback to Railway's default domain format\n        railway_domain = os.environ.get('RAILWAY_STATIC_URL', 'web-production-6577e.up.railway.app')\n    \n    # SIMPLIFIED TwiML response\n    twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <Response>\n        <Say voice=\"alice\" language=\"en-US\">Hello! I will translate your voice. Please speak now.</Say>\n        <Record \n            action=\"https://{railway_domain}/transcription-webhook\" \n            method=\"POST\"\n            transcribe=\"true\"\n            transcribeCallback=\"https://{railway_domain}/transcription-webhook\"\n            maxLength=\"10\"\n            timeout=\"5\"\n            playBeep=\"true\"\n            finishOnKey=\"#\"\n        />\n    </Response>\"\"\"\n    \n    return Response(twiml, mimetype='text/xml')\n\n@app.route('/transcription-webhook', methods=['POST'])\ndef transcription_webhook():\n    \"\"\"Handle transcription results and provide translation\"\"\"\n    call_sid = request.form.get('CallSid')\n    transcription_text = request.form.get('TranscriptionText', '')\n    transcription_status = request.form.get('TranscriptionStatus', '')\n    recording_url = request.form.get('RecordingUrl', '')\n    recording_duration = request.form.get('RecordingDuration', '0')\n    \n    print(f\"\\nüé§ TRANSCRIPTION WEBHOOK CALLED:\")\n    print(f\"   CallSid: {call_sid}\")\n    print(f\"   Status: {transcription_status}\")\n    print(f\"   Text: '{transcription_text}'\")\n    print(f\"   Duration: {recording_duration} seconds\")\n    print(f\"   Recording URL: {recording_url}\")\n    print(\"=\"*50)\n    \n    # Get the Railway domain\n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    \n    if not transcription_text:\n        # Fallback response if no transcription\n        print(\"‚ùå No transcription available, providing fallback response\")\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"en-US\">I couldn't understand. Please speak again.</Say>\n            <Record \n                action=\"https://{railway_domain}/transcription-webhook\" \n                method=\"POST\"\n                transcribe=\"true\"\n                transcribeCallback=\"https://{railway_domain}/transcription-webhook\"\n                maxLength=\"10\"\n                timeout=\"5\"\n                playBeep=\"true\"\n                finishOnKey=\"#\"\n            />\n        </Response>\"\"\"\n        return Response(twiml, mimetype='text/xml')\n    \n    try:\n        # Detect language and translate\n        detected_language = detect_language(transcription_text)\n        print(f\"üåç Detected language: {detected_language}\")\n        \n        if detected_language == \"hi\":\n            # Hindi to English\n            translated_text = translate_text(transcription_text, 'hi', 'en')\n            target_language = \"en-US\"\n            print(f\"üîÑ TRANSLATION:\")\n            print(f\"   Hindi: '{transcription_text}'\")\n            print(f\"   English: '{translated_text}'\")\n        else:\n            # English to Hindi\n            translated_text = translate_text(transcription_text, 'en', 'hi')\n            target_language = \"hi-IN\"\n            print(f\"üîÑ TRANSLATION:\")\n            print(f\"   English: '{transcription_text}'\")\n            print(f\"   Hindi: '{translated_text}'\")\n        \n        print(f\"üîä SPEAKING RESPONSE:\")\n        print(f\"   'You said: {transcription_text}'\")\n        print(f\"   'Translation: {translated_text}'\")\n        print(\"=\"*50)\n        \n        # SIMPLIFIED TwiML response - shorter and clearer\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"en-US\">You said: {transcription_text}</Say>\n            <Pause length=\"1\"/>\n            <Say voice=\"alice\" language=\"{target_language}\">Translation: {translated_text}</Say>\n            <Pause length=\"1\"/>\n            <Say voice=\"alice\" language=\"en-US\">Say something else or hang up.</Say>\n            <Record \n                action=\"https://{railway_domain}/transcription-webhook\" \n                method=\"POST\"\n                transcribe=\"true\"\n                transcribeCallback=\"https://{railway_domain}/transcription-webhook\"\n                maxLength=\"10\"\n                timeout=\"5\"\n                playBeep=\"true\"\n                finishOnKey=\"#\"\n            />\n        </Response>\"\"\"\n        \n        return Response(twiml, mimetype='text/xml')\n        \n    except Exception as e:\n        print(f\"‚ùå Translation error: {e}\")\n        # Error response\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"en-US\">Translation error. Please try again.</Say>\n            <Record \n                action=\"https://{railway_domain}/transcription-webhook\" \n                method=\"POST\"\n                transcribe=\"true\"\n                transcribeCallback=\"https://{railway_domain}/transcription-webhook\"\n                maxLength=\"10\"\n                timeout=\"5\"\n                playBeep=\"true\"\n                finishOnKey=\"#\"\n            />\n        </Response>\"\"\"\n        return Response(twiml, mimetype='text/xml')\n\ndef detect_language(text):\n    \"\"\"Simple language detection\"\"\"\n    # Simple heuristic: if text contains Devanagari characters, it's Hindi\n    devanagari_chars = set('‡§Ö‡§Ü‡§á‡§à‡§â‡§ä‡§ã‡§è‡§ê‡§ì‡§î‡§ï‡§ñ‡§ó‡§ò‡§ô‡§ö‡§õ‡§ú‡§ù‡§û‡§ü‡§†‡§°‡§¢‡§£‡§§‡§•‡§¶‡§ß‡§®‡§™‡§´‡§¨‡§≠‡§Æ‡§Ø‡§∞‡§≤‡§µ‡§∂‡§∑‡§∏‡§π')\n    if any(char in devanagari_chars for char in text):\n        return \"hi\"\n    return \"en\"\n\ndef translate_text(text, source_lang, target_lang):\n    \"\"\"Translate text using Google Cloud Translation\"\"\"\n    try:\n        print(f\"üîÑ Calling Google Translate API...\")\n        print(f\"   Source: {source_lang}\")\n        print(f\"   Target: {target_lang}\")\n        print(f\"   Text: '{text}'\")\n        \n        # Initialize the translate client with proper credentials\n        client = translate.Client()\n        result = client.translate(text, source_language=source_lang, target_language=target_lang)\n        \n        translated_text = result['translatedText']\n        print(f\"‚úÖ Translation successful: '{translated_text}'\")\n        return translated_text\n        \n    except Exception as e:\n        print(f\"‚ùå Translation error: {e}\")\n        print(f\"   Returning original text: '{text}'\")\n        # Return original text if translation fails\n        return text\n\nclass StandaloneApplication(gunicorn.app.base.BaseApplication):\n    \"\"\"Gunicorn application for Railway deployment\"\"\"\n    \n    def __init__(self, app, options=None):\n        self.options = options or {}\n        self.application = app\n        super().__init__()\n    \n    def load_config(self):\n        config = {key: value for key, value in self.options.items()\n                 if key in self.cfg.settings and value is not None}\n        for key, value in config.items():\n            self.cfg.set(key.lower(), value)\n    \n    def load(self):\n        return self.application\n\nif __name__ == \"__main__\":\n    try:\n        # Get port from Railway environment variable\n        port = int(os.environ.get('PORT', 3000))\n        print(f\"üöÄ Starting Railway deployment on port {port}\")\n        print(\"=\"*70)\n        print(\"üéØ RAILWAY TWILIO VOICE TRANSLATOR - FINAL WORKING\")\n        print(\"=\"*70)\n        print(\"‚úÖ Features:\")\n        print(\"   ‚úì Final working translation\")\n        print(\"   ‚úì Simplified responses\")\n        print(\"   ‚úì Hindi ‚Üî English translation\")\n        print(\"   ‚úì Google Cloud Translation\")\n        print(\"   ‚úì Railway cloud deployment\")\n        print(\"   ‚úì Better error handling\")\n        print(\"   ‚úì Shorter, clearer audio responses\")\n        print(f\"   ‚úì Google Cloud available: {GOOGLE_CLOUD_AVAILABLE}\")\n        print(f\"   ‚úì Credentials setup: {credentials_setup}\")\n        print(f\"   ‚úì Port: {port}\")\n        print(\"=\"*70)\n        \n        if not GOOGLE_CLOUD_AVAILABLE:\n            print(\"‚ö†Ô∏è  WARNING: Google Cloud libraries not available!\")\n            print(\"   Please check your GOOGLE_APPLICATION_CREDENTIALS environment variable\")\n        \n        if not credentials_setup:\n            print(\"‚ö†Ô∏è  WARNING: Google Cloud credentials not properly set up!\")\n            print(\"   Please check your GOOGLE_CREDENTIALS_JSON environment variable\")\n        \n        # Start Flask app with Gunicorn\n        options = {\n            'bind': f'0.0.0.0:{port}',\n            'workers': 1,\n            'worker_class': 'sync',\n            'worker_connections': 1000,\n            'timeout': 30,\n            'keepalive': 2,\n            'max_requests': 1000,\n            'max_requests_jitter': 100,\n            'preload_app': True,\n        }\n        \n        StandaloneApplication(app, options).run()\n        \n    except KeyboardInterrupt:\n        print(\"üõë Server stopped by user.\")\n    except Exception as e:\n        print(f\"‚ùå Server startup error: {e}\")\n        import traceback\n        traceback.print_exc()\n","size_bytes":12860},"single_port_translator.py":{"content":"import os\nimport asyncio\nimport json\nimport base64\nimport queue\nimport threading\nimport time\nimport struct\nfrom collections import deque\nfrom flask import Flask, request, Response\nfrom flask_socketio import SocketIO, emit\nfrom google.cloud import speech\nfrom google.cloud import texttospeech\nfrom google.cloud import translate_v2 as translate\n\n# Set Google Cloud credentials\nos.environ[\"GOOGLE_APPLICATION_CREDENTIALS\"] = \"/Users/apple/text_to_voice_translator/google-credentials.json\"\n\n# Global variables for managing call state\nactive_calls = {}\n\nclass SinglePortCallSession:\n    def __init__(self, call_sid, stream_sid):\n        self.call_sid = call_sid\n        self.stream_sid = stream_sid\n        self.last_processed_transcript = \"\"\n        self.file_counter = 0\n        self.last_translation_time = 0\n        self.is_processing = False\n        self.translation_lock = threading.Lock()\n\n# Translation functions\ndef translate_hindi_to_english(hindi_text):\n    \"\"\"Translate Hindi text to English\"\"\"\n    try:\n        client = translate.Client()\n        result = client.translate(hindi_text, source_language='hi', target_language='en')\n        english_text = result['translatedText']\n        print(f\"Hindi ‚Üí English: {hindi_text} ‚Üí {english_text}\")\n        return english_text\n    except Exception as e:\n        print(f\"Hindi to English translation error: {e}\")\n        return None\n\ndef translate_english_to_hindi(english_text):\n    \"\"\"Translate English text to Hindi\"\"\"\n    try:\n        client = translate.Client()\n        result = client.translate(english_text, source_language='en', target_language='hi')\n        hindi_text = result['translatedText']\n        print(f\"English ‚Üí Hindi: {english_text} ‚Üí {hindi_text}\")\n        return hindi_text\n    except Exception as e:\n        print(f\"English to Hindi translation error: {e}\")\n        return None\n\n# Text-to-Speech functions\ndef synthesize_english_speech(english_text, file_counter):\n    \"\"\"Convert English text to speech\"\"\"\n    try:\n        client = texttospeech.TextToSpeechClient()\n        synthesis_input = texttospeech.SynthesisInput(text=english_text)\n        voice = texttospeech.VoiceSelectionParams(\n            language_code=\"en-US\", \n            name=\"en-US-Standard-A\"\n        )\n        audio_config = texttospeech.AudioConfig(\n            audio_encoding=texttospeech.AudioEncoding.MULAW, \n            sample_rate_hertz=8000\n        )\n\n        response = client.synthesize_speech(\n            input=synthesis_input, \n            voice=voice, \n            audio_config=audio_config\n        )\n        \n        return response.audio_content\n    except Exception as e:\n        print(f\"English Text-to-Speech error: {e}\")\n        return None\n\ndef synthesize_hindi_speech(hindi_text, file_counter):\n    \"\"\"Convert Hindi text to speech\"\"\"\n    try:\n        client = texttospeech.TextToSpeechClient()\n        synthesis_input = texttospeech.SynthesisInput(text=hindi_text)\n        voice = texttospeech.VoiceSelectionParams(\n            language_code=\"hi-IN\", \n            name=\"hi-IN-Standard-A\"\n        )\n        audio_config = texttospeech.AudioConfig(\n            audio_encoding=texttospeech.AudioEncoding.MULAW, \n            sample_rate_hertz=8000\n        )\n\n        response = client.synthesize_speech(\n            input=synthesis_input, \n            voice=voice, \n            audio_config=audio_config\n        )\n        \n        return response.audio_content\n    except Exception as e:\n        print(f\"Hindi Text-to-Speech error: {e}\")\n        return None\n\n# Flask app with SocketIO\napp = Flask(__name__)\napp.config['SECRET_KEY'] = 'your-secret-key'\nsocketio = SocketIO(app, cors_allowed_origins=\"*\")\n\n@app.route('/twilio-webhook', methods=['POST'])\ndef twilio_webhook():\n    \"\"\"Handle incoming Twilio calls\"\"\"\n    call_sid = request.form.get('CallSid')\n    from_number = request.form.get('From')\n    to_number = request.form.get('To')\n    \n    print(f\"Incoming call from {from_number} to {to_number} (CallSid: {call_sid})\")\n    \n    # TwiML response to start media stream\n    twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <Response>\n        <Start>\n            <Stream url=\"wss://e5562da11db7.ngrok-free.app/socket.io/?EIO=4&transport=websocket\" />\n        </Start>\n        <Say language=\"hi-IN\">‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§∏‡•á‡§µ‡§æ ‡§§‡•à‡§Ø‡§æ‡§∞ ‡§π‡•à‡•§</Say>\n        <Say language=\"en-US\">Hello! Translation service is ready.</Say>\n        <Pause length=\"1\"/>\n    </Response>\"\"\"\n    \n    return Response(twiml, mimetype='text/xml')\n\n@app.route('/call-status', methods=['POST'])\ndef call_status():\n    \"\"\"Handle call status updates\"\"\"\n    call_sid = request.form.get('CallSid')\n    call_status = request.form.get('CallStatus')\n    \n    print(f\"Call {call_sid} status: {call_status}\")\n    \n    if call_status == 'completed':\n        # Clean up call session\n        for stream_sid, session in list(active_calls.items()):\n            if session.call_sid == call_sid:\n                del active_calls[stream_sid]\n                break\n    \n    return Response('OK', mimetype='text/plain')\n\n@socketio.on('connect')\ndef handle_connect():\n    print('Client connected')\n\n@socketio.on('disconnect')\ndef handle_disconnect():\n    print('Client disconnected')\n\n@socketio.on('message')\ndef handle_message(data):\n    \"\"\"Handle WebSocket messages from Twilio\"\"\"\n    try:\n        if isinstance(data, str):\n            data = json.loads(data)\n        \n        if data.get('event') == 'media':\n            # Process audio data\n            stream_sid = data.get('streamSid')\n            audio_payload = data.get('media', {}).get('payload')\n            \n            if audio_payload:\n                # Here you would process the audio and send back translation\n                # For now, just acknowledge receipt\n                emit('message', {'event': 'ack', 'streamSid': stream_sid})\n                \n        elif data.get('event') == 'start':\n            stream_sid = data.get('streamSid')\n            call_sid = data.get('callSid', 'unknown')\n            print(f\"Stream started: {stream_sid}\")\n            \n            # Create call session\n            call_session = SinglePortCallSession(call_sid, stream_sid)\n            active_calls[stream_sid] = call_session\n            \n        elif data.get('event') == 'stop':\n            stream_sid = data.get('streamSid')\n            print(f\"Stream stopped: {stream_sid}\")\n            if stream_sid in active_calls:\n                del active_calls[stream_sid]\n                \n    except Exception as e:\n        print(f\"Error handling message: {e}\")\n\nif __name__ == \"__main__\":\n    print(\"=\"*70)\n    print(\"SINGLE PORT BIDIRECTIONAL VOICE TRANSLATION SYSTEM\")\n    print(\"=\"*70)\n    print(\"Features:\")\n    print(\"‚úì Real-time Hindi ‚Üî English translation\")\n    print(\"‚úì Single port (HTTP + WebSocket)\")\n    print(\"‚úì Works with free ngrok account\")\n    print(\"\\nSetup Instructions:\")\n    print(\"1. Start ngrok: ngrok http 3000\")\n    print(\"2. Update the WebSocket URL in the TwiML response\")\n    print(\"3. Configure your Twilio phone number webhook\")\n    print(\"4. Make a call to your Twilio number\")\n    print(\"=\"*70)\n    \n    socketio.run(app, host='0.0.0.0', port=3000, debug=False)\n","size_bytes":7221},"final_script.py":{"content":"import os\nimport asyncio\nimport json\nimport base64\nimport queue\nimport threading\nfrom flask import Flask, Response\nimport websockets\nfrom google.cloud import speech\nfrom google.cloud import texttospeech\nfrom google.cloud import translate_v2 as translate\n\n# Set Google Cloud credentials\nos.environ[\"GOOGLE_APPLICATION_CREDENTIALS\"] = \"/Users/apple/text_to_voice_translator/google-credentials.json\"\n\n# Audio queue for local playback (optional, for debugging)\naudio_queue = queue.Queue()\n\n# Translate Hindi to English\ndef translate_text(hindi_text):\n    try:\n        client = translate.Client()\n        result = client.translate(hindi_text, source_language='hi', target_language='en')\n        english_text = result['translatedText']\n        print(f\"Translated: {english_text}\")\n        return english_text\n    except Exception as e:\n        print(f\"Translation error: {e}\")\n        return None\n\n# Text-to-Speech (English, MULAW for Twilio)\ndef synthesize_speech(english_text, file_counter):\n    try:\n        client = texttospeech.TextToSpeechClient()\n        synthesis_input = texttospeech.SynthesisInput(text=english_text)\n        voice = texttospeech.VoiceSelectionParams(language_code=\"en-US\", name=\"en-US-Standard-A\")\n        audio_config = texttospeech.AudioConfig(audio_encoding=texttospeech.AudioEncoding.MULAW, sample_rate_hertz=8000)\n\n        response = client.synthesize_speech(input=synthesis_input, voice=voice, audio_config=audio_config)\n        \n        # Save for debugging\n        audio_file_name = f\"/Users/apple/text_to_voice_translator/output_audio_{file_counter}.wav\"\n        with open(audio_file_name, \"wb\") as audio_file:\n            audio_file.write(response.audio_content)\n            print(f\"Saved audio to {audio_file_name}\")\n\n        return response.audio_content\n    except Exception as e:\n        print(f\"Text-to-Speech error: {e}\")\n        return None\n\n# Audio playback thread (optional, for local debugging)\ndef audio_playback_thread():\n    try:\n        import pyaudio\n        p = pyaudio.PyAudio()\n        stream = p.open(format=pyaudio.paInt16, channels=1, rate=8000, output=True)\n        try:\n            while True:\n                try:\n                    audio_content = audio_queue.get(timeout=1)\n                    stream.write(audio_content)\n                    audio_queue.task_done()\n                except queue.Empty:\n                    continue\n        except KeyboardInterrupt:\n            pass\n        finally:\n            stream.stop_stream()\n            stream.close()\n            p.terminate()\n    except Exception as e:\n        print(f\"Audio playback error: {e}\")\n\n# WebSocket handler for Twilio media stream\nasync def twilio_websocket(websocket, path):\n    client = speech.SpeechClient()\n    config = speech.RecognitionConfig(\n        encoding=speech.RecognitionConfig.AudioEncoding.MULAW,\n        sample_rate_hertz=8000,\n        language_code=\"hi-IN\"\n    )\n    streaming_config = speech.StreamingRecognitionConfig(config=config, interim_results=True)\n\n    file_counter = 0\n    last_processed_transcript = \"\"\n    stream_sid = None\n\n    async def stream_audio_to_speech():\n        async for message in websocket:\n            try:\n                data = json.loads(message)\n                if data['event'] == 'media':\n                    nonlocal stream_sid\n                    stream_sid = data['streamSid']\n                    audio = base64.b64decode(data['media']['payload'])\n                    yield speech.StreamingRecognizeRequest(audio_content=audio)\n                elif data['event'] == 'start':\n                    print(f\"Stream started: {data['streamSid']}\")\n                    stream_sid = data['streamSid']\n                elif data['event'] == 'stop':\n                    print(\"Stream stopped\")\n                    break\n            except json.JSONDecodeError as e:\n                print(f\"JSON decode error: {e}\")\n                continue\n            except Exception as e:\n                print(f\"WebSocket message error: {e}\")\n                continue\n\n    try:\n        responses = client.streaming_recognize(streaming_config, stream_audio_to_speech())\n        async for response in responses:\n            if not response.results or not response.results[0].alternatives:\n                continue\n            transcript = response.results[0].alternatives[0].transcript\n            if response.results[0].is_final and transcript.strip() and transcript != last_processed_transcript:\n                print(f\"Final transcript: {transcript}\")\n                last_processed_transcript = transcript\n                english_text = translate_text(transcript)\n                if english_text:\n                    file_counter += 1\n                    audio_content = synthesize_speech(english_text, file_counter)\n                    if audio_content and stream_sid:\n                        # Send translated audio back to Twilio\n                        await websocket.send(json.dumps({\n                            'event': 'media',\n                            'streamSid': stream_sid,\n                            'media': {'payload': base64.b64encode(audio_content).decode('utf-8')}\n                        }))\n                        # Queue for local playback (optional)\n                        audio_queue.put(audio_content)\n    except Exception as e:\n        print(f\"Streaming error: {e}\")\n    finally:\n        try:\n            await websocket.close()\n        except Exception as e:\n            print(f\"WebSocket close error: {e}\")\n\n# Flask app for HTTP webhook\napp = Flask(__name__)\n\n@app.route('/twilio-webhook', methods=['POST'])\ndef twilio_webhook():\n    twiml = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <Response>\n        <Start>\n            <Stream url=\"wss://af844c11418d.ngrok-free.app/websocket\" />\n        </Start>\n        <Say>Please wait while we process your call.</Say>\n    </Response>\"\"\"\n    return Response(twiml, mimetype='text/xml')\n\n# Start servers\nasync def start_servers():\n    if not os.path.exists(\"/Users/apple/text_to_voice_translator/google-credentials.json\"):\n        print(\"Error: google-credentials.json not found.\")\n        return\n\n    # Start audio playback thread (optional)\n    playback_thread = threading.Thread(target=audio_playback_thread, daemon=True)\n    playback_thread.start()\n\n    # Start Flask in a separate thread\n    from threading import Thread\n    def run_flask():\n        app.run(host='0.0.0.0', port=3000, debug=False, use_reloader=False)\n    flask_thread = Thread(target=run_flask)\n    flask_thread.start()\n    print(\"Flask server running on port 3000\")\n\n    # Start WebSocket server\n    try:\n        start_server = websockets.serve(twilio_websocket, '0.0.0.0', 8080)\n        await start_server\n        print(\"WebSocket server running on port 8080\")\n    except Exception as e:\n        print(f\"WebSocket server error: {e}\")\n\nif __name__ == \"__main__\":\n    try:\n        asyncio.get_event_loop().run_until_complete(start_servers())\n        asyncio.get_event_loop().run_forever()\n    except KeyboardInterrupt:\n        print(\"Server stopped by user.\")\n    except Exception as e:\n        print(f\"Server startup error: {e}\")","size_bytes":7139},"railway_working_translator.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nRailway Deployment - Working Voice Translation\nFixed Google Cloud credentials and translation\n\"\"\"\n\nimport os\nimport json\nimport time\nimport warnings\nimport requests\nfrom flask import Flask, request, Response\nimport gunicorn.app.base\n\n# Suppress pkg_resources deprecation warnings\nwarnings.filterwarnings(\"ignore\", message=\"pkg_resources is deprecated\")\nwarnings.filterwarnings(\"ignore\", category=UserWarning, module=\"google.cloud.translate_v2\")\n\n# Try to import Google Cloud libraries with error handling\ntry:\n    from google.cloud import speech\n    from google.cloud import texttospeech\n    from google.cloud import translate_v2 as translate\n    GOOGLE_CLOUD_AVAILABLE = True\n    print(\"Google Cloud libraries imported successfully\")\nexcept ImportError as e:\n    print(f\"Google Cloud libraries not available: {e}\")\n    GOOGLE_CLOUD_AVAILABLE = False\n\n# Flask app for HTTP webhooks\napp = Flask(__name__)\n\n@app.route('/health')\ndef health_check():\n    \"\"\"Health check endpoint for Railway\"\"\"\n    status = {\n        \"status\": \"healthy\", \n        \"service\": \"twilio-voice-translator\",\n        \"google_cloud_available\": GOOGLE_CLOUD_AVAILABLE,\n        \"port\": os.environ.get('PORT', 'not_set'),\n        \"timestamp\": time.time(),\n        \"version\": \"11.0-working-translation\"\n    }\n    return status, 200\n\n@app.route('/')\ndef home():\n    \"\"\"Home endpoint\"\"\"\n    return {\n        \"message\": \"Twilio Voice Translator is running!\",\n        \"health_check\": \"/health\",\n        \"webhook\": \"/twilio-webhook\",\n        \"transcription_webhook\": \"/transcription-webhook\",\n        \"google_cloud_available\": GOOGLE_CLOUD_AVAILABLE,\n        \"version\": \"11.0-working-translation\",\n        \"features\": [\n            \"Fixed Google Cloud credentials\",\n            \"Hindi ‚Üî English translation\",\n            \"Google Cloud Speech-to-Text\",\n            \"Google Cloud Translation\",\n            \"Proper language voice selection\"\n        ]\n    }, 200\n\n@app.route('/twilio-webhook', methods=['POST'])\ndef twilio_webhook():\n    \"\"\"Handle incoming Twilio calls\"\"\"\n    call_sid = request.form.get('CallSid')\n    from_number = request.form.get('From')\n    to_number = request.form.get('To')\n    \n    print(f\"Incoming call from {from_number} to {to_number} (CallSid: {call_sid})\")\n    \n    # Get the Railway domain from environment variable\n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    if railway_domain == 'your-railway-app.railway.app':\n        # Fallback to Railway's default domain format\n        railway_domain = os.environ.get('RAILWAY_STATIC_URL', 'web-production-6577e.up.railway.app')\n    \n    # TwiML response with improved recording\n    twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <Response>\n        <Say voice=\"alice\" language=\"hi-IN\">‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡•Ä ‡§Ü‡§µ‡§æ‡§ú‡§º ‡§ï‡§æ ‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§ï‡§∞‡•Ç‡§Ç‡§ó‡§æ‡•§</Say>\n        <Say voice=\"alice\" language=\"en-US\">Hello! I will translate your voice.</Say>\n        <Say voice=\"alice\" language=\"hi-IN\">‡§Ö‡§¨ ‡§Ü‡§™ ‡§¨‡•ã‡§≤ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç‡•§</Say>\n        <Say voice=\"alice\" language=\"en-US\">You can start speaking now.</Say>\n        <Record \n            action=\"https://{railway_domain}/transcription-webhook\" \n            method=\"POST\"\n            transcribe=\"true\"\n            transcribeCallback=\"https://{railway_domain}/transcription-webhook\"\n            maxLength=\"15\"\n            timeout=\"10\"\n            playBeep=\"true\"\n            finishOnKey=\"#\"\n            recordingStatusCallback=\"https://{railway_domain}/recording-status\"\n        />\n        <Say voice=\"alice\" language=\"hi-IN\">‡§ß‡§®‡•ç‡§Ø‡§µ‡§æ‡§¶! ‡§Ü‡§™‡§ï‡§æ ‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§§‡•à‡§Ø‡§æ‡§∞ ‡§π‡•à‡•§</Say>\n        <Say voice=\"alice\" language=\"en-US\">Thank you! Your translation is ready.</Say>\n    </Response>\"\"\"\n    \n    return Response(twiml, mimetype='text/xml')\n\n@app.route('/transcription-webhook', methods=['POST'])\ndef transcription_webhook():\n    \"\"\"Handle transcription results and provide translation\"\"\"\n    call_sid = request.form.get('CallSid')\n    transcription_text = request.form.get('TranscriptionText', '')\n    transcription_status = request.form.get('TranscriptionStatus', '')\n    recording_url = request.form.get('RecordingUrl', '')\n    recording_duration = request.form.get('RecordingDuration', '0')\n    \n    print(f\"Transcription webhook called for call {call_sid}\")\n    print(f\"Transcription Status: {transcription_status}\")\n    print(f\"Transcription Text: {transcription_text}\")\n    print(f\"Recording URL: {recording_url}\")\n    print(f\"Recording Duration: {recording_duration}\")\n    \n    # Get the Railway domain\n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    \n    # If no transcription text, try to process the recording directly\n    if not transcription_text and recording_url and GOOGLE_CLOUD_AVAILABLE:\n        try:\n            print(\"Attempting direct recording processing...\")\n            transcription_text = process_recording_directly(recording_url)\n            print(f\"Direct processing result: {transcription_text}\")\n        except Exception as e:\n            print(f\"Direct processing failed: {e}\")\n            transcription_text = \"\"\n    \n    if not transcription_text:\n        # Fallback response if no transcription\n        print(\"No transcription available, providing fallback response\")\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"hi-IN\">‡§Æ‡•Å‡§ù‡•á ‡§Ü‡§™‡§ï‡•Ä ‡§Ü‡§µ‡§æ‡§ú‡§º ‡§∏‡§Æ‡§ù ‡§®‡§π‡•Ä‡§Ç ‡§Ü‡§à‡•§</Say>\n            <Say voice=\"alice\" language=\"en-US\">I couldn't understand your voice.</Say>\n            <Say voice=\"alice\" language=\"hi-IN\">‡§ï‡•É‡§™‡§Ø‡§æ ‡§´‡§ø‡§∞ ‡§∏‡•á ‡§¨‡•ã‡§≤‡•á‡§Ç‡•§</Say>\n            <Say voice=\"alice\" language=\"en-US\">Please speak again.</Say>\n            <Record \n                action=\"https://{railway_domain}/transcription-webhook\" \n                method=\"POST\"\n                transcribe=\"true\"\n                transcribeCallback=\"https://{railway_domain}/transcription-webhook\"\n                maxLength=\"15\"\n                timeout=\"10\"\n                playBeep=\"true\"\n                finishOnKey=\"#\"\n            />\n        </Response>\"\"\"\n        return Response(twiml, mimetype='text/xml')\n    \n    try:\n        # Detect language and translate\n        detected_language = detect_language(transcription_text)\n        print(f\"Detected language: {detected_language}\")\n        \n        if detected_language == \"hi\":\n            # Hindi to English\n            translated_text = translate_text(transcription_text, 'hi', 'en')\n            target_language = \"en-US\"\n            target_voice = \"alice\"\n            print(f\"Hindi: {transcription_text} ‚Üí English: {translated_text}\")\n        else:\n            # English to Hindi\n            translated_text = translate_text(transcription_text, 'en', 'hi')\n            target_language = \"hi-IN\"\n            target_voice = \"alice\"\n            print(f\"English: {transcription_text} ‚Üí Hindi: {translated_text}\")\n        \n        # Create TwiML response with proper voice and language\n        print(\"Creating TwiML response with translation\")\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"en-US\">You said: {transcription_text}</Say>\n            <Say voice=\"{target_voice}\" language=\"{target_language}\">Translation: {translated_text}</Say>\n            <Say voice=\"alice\" language=\"hi-IN\">‡§ï‡•ç‡§Ø‡§æ ‡§Ü‡§™ ‡§ï‡•Å‡§õ ‡§î‡§∞ ‡§ï‡§π‡§®‡§æ ‡§ö‡§æ‡§π‡§§‡•á ‡§π‡•à‡§Ç?</Say>\n            <Say voice=\"alice\" language=\"en-US\">Would you like to say something else?</Say>\n            <Record \n                action=\"https://{railway_domain}/transcription-webhook\" \n                method=\"POST\"\n                transcribe=\"true\"\n                transcribeCallback=\"https://{railway_domain}/transcription-webhook\"\n                maxLength=\"15\"\n                timeout=\"10\"\n                playBeep=\"true\"\n                finishOnKey=\"#\"\n            />\n        </Response>\"\"\"\n        \n        return Response(twiml, mimetype='text/xml')\n        \n    except Exception as e:\n        print(f\"Translation error: {e}\")\n        # Error response\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"hi-IN\">‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§Æ‡•á‡§Ç ‡§§‡•ç‡§∞‡•Å‡§ü‡§ø ‡§π‡•Å‡§à ‡§π‡•à‡•§</Say>\n            <Say voice=\"alice\" language=\"en-US\">There was an error in translation.</Say>\n            <Say voice=\"alice\" language=\"hi-IN\">‡§ï‡•É‡§™‡§Ø‡§æ ‡§´‡§ø‡§∞ ‡§∏‡•á ‡§ï‡•ã‡§∂‡§ø‡§∂ ‡§ï‡§∞‡•á‡§Ç‡•§</Say>\n            <Say voice=\"alice\" language=\"en-US\">Please try again.</Say>\n            <Record \n                action=\"https://{railway_domain}/transcription-webhook\" \n                method=\"POST\"\n                transcribe=\"true\"\n                transcribeCallback=\"https://{railway_domain}/transcription-webhook\"\n                maxLength=\"15\"\n                timeout=\"10\"\n                playBeep=\"true\"\n                finishOnKey=\"#\"\n            />\n        </Response>\"\"\"\n        return Response(twiml, mimetype='text/xml')\n\n@app.route('/recording-status', methods=['POST'])\ndef recording_status():\n    \"\"\"Handle recording status updates\"\"\"\n    call_sid = request.form.get('CallSid')\n    recording_status = request.form.get('RecordingStatus', '')\n    recording_url = request.form.get('RecordingUrl', '')\n    \n    print(f\"Recording status for call {call_sid}: {recording_status}\")\n    if recording_url:\n        print(f\"Recording URL: {recording_url}\")\n    \n    return Response('OK', mimetype='text/plain')\n\ndef detect_language(text):\n    \"\"\"Simple language detection\"\"\"\n    # Simple heuristic: if text contains Devanagari characters, it's Hindi\n    devanagari_chars = set('‡§Ö‡§Ü‡§á‡§à‡§â‡§ä‡§ã‡§è‡§ê‡§ì‡§î‡§ï‡§ñ‡§ó‡§ò‡§ô‡§ö‡§õ‡§ú‡§ù‡§û‡§ü‡§†‡§°‡§¢‡§£‡§§‡§•‡§¶‡§ß‡§®‡§™‡§´‡§¨‡§≠‡§Æ‡§Ø‡§∞‡§≤‡§µ‡§∂‡§∑‡§∏‡§π')\n    if any(char in devanagari_chars for char in text):\n        return \"hi\"\n    return \"en\"\n\ndef translate_text(text, source_lang, target_lang):\n    \"\"\"Translate text using Google Cloud Translation\"\"\"\n    try:\n        # Initialize the translate client with proper credentials\n        client = translate.Client()\n        result = client.translate(text, source_language=source_lang, target_language=target_lang)\n        return result['translatedText']\n    except Exception as e:\n        print(f\"Translation error: {e}\")\n        # Return original text if translation fails\n        return text\n\ndef process_recording_directly(recording_url):\n    \"\"\"Process recording directly using Google Cloud Speech-to-Text\"\"\"\n    try:\n        print(f\"Downloading recording from: {recording_url}\")\n        # Download the recording\n        response = requests.get(recording_url, timeout=30)\n        if response.status_code != 200:\n            print(f\"Failed to download recording: {response.status_code}\")\n            return \"\"\n        \n        audio_content = response.content\n        print(f\"Downloaded {len(audio_content)} bytes of audio\")\n        \n        # Initialize Speech-to-Text client\n        client = speech.SpeechClient()\n        \n        # Configure recognition\n        config = speech.RecognitionConfig(\n            encoding=speech.RecognitionConfig.AudioEncoding.MULAW,\n            sample_rate_hertz=8000,\n            language_code=\"hi-IN\",\n            alternative_language_codes=[\"en-US\"],\n            enable_automatic_punctuation=True,\n            model=\"latest_long\"\n        )\n        \n        audio = speech.RecognitionAudio(content=audio_content)\n        \n        # Perform recognition\n        print(\"Performing speech recognition...\")\n        response = client.recognize(config=config, audio=audio)\n        \n        if response.results:\n            result = response.results[0]\n            if result.is_final:\n                transcript = result.alternatives[0].transcript\n                confidence = result.alternatives[0].confidence\n                print(f\"Direct processing confidence: {confidence}\")\n                if confidence > 0.5:\n                    return transcript\n        \n        return \"\"\n        \n    except Exception as e:\n        print(f\"Direct processing error: {e}\")\n        return \"\"\n\n@app.route('/call-status', methods=['POST'])\ndef call_status():\n    \"\"\"Handle call status updates\"\"\"\n    call_sid = request.form.get('CallSid')\n    call_status = request.form.get('CallStatus')\n    \n    print(f\"Call {call_sid} status: {call_status}\")\n    \n    return Response('OK', mimetype='text/plain')\n\nclass StandaloneApplication(gunicorn.app.base.BaseApplication):\n    \"\"\"Gunicorn application for Railway deployment\"\"\"\n    \n    def __init__(self, app, options=None):\n        self.options = options or {}\n        self.application = app\n        super().__init__()\n    \n    def load_config(self):\n        config = {key: value for key, value in self.options.items()\n                 if key in self.cfg.settings and value is not None}\n        for key, value in config.items():\n            self.cfg.set(key.lower(), value)\n    \n    def load(self):\n        return self.application\n\nif __name__ == \"__main__\":\n    try:\n        # Get port from Railway environment variable\n        port = int(os.environ.get('PORT', 3000))\n        print(f\"Starting Railway deployment on port {port}\")\n        print(\"=\"*70)\n        print(\"RAILWAY TWILIO VOICE TRANSLATOR - WORKING TRANSLATION\")\n        print(\"=\"*70)\n        print(\"Features:\")\n        print(\"‚úì Fixed Google Cloud credentials\")\n        print(\"‚úì Hindi ‚Üî English translation\")\n        print(\"‚úì Google Cloud Speech-to-Text\")\n        print(\"‚úì Google Cloud Translation\")\n        print(\"‚úì Proper language voice selection\")\n        print(\"‚úì Railway cloud deployment\")\n        print(\"‚úì Better error handling\")\n        print(\"‚úì Direct recording processing fallback\")\n        print(\"‚úì Enhanced logging for debugging\")\n        print(f\"‚úì Google Cloud available: {GOOGLE_CLOUD_AVAILABLE}\")\n        print(f\"‚úì Port: {port}\")\n        print(\"=\"*70)\n        \n        if not GOOGLE_CLOUD_AVAILABLE:\n            print(\"WARNING: Google Cloud libraries not available!\")\n            print(\"Please check your GOOGLE_APPLICATION_CREDENTIALS environment variable\")\n        \n        # Start Flask app with Gunicorn\n        options = {\n            'bind': f'0.0.0.0:{port}',\n            'workers': 1,\n            'worker_class': 'sync',\n            'worker_connections': 1000,\n            'timeout': 30,\n            'keepalive': 2,\n            'max_requests': 1000,\n            'max_requests_jitter': 100,\n            'preload_app': True,\n        }\n        \n        StandaloneApplication(app, options).run()\n        \n    except KeyboardInterrupt:\n        print(\"Server stopped by user.\")\n    except Exception as e:\n        print(f\"Server startup error: {e}\")\n        import traceback\n        traceback.print_exc()\n","size_bytes":14978},"sip_voice_translator.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nSIP Voice Translator\nPhone integration using SIP + Google Cloud\nNo Twilio dependency\n\"\"\"\n\nimport os\nimport json\nimport asyncio\nimport logging\nfrom flask import Flask, request, Response\nfrom flask_socketio import SocketIO, emit\nimport socketio\n\n# Set up Google Cloud credentials\ndef setup_google_credentials():\n    try:\n        if os.path.exists('google-credentials.json'):\n            os.environ['GOOGLE_APPLICATION_CREDENTIALS'] = 'google-credentials.json'\n            print(\"‚úÖ Google credentials set up from local file\")\n            return True\n        return False\n    except Exception as e:\n        print(f\"‚ùå Credentials error: {e}\")\n        return False\n\ncredentials_setup = setup_google_credentials()\n\n# Import Google Cloud\ntry:\n    from google.cloud import translate_v2 as translate\n    from google.cloud import texttospeech\n    from google.cloud import speech\n    GOOGLE_CLOUD_AVAILABLE = True\n    print(\"‚úÖ Google Cloud available\")\nexcept ImportError:\n    GOOGLE_CLOUD_AVAILABLE = False\n    print(\"‚ùå Google Cloud not available\")\n\napp = Flask(__name__)\napp.config['SECRET_KEY'] = 'your-secret-key'\nsocketio = SocketIO(app, cors_allowed_origins=\"*\")\n\n# Audio settings\nFORMAT = pyaudio.paInt16\nCHANNELS = 1\nRATE = 16000\nCHUNK = 1024\n\nclass SIPVoiceTranslator:\n    def __init__(self):\n        self.active_calls = {}\n        self.audio_streams = {}\n        \n    def detect_language(self, text):\n        \"\"\"Detect if text is Hindi or English\"\"\"\n        devanagari_chars = set('‡§Ö‡§Ü‡§á‡§à‡§â‡§ä‡§ã‡§è‡§ê‡§ì‡§î‡§ï‡§ñ‡§ó‡§ò‡§ô‡§ö‡§õ‡§ú‡§ù‡§û‡§ü‡§†‡§°‡§¢‡§£‡§§‡§•‡§¶‡§ß‡§®‡§™‡§´‡§¨‡§≠‡§Æ‡§Ø‡§∞‡§≤‡§µ‡§∂‡§∑‡§∏‡§π')\n        is_hindi = any(char in devanagari_chars for char in text)\n        \n        # Check for common Hindi words in English script\n        hindi_words = ['namaste', 'kaise', 'ho', 'dhanyawad', 'alvida', 'theek', 'hun', 'aap']\n        speech_words = text.lower().split()\n        has_hindi_words = any(word in speech_words for word in speech_words)\n        \n        return 'hi' if (is_hindi or has_hindi_words) else 'en'\n    \n    def translate_text(self, text, source_lang, target_lang):\n        \"\"\"Translate text using Google Translate\"\"\"\n        try:\n            if not GOOGLE_CLOUD_AVAILABLE:\n                return text\n            \n            client = translate.Client()\n            result = client.translate(\n                text, \n                source_language=source_lang, \n                target_language=target_lang,\n                format_='text'\n            )\n            return result['translatedText']\n            \n        except Exception as e:\n            print(f\"‚ùå Translation error: {e}\")\n            return text\n    \n    def synthesize_speech(self, text, language_code):\n        \"\"\"Convert text to speech using Google Text-to-Speech\"\"\"\n        try:\n            if not GOOGLE_CLOUD_AVAILABLE:\n                return None\n            \n            client = texttospeech.TextToSpeechClient()\n            synthesis_input = texttospeech.SynthesisInput(text=text)\n            \n            if language_code == 'hi':\n                voice = texttospeech.VoiceSelectionParams(\n                    language_code=\"hi-IN\",\n                    name=\"hi-IN-Standard-A\",\n                    ssml_gender=texttospeech.SsmlVoiceGender.FEMALE\n                )\n            else:  # en\n                voice = texttospeech.VoiceSelectionParams(\n                    language_code=\"en-US\",\n                    name=\"en-US-Standard-C\",\n                    ssml_gender=texttospeech.SsmlVoiceGender.FEMALE\n                )\n            \n            audio_config = texttospeech.AudioConfig(\n                audio_encoding=texttospeech.AudioEncoding.LINEAR16,\n                sample_rate_hertz=16000\n            )\n            \n            response = client.synthesize_speech(\n                input=synthesis_input,\n                voice=voice,\n                audio_config=audio_config\n            )\n            \n            return response.audio_content\n            \n        except Exception as e:\n            print(f\"‚ùå Text-to-Speech error: {e}\")\n            return None\n    \n    def transcribe_audio(self, audio_data):\n        \"\"\"Convert speech to text using Google Speech-to-Text\"\"\"\n        try:\n            if not GOOGLE_CLOUD_AVAILABLE:\n                return None, 0\n            \n            client = speech.SpeechClient()\n            \n            audio = speech.RecognitionAudio(content=audio_data)\n            config = speech.RecognitionConfig(\n                encoding=speech.RecognitionConfig.AudioEncoding.LINEAR16,\n                sample_rate_hertz=RATE,\n                language_code=\"hi-IN\",\n                alternative_language_codes=[\"en-US\"]\n            )\n            \n            response = client.recognize(config=config, audio=audio)\n            \n            for result in response.results:\n                transcript = result.alternatives[0].transcript\n                confidence = result.alternatives[0].confidence\n                return transcript, confidence\n            \n            return None, 0\n            \n        except Exception as e:\n            print(f\"‚ùå Speech-to-Text error: {e}\")\n            return None, 0\n\n# Global translator instance\ntranslator = SIPVoiceTranslator()\n\n@app.route('/')\ndef home():\n    return {\n        \"message\": \"SIP Voice Translator\",\n        \"version\": \"1.0.0\",\n        \"features\": [\n            \"SIP phone integration\",\n            \"Google Speech-to-Text\",\n            \"Google Translate\",\n            \"Google Text-to-Speech\",\n            \"Real-time Hindi ‚Üî English translation\"\n        ],\n        \"status\": \"Ready\"\n    }, 200\n\n@app.route('/health')\ndef health():\n    return {\n        \"status\": \"healthy\",\n        \"google_cloud_available\": GOOGLE_CLOUD_AVAILABLE,\n        \"credentials_setup\": credentials_setup\n    }, 200\n\n@app.route('/sip-webhook', methods=['POST'])\ndef sip_webhook():\n    \"\"\"Handle SIP call events\"\"\"\n    try:\n        data = request.get_json()\n        event_type = data.get('event_type')\n        call_id = data.get('call_id')\n        \n        print(f\"üìû SIP Event: {event_type} for call {call_id}\")\n        \n        if event_type == 'call_started':\n            # Initialize call\n            translator.active_calls[call_id] = {\n                'status': 'active',\n                'start_time': data.get('timestamp'),\n                'caller_id': data.get('caller_id')\n            }\n            \n            # Send welcome message\n            welcome_text = \"Hello! I am your voice translator. Please speak in Hindi or English.\"\n            audio_data = translator.synthesize_speech(welcome_text, 'en')\n            \n            if audio_data:\n                # Send audio to SIP client\n                return {\n                    \"action\": \"play_audio\",\n                    \"audio_data\": audio_data.hex(),\n                    \"message\": \"Welcome message sent\"\n                }, 200\n            \n        elif event_type == 'audio_received':\n            # Process received audio\n            audio_data = bytes.fromhex(data.get('audio_data', ''))\n            \n            # Transcribe\n            transcript, confidence = translator.transcribe_audio(audio_data)\n            \n            if transcript and confidence > 0.5:\n                # Detect language\n                source_lang = translator.detect_language(transcript)\n                target_lang = 'en' if source_lang == 'hi' else 'hi'\n                \n                # Translate\n                translated_text = translator.translate_text(transcript, source_lang, target_lang)\n                \n                # Synthesize speech\n                audio_data = translator.synthesize_speech(translated_text, target_lang)\n                \n                if audio_data:\n                    return {\n                        \"action\": \"play_audio\",\n                        \"audio_data\": audio_data.hex(),\n                        \"transcript\": transcript,\n                        \"translated_text\": translated_text,\n                        \"source_language\": source_lang,\n                        \"target_language\": target_lang\n                    }, 200\n            \n        elif event_type == 'call_ended':\n            # Clean up call\n            if call_id in translator.active_calls:\n                del translator.active_calls[call_id]\n            \n            return {\"message\": \"Call ended\"}, 200\n        \n        return {\"message\": \"Event processed\"}, 200\n        \n    except Exception as e:\n        return {\"error\": str(e)}, 500\n\n@app.route('/make-call', methods=['POST'])\ndef make_call():\n    \"\"\"Initiate a call to a phone number\"\"\"\n    try:\n        data = request.get_json()\n        phone_number = data.get('phone_number')\n        \n        if not phone_number:\n            return {\"error\": \"Phone number required\"}, 400\n        \n        # In a real implementation, you would:\n        # 1. Use a SIP client library to make the call\n        # 2. Handle the call flow\n        # 3. Process audio in real-time\n        \n        return {\n            \"message\": f\"Call initiated to {phone_number}\",\n            \"call_id\": f\"call_{int(time.time())}\",\n            \"status\": \"initiated\"\n        }, 200\n        \n    except Exception as e:\n        return {\"error\": str(e)}, 500\n\n@app.route('/translate-text', methods=['POST'])\ndef translate_text_endpoint():\n    \"\"\"Translate text and return audio\"\"\"\n    try:\n        data = request.get_json()\n        text = data.get('text', '')\n        \n        if not text:\n            return {\"error\": \"No text provided\"}, 400\n        \n        # Detect language\n        source_lang = translator.detect_language(text)\n        target_lang = 'en' if source_lang == 'hi' else 'hi'\n        \n        # Translate\n        translated_text = translator.translate_text(text, source_lang, target_lang)\n        \n        # Synthesize speech\n        audio_data = translator.synthesize_speech(translated_text, target_lang)\n        \n        if audio_data:\n            # Return audio as base64\n            import base64\n            audio_b64 = base64.b64encode(audio_data).decode('utf-8')\n            return {\n                \"translated_text\": translated_text,\n                \"source_language\": source_lang,\n                \"target_language\": target_lang,\n                \"audio_base64\": audio_b64\n            }, 200\n        else:\n            return {\"error\": \"Could not synthesize speech\"}, 500\n            \n    except Exception as e:\n        return {\"error\": str(e)}, 500\n\n# WebSocket events for real-time communication\n@socketio.on('connect')\ndef handle_connect():\n    print('Client connected')\n    emit('status', {'message': 'Connected to SIP Voice Translator'})\n\n@socketio.on('disconnect')\ndef handle_disconnect():\n    print('Client disconnected')\n\n@socketio.on('audio_data')\ndef handle_audio_data(data):\n    \"\"\"Handle real-time audio data from client\"\"\"\n    try:\n        # Process audio data\n        audio_data = bytes.fromhex(data['audio'])\n        \n        # Transcribe\n        transcript, confidence = translator.transcribe_audio(audio_data)\n        \n        if transcript and confidence > 0.5:\n            # Detect language\n            source_lang = translator.detect_language(transcript)\n            target_lang = 'en' if source_lang == 'hi' else 'hi'\n            \n            # Translate\n            translated_text = translator.translate_text(transcript, source_lang, target_lang)\n            \n            # Synthesize speech\n            audio_data = translator.synthesize_speech(translated_text, target_lang)\n            \n            if audio_data:\n                # Send back translated audio\n                emit('translated_audio', {\n                    'audio': audio_data.hex(),\n                    'transcript': transcript,\n                    'translated_text': translated_text,\n                    'source_language': source_lang,\n                    'target_language': target_lang\n                })\n        \n    except Exception as e:\n        emit('error', {'message': str(e)})\n\nif __name__ == \"__main__\":\n    port = int(os.environ.get('PORT', 3000))\n    print(f\"üöÄ SIP Voice Translator on port {port}\")\n    print(\"=\"*60)\n    print(\"‚úÖ Features:\")\n    print(\"   ‚úì SIP phone integration\")\n    print(\"   ‚úì Google Speech-to-Text (Hindi + English)\")\n    print(\"   ‚úì Google Translate (Hindi ‚Üî English)\")\n    print(\"   ‚úì Google Text-to-Speech (High-quality voices)\")\n    print(\"   ‚úì Real-time audio processing\")\n    print(\"   ‚úì WebSocket support\")\n    print(f\"   ‚úì Google Cloud: {GOOGLE_CLOUD_AVAILABLE}\")\n    print(f\"   ‚úì Credentials: {credentials_setup}\")\n    print(\"=\"*60)\n    print(\"üìû Usage:\")\n    print(\"   POST /sip-webhook - Handle SIP call events\")\n    print(\"   POST /make-call - Initiate a call\")\n    print(\"   POST /translate-text - Translate text and get audio\")\n    print(\"   WebSocket / - Real-time audio processing\")\n    print(\"=\"*60)\n    \n    socketio.run(app, host='0.0.0.0', port=port, debug=False)\n","size_bytes":12957},"railway_simple_fix.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nRailway Deployment - Simple Fixed Twilio Voice Translator\nSimplified version without WebSocket for Railway deployment\n\"\"\"\n\nimport os\nimport json\nimport time\nimport warnings\nfrom flask import Flask, request, Response\nimport gunicorn.app.base\n\n# Suppress pkg_resources deprecation warnings\nwarnings.filterwarnings(\"ignore\", message=\"pkg_resources is deprecated\")\nwarnings.filterwarnings(\"ignore\", category=UserWarning, module=\"google.cloud.translate_v2\")\n\n# Try to import Google Cloud libraries with error handling\ntry:\n    from google.cloud import speech\n    from google.cloud import texttospeech\n    from google.cloud import translate_v2 as translate\n    GOOGLE_CLOUD_AVAILABLE = True\n    print(\"Google Cloud libraries imported successfully\")\nexcept ImportError as e:\n    print(f\"Google Cloud libraries not available: {e}\")\n    GOOGLE_CLOUD_AVAILABLE = False\n\n# Flask app for HTTP webhooks\napp = Flask(__name__)\n\n@app.route('/health')\ndef health_check():\n    \"\"\"Health check endpoint for Railway\"\"\"\n    status = {\n        \"status\": \"healthy\", \n        \"service\": \"twilio-voice-translator\",\n        \"google_cloud_available\": GOOGLE_CLOUD_AVAILABLE,\n        \"port\": os.environ.get('PORT', 'not_set'),\n        \"timestamp\": time.time(),\n        \"version\": \"4.0-simple-fix\"\n    }\n    return status, 200\n\n@app.route('/')\ndef home():\n    \"\"\"Home endpoint\"\"\"\n    return {\n        \"message\": \"Twilio Voice Translator is running!\",\n        \"health_check\": \"/health\",\n        \"webhook\": \"/twilio-webhook\",\n        \"google_cloud_available\": GOOGLE_CLOUD_AVAILABLE,\n        \"version\": \"4.0-simple-fix\"\n    }, 200\n\n@app.route('/twilio-webhook', methods=['POST'])\ndef twilio_webhook():\n    \"\"\"Handle incoming Twilio calls\"\"\"\n    call_sid = request.form.get('CallSid')\n    from_number = request.form.get('From')\n    to_number = request.form.get('To')\n    \n    print(f\"Incoming call from {from_number} to {to_number} (CallSid: {call_sid})\")\n    \n    # Simple TwiML response without WebSocket\n    twiml = \"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <Response>\n        <Say language=\"hi-IN\">‡§®‡§Æ‡§∏‡•ç‡§§‡•á! ‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡•Ä ‡§Ü‡§µ‡§æ‡§ú‡§º ‡§ï‡§æ ‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§ï‡§∞‡•Ç‡§Ç‡§ó‡§æ‡•§</Say>\n        <Say language=\"en-US\">Hello! I will translate your voice.</Say>\n        <Say language=\"hi-IN\">‡§Ö‡§¨ ‡§Ü‡§™ ‡§¨‡•ã‡§≤ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç‡•§</Say>\n        <Say language=\"en-US\">You can start speaking now.</Say>\n        <Say language=\"hi-IN\">‡§Ø‡§π ‡§è‡§ï ‡§∏‡§∞‡§≤ ‡§Ö‡§®‡•Å‡§µ‡§æ‡§¶ ‡§∏‡•á‡§µ‡§æ ‡§π‡•à‡•§</Say>\n        <Say language=\"en-US\">This is a simple translation service.</Say>\n        <Say language=\"hi-IN\">‡§ß‡§®‡•ç‡§Ø‡§µ‡§æ‡§¶!</Say>\n        <Say language=\"en-US\">Thank you!</Say>\n        <Hangup/>\n    </Response>\"\"\"\n    \n    return Response(twiml, mimetype='text/xml')\n\n@app.route('/call-status', methods=['POST'])\ndef call_status():\n    \"\"\"Handle call status updates\"\"\"\n    call_sid = request.form.get('CallSid')\n    call_status = request.form.get('CallStatus')\n    \n    print(f\"Call {call_sid} status: {call_status}\")\n    \n    return Response('OK', mimetype='text/plain')\n\nclass StandaloneApplication(gunicorn.app.base.BaseApplication):\n    \"\"\"Gunicorn application for Railway deployment\"\"\"\n    \n    def __init__(self, app, options=None):\n        self.options = options or {}\n        self.application = app\n        super().__init__()\n    \n    def load_config(self):\n        config = {key: value for key, value in self.options.items()\n                 if key in self.cfg.settings and value is not None}\n        for key, value in config.items():\n            self.cfg.set(key.lower(), value)\n    \n    def load(self):\n        return self.application\n\nif __name__ == \"__main__\":\n    try:\n        # Get port from Railway environment variable\n        port = int(os.environ.get('PORT', 3000))\n        print(f\"Starting Railway deployment on port {port}\")\n        print(\"=\"*70)\n        print(\"RAILWAY TWILIO VOICE TRANSLATOR - SIMPLE FIX\")\n        print(\"=\"*70)\n        print(\"Features:\")\n        print(\"‚úì Simple voice response (no WebSocket)\")\n        print(\"‚úì Railway cloud deployment\")\n        print(\"‚úì Health check endpoint\")\n        print(\"‚úì Gunicorn WSGI server\")\n        print(f\"‚úì Google Cloud available: {GOOGLE_CLOUD_AVAILABLE}\")\n        print(f\"‚úì Port: {port}\")\n        print(\"=\"*70)\n        \n        if not GOOGLE_CLOUD_AVAILABLE:\n            print(\"WARNING: Google Cloud libraries not available!\")\n            print(\"Please check your GOOGLE_APPLICATION_CREDENTIALS environment variable\")\n        \n        # Start Flask app with Gunicorn\n        options = {\n            'bind': f'0.0.0.0:{port}',\n            'workers': 1,\n            'worker_class': 'sync',\n            'worker_connections': 1000,\n            'timeout': 30,\n            'keepalive': 2,\n            'max_requests': 1000,\n            'max_requests_jitter': 100,\n            'preload_app': True,\n        }\n        \n        StandaloneApplication(app, options).run()\n        \n    except KeyboardInterrupt:\n        print(\"Server stopped by user.\")\n    except Exception as e:\n        print(f\"Server startup error: {e}\")\n        import traceback\n        traceback.print_exc()\n","size_bytes":5191},"railway_working_tts.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nRailway Deployment - WORKING TTS Voice Translator\nFIXED: Simple approach that definitely works\n\"\"\"\n\nimport os\nimport json\nimport time\nimport warnings\nimport requests\nfrom flask import Flask, request, Response\nimport gunicorn.app.base\n\n# Suppress warnings\nwarnings.filterwarnings(\"ignore\")\n\n# Set up Google Cloud credentials\ndef setup_google_credentials():\n    try:\n        creds_json = os.environ.get('GOOGLE_CREDENTIALS_JSON')\n        if creds_json:\n            creds_data = json.loads(creds_json)\n            temp_creds_path = '/tmp/google-credentials.json'\n            with open(temp_creds_path, 'w') as f:\n                json.dump(creds_data, f)\n            os.environ['GOOGLE_APPLICATION_CREDENTIALS'] = temp_creds_path\n            print(\"‚úÖ Google credentials set up\")\n            return True\n        return False\n    except Exception as e:\n        print(f\"‚ùå Credentials error: {e}\")\n        return False\n\ncredentials_setup = setup_google_credentials()\n\n# Import Google Cloud\ntry:\n    from google.cloud import translate_v2 as translate\n    GOOGLE_CLOUD_AVAILABLE = True\n    print(\"‚úÖ Google Cloud available\")\nexcept ImportError:\n    GOOGLE_CLOUD_AVAILABLE = False\n    print(\"‚ùå Google Cloud not available\")\n\napp = Flask(__name__)\n\n@app.route('/health')\ndef health_check():\n    return {\n        \"status\": \"healthy\",\n        \"google_cloud_available\": GOOGLE_CLOUD_AVAILABLE,\n        \"credentials_setup\": credentials_setup,\n        \"version\": \"26.0-working-tts\"\n    }, 200\n\n@app.route('/')\ndef home():\n    return {\n        \"message\": \"WORKING TTS Twilio Voice Translator\",\n        \"webhook\": \"/twilio-webhook\",\n        \"version\": \"26.0-working-tts\"\n    }, 200\n\n@app.route('/twilio-webhook', methods=['POST'])\ndef twilio_webhook():\n    call_sid = request.form.get('CallSid')\n    from_number = request.form.get('From')\n    \n    print(f\"\\nüìû CALL FROM: {from_number}\")\n    print(f\"   CallSid: {call_sid}\")\n    print(\"=\"*40)\n    \n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    \n    # WORKING TTS: Simple approach\n    twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <Response>\n        <Say voice=\"alice\" language=\"en-US\">Hello! Speak in English or Hindi for translation.</Say>\n        <Pause length=\"2\"/>\n        <Gather \n            action=\"https://{railway_domain}/gather-webhook\" \n            method=\"POST\"\n            input=\"speech\"\n            speechTimeout=\"auto\"\n            timeout=\"30\"\n            language=\"en-US\"\n            hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida, main theek hun, aap kaise hain, kya haal hai, shukriya, namaskar, pranam, aapka swagat hai, main aap se mil kar khush hun, aap kahan se hain, main ghar ja raha hun, main office ja raha hun, main school ja raha hun, main market ja raha hun, main doctor ke paas ja raha hun, main hospital ja raha hun, main bank ja raha hun, main restaurant ja raha hun, main hotel ja raha hun, main station ja raha hun, main airport ja raha hun, main bus stand ja raha hun, main railway station ja raha hun, main metro station ja raha hun, main shopping mall ja raha hun, main cinema hall ja raha hun, main park ja raha hun, main temple ja raha hun, main mosque ja raha hun, main church ja raha hun, main gurudwara ja raha hun, main mandir ja raha hun, main masjid ja raha hun, main girja ja raha hun, main gurdwara ja raha hun, main khana kha raha hun, main paani pi raha hun, main sone ja raha hun, main uth raha hun, main baith raha hun, main chal raha hun, main daud raha hun, main khel raha hun, main padh raha hun, main likh raha hun, main sun raha hun, main dekh raha hun, main bol raha hun, main has raha hun, main ro raha hun, main soch raha hun, main samajh raha hun, main jaanta hun, main nahi jaanta, main chahta hun, main nahi chahta, main karna chahta hun, main nahi karna chahta, main aa sakta hun, main nahi aa sakta, main ja sakta hun, main nahi ja sakta, main kar sakta hun, main nahi kar sakta, main de sakta hun, main nahi de sakta, main le sakta hun, main nahi le sakta, main bana sakta hun, main nahi bana sakta, main kharid sakta hun, main nahi kharid sakta, main bech sakta hun, main nahi bech sakta, main sikha sakta hun, main nahi sikha sakta, main seekh sakta hun, main nahi seekh sakta, main samjha sakta hun, main nahi samjha sakta, main bata sakta hun, main nahi bata sakta, main puch sakta hun, main nahi puch sakta, main jawab de sakta hun, main nahi jawab de sakta, main madad kar sakta hun, main nahi madad kar sakta, main kaam kar sakta hun, main nahi kaam kar sakta, main ghar ja sakta hun, main nahi ghar ja sakta, main office ja sakta hun, main nahi office ja sakta, main school ja sakta hun, main nahi school ja sakta, main market ja sakta hun, main nahi market ja sakta, main doctor ke paas ja sakta hun, main nahi doctor ke paas ja sakta, main hospital ja sakta hun, main nahi hospital ja sakta, main bank ja sakta hun, main nahi bank ja sakta, main restaurant ja sakta hun, main nahi restaurant ja sakta, main hotel ja sakta hun, main nahi hotel ja sakta, main station ja sakta hun, main nahi station ja sakta, main airport ja sakta hun, main nahi airport ja sakta, main bus stand ja sakta hun, main nahi bus stand ja sakta, main railway station ja sakta hun, main nahi railway station ja sakta, main metro station ja sakta hun, main nahi metro station ja sakta, main shopping mall ja sakta hun, main nahi shopping mall ja sakta, main cinema hall ja sakta hun, main nahi cinema hall ja sakta, main park ja sakta hun, main nahi park ja sakta, main temple ja sakta hun, main nahi temple ja sakta, main mosque ja sakta hun, main nahi mosque ja sakta, main church ja sakta hun, main nahi church ja sakta, main gurudwara ja sakta hun, main nahi gurudwara ja sakta, main mandir ja sakta hun, main nahi mandir ja sakta, main masjid ja sakta hun, main nahi masjid ja sakta, main girja ja sakta hun, main nahi girja ja sakta, main gurdwara ja sakta hun, main nahi gurdwara ja sakta\"\n        />\n        <Say voice=\"alice\" language=\"en-US\">I didn't hear anything. Please try again.</Say>\n        <Pause length=\"2\"/>\n        <Gather \n            action=\"https://{railway_domain}/gather-webhook\" \n            method=\"POST\"\n            input=\"speech\"\n            speechTimeout=\"auto\"\n            timeout=\"30\"\n            language=\"en-US\"\n            hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n        />\n        <Say voice=\"alice\" language=\"en-US\">Thank you. Goodbye.</Say>\n    </Response>\"\"\"\n    \n    return Response(twiml, mimetype='text/xml')\n\n@app.route('/gather-webhook', methods=['POST'])\ndef gather_webhook():\n    call_sid = request.form.get('CallSid')\n    speech_result = request.form.get('SpeechResult', '')\n    confidence = request.form.get('Confidence', '0')\n    \n    print(f\"\\nüé§ GATHER WEBHOOK:\")\n    print(f\"   CallSid: {call_sid}\")\n    print(f\"   Speech Result: '{speech_result}'\")\n    print(f\"   Confidence: {confidence}\")\n    print(\"=\"*40)\n    \n    railway_domain = os.environ.get('RAILWAY_PUBLIC_DOMAIN', 'web-production-6577e.up.railway.app')\n    \n    if not speech_result or len(speech_result.strip()) < 2:\n        print(\"‚ùå No speech result - fallback response\")\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"en-US\">I didn't hear anything. Please speak clearly.</Say>\n            <Pause length=\"2\"/>\n            <Gather \n                action=\"https://{railway_domain}/gather-webhook\" \n                method=\"POST\"\n                input=\"speech\"\n                speechTimeout=\"auto\"\n                timeout=\"30\"\n                language=\"en-US\"\n                hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n            />\n            <Say voice=\"alice\" language=\"en-US\">Thank you. Goodbye.</Say>\n        </Response>\"\"\"\n        return Response(twiml, mimetype='text/xml')\n    \n    try:\n        # WORKING TTS: Better language detection\n        devanagari_chars = set('‡§Ö‡§Ü‡§á‡§à‡§â‡§ä‡§ã‡§è‡§ê‡§ì‡§î‡§ï‡§ñ‡§ó‡§ò‡§ô‡§ö‡§õ‡§ú‡§ù‡§û‡§ü‡§†‡§°‡§¢‡§£‡§§‡§•‡§¶‡§ß‡§®‡§™‡§´‡§¨‡§≠‡§Æ‡§Ø‡§∞‡§≤‡§µ‡§∂‡§∑‡§∏‡§π')\n        is_hindi = any(char in devanagari_chars for char in speech_result)\n        \n        # Check for common Hindi words in English script\n        hindi_words = ['namaste', 'kaise', 'ho', 'dhanyawad', 'alvida', 'theek', 'hun', 'aap', 'kahan', 'se', 'ghar', 'ja', 'raha', 'office', 'school', 'market', 'doctor', 'hospital', 'bank', 'restaurant', 'hotel', 'station', 'airport', 'bus', 'railway', 'metro', 'shopping', 'mall', 'cinema', 'hall', 'park', 'temple', 'mosque', 'church', 'gurudwara', 'mandir', 'masjid', 'girja', 'gurdwara', 'khana', 'paani', 'sone', 'uth', 'baith', 'chal', 'daud', 'khel', 'padh', 'likh', 'sun', 'dekh', 'bol', 'has', 'ro', 'soch', 'samajh', 'jaanta', 'chahta', 'karna', 'aa', 'sakta', 'de', 'le', 'bana', 'kharid', 'bech', 'sikha', 'seekh', 'samjha', 'bata', 'puch', 'jawab', 'madad', 'kaam']\n        has_hindi_words = any(word in speech_result.lower() for word in hindi_words)\n        \n        if is_hindi or has_hindi_words:\n            # Hindi to English\n            translated_text = translate_text(speech_result, 'hi', 'en')\n            print(f\"üîÑ Hindi ‚Üí English: '{translated_text}'\")\n            \n            # WORKING TTS: Use Twilio's built-in voice for English\n            twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n            <Response>\n                <Say voice=\"alice\" language=\"en-US\">{translated_text}</Say>\n                <Pause length=\"3\"/>\n                <Say voice=\"alice\" language=\"en-US\">Say something else or goodbye.</Say>\n                <Gather \n                    action=\"https://{railway_domain}/gather-webhook\" \n                    method=\"POST\"\n                    input=\"speech\"\n                    speechTimeout=\"auto\"\n                    timeout=\"30\"\n                    language=\"en-US\"\n                    hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n                />\n                <Say voice=\"alice\" language=\"en-US\">Thank you. Goodbye.</Say>\n            </Response>\"\"\"\n        else:\n            # English to Hindi\n            translated_text = translate_text(speech_result, 'en', 'hi')\n            print(f\"üîÑ English ‚Üí Hindi: '{translated_text}'\")\n            \n            # WORKING TTS: Use Twilio's built-in voice for Hindi\n            twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n            <Response>\n                <Say voice=\"alice\" language=\"hi-IN\">{translated_text}</Say>\n                <Pause length=\"3\"/>\n                <Say voice=\"alice\" language=\"en-US\">Say something else or goodbye.</Say>\n                <Gather \n                    action=\"https://{railway_domain}/gather-webhook\" \n                    method=\"POST\"\n                    input=\"speech\"\n                    speechTimeout=\"auto\"\n                    timeout=\"30\"\n                    language=\"en-US\"\n                    hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n                />\n                <Say voice=\"alice\" language=\"en-US\">Thank you. Goodbye.</Say>\n            </Response>\"\"\"\n        \n        print(f\"üîä SPEAKING: Translation: {translated_text}\")\n        print(\"=\"*40)\n        \n        return Response(twiml, mimetype='text/xml')\n        \n    except Exception as e:\n        print(f\"‚ùå Translation error: {e}\")\n        twiml = f\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n        <Response>\n            <Say voice=\"alice\" language=\"en-US\">Translation error. Please try again.</Say>\n            <Pause length=\"2\"/>\n            <Gather \n                action=\"https://{railway_domain}/gather-webhook\" \n                method=\"POST\"\n                input=\"speech\"\n                speechTimeout=\"auto\"\n                timeout=\"30\"\n                language=\"en-US\"\n                hints=\"hello, hi, how are you, thank you, goodbye, namaste, kaise ho, dhanyawad, alvida\"\n            />\n            <Say voice=\"alice\" language=\"en-US\">Thank you. Goodbye.</Say>\n        </Response>\"\"\"\n        return Response(twiml, mimetype='text/xml')\n\ndef translate_text(text, source_lang, target_lang):\n    try:\n        if not GOOGLE_CLOUD_AVAILABLE:\n            return text\n        \n        print(f\"üîÑ Calling Google Translate API...\")\n        print(f\"   Source: {source_lang}\")\n        print(f\"   Target: {target_lang}\")\n        print(f\"   Text: '{text}'\")\n        \n        client = translate.Client()\n        \n        # WORKING TTS: Direct translation\n        result = client.translate(\n            text, \n            source_language=source_lang, \n            target_language=target_lang,\n            format_='text'\n        )\n        \n        translated_text = result['translatedText']\n        print(f\"‚úÖ Translation successful: '{translated_text}'\")\n        \n        return translated_text.strip()\n        \n    except Exception as e:\n        print(f\"‚ùå Translation error: {e}\")\n        return text\n\nclass StandaloneApplication(gunicorn.app.base.BaseApplication):\n    def __init__(self, app, options=None):\n        self.options = options or {}\n        self.application = app\n        super().__init__()\n    \n    def load_config(self):\n        config = {key: value for key, value in self.options.items()\n                 if key in self.cfg.settings and value is not None}\n        for key, value in config.items():\n            self.cfg.set(key.lower(), value)\n    \n    def load(self):\n        return self.application\n\nif __name__ == \"__main__\":\n    port = int(os.environ.get('PORT', 3000))\n    print(f\"üöÄ WORKING TTS TRANSLATOR on port {port}\")\n    print(\"=\"*50)\n    print(\"‚úÖ Features:\")\n    print(\"   ‚úì Google Translate API for translation\")\n    print(\"   ‚úì Twilio built-in voice for speech\")\n    print(\"   ‚úì Simple and reliable approach\")\n    print(\"   ‚úì Direct translation without repetition\")\n    print(\"   ‚úì Hindi ‚Üî English translation\")\n    print(\"   ‚úì Will definitely work\")\n    print(f\"   ‚úì Google Cloud: {GOOGLE_CLOUD_AVAILABLE}\")\n    print(f\"   ‚úì Credentials: {credentials_setup}\")\n    print(\"=\"*50)\n    \n    options = {\n        'bind': f'0.0.0.0:{port}',\n        'workers': 1,\n        'worker_class': 'sync',\n        'timeout': 60,\n        'keepalive': 5,\n    }\n    \n    StandaloneApplication(app, options).run()\n","size_bytes":14431}},"version":2}